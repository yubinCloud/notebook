---
title: 数据复制（冗余）
date: 2023-01-15 15:08:00
permalink: /pages/DDIA/note/replication/
categories:
  - 数据科学
  - 数据密集型应用系统设计
  - 读书笔记
tags:
  - 
---

本书第一部分讲单机数据系统，现在进入的第二部分讲多机数据系统。

[[toc]]

<mark>冗余</mark>（**Replication**）是指将同一份数据复制多份，放到通过网络互联的多个机器上去。其好处有：

1. **降低访问延迟**：可以在地理上同时接近不同地区的用户。
2. **提高可用性**：当系统部分故障时仍然能够正常提供服务。
3. **提高读吞吐**：扩展至多台机器以同时提供数据访问服务。

> 本章假设我们的数据系统中所有数据能够存放到一台机器中，则本章只需考虑多机冗余的问题，而不考虑分片的问题。

<u>如果数据是只读的，则冗余很好做，直接复制到多机即可</u>。我们有时可以利用这个特性，使用分治策略，将数据分为只读部分和读写部分，则只读部分的冗余就会容易处理的多，甚至可以用 EC 方式做冗余，减小存储放大的同时，还提高了可用性。

> - 想想 EC 牺牲了什么？以计算换存储。

但<u>难点就在于，数据允许数据变更时，如何维护多机冗余且一致</u>。常用的冗余控制算法有：

1. single leader，主从复制
2. multi-leader，多主节点复制
3. leaderless，无主节点复制

这需要在多方面做取舍：

+ 使用同步复制还是异步复制
+ 如何处理失败的副本

数据库冗余问题在学术界不是一个新问题了，但在工业界，大部分人都是新手——分布式数据库是近些年才大规模的在工业界落地的。

## 1. 主节点与从节点

冗余存储的每份数据称为<mark>副本</mark>（**replica**）。多副本所带来的最主要的一个问题是：如何保证所有数据被同步到了所有副本上？

**leader-based replication**（<mark>主从复制</mark>）的同步算法，是最常用解决办法。

1. 其中一个 replica 称为 leader，也称为**主副本**（primary、master）。主副本作为写入的协调者，所有写入都要发给主副本。
2. 其他 replica 称为 follower，也称为**只读副本**（read replicas）、**从副本**（slaves）、**次副本**（secondaries）、**热备**（hot-standby）。主副本将改动写到本地后，将其发送给各个从副本，从副本收变动到后应用到自己状态机，这个过程称为**日志同步**（replication log）、**变更流**（change steam）。
3. 对于读取，客户端可以从主副本和从副本中读取；但写入，客户端只能将请求发到主副本。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230115152251991.png" alt="image-20230115152251991" style="zoom: 50%;" />

> leader 也被称为**主节点**，follower 也被称为**从节点**，因此这种算法也被称为**主从复制**。不论名称叫什么，关键是理解其中的思想。根据习惯，下面通称主副本和从副本。

有很多数据系统都用了此模式：

1. 关系型数据库：PostgreSQL（9.0+）、MySQL 和 Oracle Data Guard 和 SQL Server 的 AlwaysOn
2. 非关系型数据库：MonogoDB、RethinkDB 和 Espresso
3. 消息队列：Kafka 和 RabbitMQ。

### 1.1 同步复制与异步复制

**同步（synchronously）复制**和**异步（asynchronously）复制**和关键区别在于：请求何时返回给客户端。

+ 如果等待某副本写完成后，则该副本为<mark>同步复制</mark>。
+ 如果不等待某副本写完成，则该副本为<mark>异步复制</mark>。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230115152800522.png" alt="image-20230115152800522" style="zoom: 50%;" />

两者的对比：

+ 同步复制牺牲了响应延迟和部分可用性（在某些副本有问题时不能完成写入操作），换取了**所有副本的一致性**（但并不能严格保证）
+ 异步复制放松了一致性，而换来了**较低的写入延迟**和**较高的可用性**。

在实践中，会根据对一致性和可用性的要求，进行取舍。针对所有从副本来说，可以有以下选择：

1. **全同步**：所有的从副本都同步写入。如果副本数过多，可能性能较差，当然也可以做并行化、流水线化处理。
2. **半同步**：（**semi-synchronous**），有一些副本为同步，另一些副本为异步。
3. **全异步**：所有的从副本都异步写入。网络环境比较好的话，可以这么配置。

> 异步复制可能会造成副本丢失等严重问题，为了能兼顾一致性和性能，学术界也在不断研究新的复制方法。如，**链式复制（chain-replication）**。
>
> 多副本的一致性和共识性有诸多联系，本书后面章节会讨论。

### 1.2 配置新的从节点

> 其实，“节点”往往是在说提供 service 的机器，而“副本”是在指逻辑上的数据集。但在文中讲解时，两者会混用。

如果原副本是只读（read-only）的，只需要简单拷贝即可。但是如果是可写副本，则问题要复杂很多。因此，比较简单的一种解决方法是：**禁止写入，然后拷贝**。这在某些情况下很有用，比如夜间没有写入流量，同时一晚上肯定能复制完。但这会违反高可用的设计目标。

但如果要求不停机，则需要另一种解决方法：

1. 主副本在本地做**一致性快照**。何谓一致性？
2. 将快照复制到从副本节点。
3. 从主副本拉取快照之后的操作日志，应用到从副本，这个过程叫做**追赶**。如何知道快照与其后日志的对应关系？序列号。
4. 当从副本赶上主副本进度后，就可以正常跟随主副本了。

这个过程一般是自动化的，比如 Raft，具体操作步骤也因数据库系统而异。也可以手动化，比如写一些脚本。

### 1.3 宕机处理

系统中任何节点都可能在计划内或者计划外宕机（节点失效）。那么如何应对这些宕机情况，保持整个系统的可用性呢？我们的目标是，尽管个别节点会出现中断，但要保持系统总体的持续运行，并尽可能减小节点中断带来的影响。

#### 1.3.1 从节点宕机：追赶恢复

类似于新增从副本。如果落后的多，可以直接向主副本拉取快照+日志；如果落后的少，可以仅拉取缺失日志。

#### 1.3.2 主节点宕机：故障转移

处理相对麻烦，首先要选出新的主副本，然后要通知所有从副本变更。具体来说，包含下面步骤：

1. **确认主副本故障**。要防止由于网络抖动造成的误判。一般会用心跳探活，并设置合理超时（timeout）阈值，超过阈值后没有收到该节点心跳，则认为该节点故障。
2. **选择新的主副本**。新的主副本可以通过**选举**（共识问题）或者**指定**（外部控制程序）来产生。选主时，要保证备选节点数据尽可能的新，以最小化数据损失。
3. **让系统感知新主副本**。系统其他参与方，包括从副本、客户端和旧主副本。前两者不多说，旧主副本在恢复时，需要通过某种手段，让其知道已经失去领导权，避免**脑裂**。

主副本切换时，会遇到很多问题：

1. **新老主副本数据冲突**。新主副本在上位前没有同步完所有日志，旧主副本恢复后，可能会发现和新主副本数据冲突。
2. **相关外部系统冲突**。即新主副本，和使用该副本数据的外部系统冲突。书中举了 github 数据库 MySQL 和缓存系统 redis 冲突的例子。
3. **新老主副本角色冲突**。即新老主副本都以为自己才是主副本，称为**脑裂（split brain）**。如果他们两个都能接受写入，且没有冲突解决机制，数据会丢失或者损坏。有的系统会在检测到脑裂后，关闭其中一个副本，但设计的不好可能将两个主副本都关闭调。反正需要让那些不是 leader 但还自认为是 leader 的节点意识到自己不是 leader 了。
4. **超时阈值选取**。如果超时阈值选取的过小，在不稳定的网络环境中（或者主副本负载过高）可能会造成主副本频繁的切换；如果选取过大，则不能及时进行故障切换，且恢复时间也增长，从而造成服务长时间不可用。

所有上述问题，在不同需求、不同环境、不同时间点，都可能会有不同的解决方案。因此在系统上线初期，不少运维团队更愿意手动进行切换；等积累一定经验后，再进行逐步自动化。

节点故障、不可靠网络、副本一致性、持久化、可用性和延迟之间各种细微的权衡，都是设计分布式系统时，所面临的**分布式系统核心的基本问题**。根据实际情况，对这些问题进行艺术化的取舍，便是分布式系统之美。