## 1. 正则表达式

正则表达式用于字符串的检索、替换和匹配。可以在 [菜鸟正则表达式在线测试](https://c.runoob.com/front-end/854/) 或 [oschina正则表达式测试工具](https://tool.oschina.net/regex) 进行尝试。

Python 的 re 库提供了整个正则表达式的实现，往往选择使用它。第三方模块 [regex](https://pypi.org/project/regex/) , 提供了与标准库 re 模块兼容的 API 接口，同时，还提供了更多功能和更全面的 Unicode 支持。

### 1.1 match

> `re.match(pattern, string, flags=0)`
>
> 会尝试从字符串的**起始位置开始匹配**正则表达式，如果匹配，就返回一个相应的匹配对象 。 如果没有匹配，就返回 `None` ；注意它跟零长度匹配是不同的。
>
> 注意即便是 [`MULTILINE`](https://docs.python.org/zh-cn/3/library/re.html#re.MULTILINE) 多行模式， re.match() 也只匹配字符串的开始位置，而不匹配每行开始。

示例：

```python {5}
import re

content = 'Hello 123 4567 World_This is a Regex Demo'
pattern = '^Hello\s\d\d\d\s\d{4}\s\w{10}'
result = re.match(pattern, content)
print(result.group())
print(result.span())
```

输出：

```
Hello 123 4567 World_This
(0, 25)
```

+ `group` 方法返回匹配的内容

+ `span` 方法返回匹配的范围

#### 匹配目标

如果是想从字符串中提取一部分内容，比如从一段文本中提取出 email 地址，该怎么办？可以使用 () 将向提取的子字符串括起来。

示例：

```python {4}
import re

content = 'Hello 1234567 World_This is a Regex Demo'
pattern = '^Hello\s(\d+)\sWorld'
result = re.match(pattern, content)
print(result.group())
print(result.group(1))
```

输出：

```
Hello 1234567 World
1234567
```

可以看到 pattern 中数字部分的正则表达式被 () 括了起来，这样调用 `group(1)` 获取了匹配结果：

+ `group()` 返回完整的匹配结果
+ `group(1)` 返回第一个被 () 包围的匹配结果

#### 通用匹配

+ `*` 代表匹配前面的字符无限次
+ `.` 代表可以匹配任意字符（除换行符）

#### 贪婪与非贪婪

有时候通用匹配 `.*` 匹配到的内容不是我们想要的，这涉及到贪婪模式和非贪婪模式：

+ **贪婪匹配**是匹配尽可能多的字符
+ **非贪婪匹配**是匹配尽可能少的字符

示例，假如我们仍然向获得目标字符串中间的数字，所以正则表达式中间仍然写 `(\d+)`，两边较为杂乱，所以用 `.*` 来匹配：

```python {4, 5}
import re

content = 'Hello 1234567 World_This is a Regex Demo'
pattern1 = '^He.*(\d+).*Demo$'  # 贪婪匹配
pattern2 = '^He.*?(\d+).*Demo$' # 非贪婪匹配

result1 = re.match(pattern1, content)
result2 = re.match(pattern2, content)

print(result1.group(1))
print(result1.group(1))
```

输出：

```
7
1234567
```

+ 在贪婪匹配下，`.*` 会匹配尽可能多的字符，`.*` 后面是 `\d+`，也就是至少匹配一个数字，但没有规定几个数字，因此，`.*` 会尽可能多的匹配，这里也就把 123456 都匹配了，只给 `\d+` 留下了一个可满足条件的数字 7
+ 非贪婪匹配的写法是 `.*?`，也就是多了一个 `?` ，这里当 `.*?` 匹配到 Hello 后面的空白字符时，再往后就是数字了，可以交给 `(\d+)` 来匹配，于是 `.*?` 就不再匹配了，最终结果是 `(\d+)` 匹配了 1234567

所以说，**在做匹配的时候、字符串中间尽量使用非贪梦匹配**，也就是用 `.*?`代替 `.*`，以免出现匹配结果缺失的情况。

但这里需要**注意，如果匹配的结果在字符串结尾，`.*?` 有可能匹配不到任何内容了，因为它会匹配尽可能少的字符**。例如：

```python
import re
content ='http://weibo.com/comment/kEraCN'
result1 = re.match('http.*?comment/(.*?)', content)
result2 = re.match('http.*?comment/(.*)', content)
print('result1',result1.group(1))
print('result2',result2.group(1))
```

运行结果如下：

```
result1
result2 kEraCN
```

可以观察到，`.*?`没有匹配到任何结果，而 `.*` 则是尽量多匹配内容，成功得到了匹配结果。

#### 修饰符（标记）

正则表达式的标记用于指定额外的匹配策略。

标记不写在正则表达式里，标记位于表达式之外，格式如下：

```
/pattern/flags
```

下表列出了正则表达式常用的修饰符：

| 修饰符 |                  含义                  | 描述                                                         |
| :----: | :------------------------------------: | :----------------------------------------------------------- |
|   i    |         ignore - 不区分大小写          | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 |
|   g    |           global - 全局匹配            | 查找所有的匹配项。                                           |
|   m    |         multi line - 多行匹配          | 使边界字符 **^** 和 **$** 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
|   s    | 特殊字符圆点 **.** 中包含换行符 **\n** | 默认情况下的圆点 **.** 是 匹配除换行符 **\n** 之外的任何字符，加上 **s** 修饰符之后, **.** 中包含换行符 \n。 |

+ 在 `re` 库中，是写在 match 方法的第三个参数里，比如 `re.match(p, s, re.S)`
+ 较为常用的是 re.S 和 re.I

Python 示例：

```python
import re

content = """Hello 1234567 World_This
is a Regex Demo
"""
pattern = '^He.*?(\d+).*Demo$'

result1 = re.match(pattern, content)
print(result1.group(1))
```

运行后会报错，因为未匹配成功导致 match 返回一个 None，在 None 上调用 group 引发错误。这里 `.*` 无法匹配换行符，我们再加一个修饰符 `re.S` 便可以得到解决：

```python
result2 = re.match(pattern, content, re.S)
print(result2.group(1))
```

<u>这个 re.S 在网页匹配中经常用到，因为 HTML 节点经常会有换行，加上他，就可以匹配节点与节点之间的换行了</u>。

#### 转义匹配

当在目标字符串中遇到用作正则匹配模式的特殊字符时，在此字符前面加上反斜线 `\` 转义一下即可。比如 `\.` 可以匹配 `.`。

### 1.2 search 和 findall

match 是从字符串的开头开始匹配的，意味着一旦开头不匹配，整个匹配就失败了。

* **search** 会在匹配时扫描整个字符串，然后返回第一个匹配成功的结果，如果扫描完都没有找到，那返回 None
* **findall** 获取与正则表达式相匹配的所有字符串，其返回结果是列表类型

如果只想获取匹配的第一个字符串，可以用 search 方法，如果需要提取多个内容，可以用 findall 方法。

### 1.3 sub

除了使用正则表达式提取信息，有时候还需要借助它来**修改文本**。例如，想要把一串文本中的所有数字都去掉，如果只用字符串的 replace 方法，未免太烦琐了，这时可以借助 sub 方法。实例如下：

```python
import re
content = '54aK54yr50iR54ix5L2g'
content = re.sub('\d+', '', content)
print(content)
```

运行结果如下：

```
aKyroiRixLg
```

这里往 sub 方法的第一个参数中传人 `\d+` 以匹配所有的数字，往第二个参数中传入把数字替换成的字符串（如果去掉该参数，可以赋值为空），第三个参数是原字符串。

### 1.4 compile

compile 方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。另外，compile 还可以传入修饰符，例如 re.S 等修饰符，这样在 search、findall 等方法中就不用额外传递了。

```python
import re

content1 = '2019-12-15 12:00'
content2 = '2020-06-12 13:15'
content3 = '2021-09-01 14:20'

pattern = re.compile('\d{2}:\d{2}')

result1 = re.sub(pattern, '', content1)
result2 = re.sub(pattern, '', content2)
result3 = re.sub(pattern, '', content3)

print(result1, result2, result3)
```

输出：

```
2019-12-15  2020-06-12  2021-09-01
```

>更多方法可以参见 [Python3 正则表达式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/python3/python3-reg-expressions.html) 或官方文档 [re --- 正则表达式操作](https://docs.python.org/zh-cn/3/library/re.html)

## 2. httpx 的使用

有些网站强制使用 HTTP/2.0 协议访问，而 urilib 和 requests 只支持 HTTP/1.1，这时可以采用 hyper 或 httpx，后者使用更方便，功能更强大。

> 官方文档见 [HTTPX (python-httpx.org)](https://www.python-httpx.org/)

#### 案例

`https://spa16.scrape.center/` 就是一个强制使用 HTTP/2.0 访问的网站，用浏览器打开后查看 Network 可以看到传输全部是通过 h2 方式。

如果我们使用 requests 爬取，会产生错误：

![image-20220111155641392](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220111155641392.png)

#### 安装

见官方文档

#### 基本使用

用 httpx 来爬取刚刚的网站：

```python
import httpx

url = 'https://spa16.scrape.center/'
client = httpx.Client(http2=True)
response = client.get(url)
print(response.text)
```

+ 注意默认不会开启对 HTTP/2.0 的支持，需要手动声明。

注意在客户端的 httpx 上启用对HTTP/2.0的支持并不意味着请求和响应都将通过 HTTP/2.0 传输，**这得客户端和服务端都支持 HTTP/2.0 才行**。如果客户端连接到仅支持 HTTP/1.1 的服务器，那么它也需要改用HTTP/1.1。

>  其他用法见官网。