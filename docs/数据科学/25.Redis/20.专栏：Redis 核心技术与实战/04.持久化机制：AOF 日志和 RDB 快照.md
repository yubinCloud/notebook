---
title: 持久化机制：AOF 日志和 RDB 快照
date: 2023-02-14 15:19:59
permalink: /pages/b212b7/
categories:
  - 数据科学
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

> 参考：
>
> + [04 AOF 日志：宕机了，Redis 如何避免数据丢失？| 极客时间](https://time.geekbang.org/column/article/271754)
> + [05 内存快照：宕机后，Redis 如何实现快速恢复？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)

Redis 用作缓存并将数据存于内存中，就会面对一个问题：一旦服务器宕机，内存中的数据将全部丢失。

也许有个解决方案：从后端数据库恢复这些数据。但这频繁访问数据库会使得性能严重下降。所以对于 Redis 而言，实现数据的持久化，避免从后端中恢复数据，是至关重要的。

目前，Redis 的持久化主要有两大机制：AOF 日志和 RDB 快照。这里讲分别讲解。

## 1. AOF 日志：宕机了，Redis 如何避免数据丢失？

AOF：Append Only File

### 1.1 AOF 日志是如何实现的？

说到日志，我们熟悉的是预写日志（WAL，Write Ahead Log），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，**AOF 日志正好相反，它是写后日志**，“写后”的意思是 **Redis 是先执行命令，把数据写入内存，然后才记录日志**，如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214153236.png" alt="20230214153236" style="zoom:70%;" /></center>

那 AOF 为什么要先执行命令再记日志呢？要回答这个问题，我们要先知道 AOF 里记录了什么内容。

传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 **AOF 里记录的是 Redis 收到的每一条命令**，这些命令是以文本形式保存的。

我们以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。如下图，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214153656.png" alt="20230214153656" style="zoom:73%;" /></center>

但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。

而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，**Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况**。

除此之外，AOF 还有一个好处：**它是在命令执行后才记录日志，所以不会阻塞当前的写操作**。

不过，AOF 也有两个潜在的风险:

+ 首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。
+ 其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。

仔细分析的话，你就会发现，这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味着，**如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了**。

### 1.2 三种写回策略

其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 **appendfsync** 的三个可选值：

+ **Always**，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
+ **Everysec**，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
+ **No**，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。我们来分析下其中的原因：

+ “同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；
+ 虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；
+ “每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。

三种写回策略的对比如下：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214154209.png" alt="20230214154209" style="zoom:75%;" /></center>

选择哪种写回策略，就要在高性能和高可靠性之间做 trade-off 了：

+ 想要获得高性能，就选择 No 策略；
+ 如果想要得到高可靠性保证，就选择 Always 策略；
+ 如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。

随着 Redis 接收的命令越来越多，AOF 文件也会越来越大，这也就意味着，**我们一定要小心 AOF 文件过大带来的性能问题**。这里的“性能问题”，主要在于以下三个方面：

1. 文件系统本身对文件大小有限制，无法保存过大的文件；
2. 如果文件太大，之后再往里面追加命令记录的话，效率也会变低；
3. 如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。

所以，我们就要采取一定的控制手段，这个时候，**AOF 重写机制**就登场了。

### 1.3 AOF 重写机制

当 AOF 日志文件太大了，就需要 AOF 重写机制了。

<mark>AOF 重写机制</mark>：就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，**读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入**。比如说，当读取了键值对“testkey”: “testvalue”之后，重写机制会记录 set testkey testvalue 这条命令。这样，当需要恢复时，可以重新执行该命令，实现“testkey”: “testvalue”的写入。

为什么**重写机制可以把日志文件变小呢**? 实际上，重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。因为这个过程把一些中间的修改记录给去掉了，只保留了最新的数据库状态。如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214155004.png" alt="20230214155004" style="zoom:75%;" /></center>

不过，虽然 AOF 重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。这时，我们就要继续关注另一个问题了：**重写会不会阻塞主线程**？

### 1.4 AOF 重写会阻塞吗？

和 AOF 日志由主线程写回不同，**重写过程是由后台子进程 bgrewriteaof 来完成的**，这也是为了避免阻塞主线程，导致数据库性能下降。

我把重写的过程总结为“**一个拷贝，两处日志**”：

“**一个拷贝**”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

“**两处日志**”又是什么呢？

因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。

而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。

因此，AOF 非阻塞的重写过程如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214155527.png" alt="20230214155527" style="zoom:75%;" /></center>

总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。

### 1.5 小结

这一节介绍了 Redis 用于避免数据丢失的 AOF 日志机制。这个方法通过逐一记录操作命令，在恢复时再逐一执行命令的方式，保证了数据的可靠性。

AOF 机制考虑到对 Redis 性能的影响，提供了 AOF 日志的三种写回策略。

此外，为了避免日志文件过大，Redis 提供了 AOF 重写机制，直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志。这个过程通过后台线程完成，避免了对主线程的阻塞。

不过，上面介绍的落盘时机和重写机制都是用于“记日志”的方法，而在”用日志“时，需要对所有的操作记录进行顺序重放，这个重放过程就很慢了。那，有没有既能避免数据丢失，又能更快地恢复的方法呢？当然有，那就是 RDB 快照了。

## 2. RDB 快照：宕机后，Redis如何实现快速恢复？

### 2.1 什么是 RDB

上一节讲的 Redis 避免数据丢失的 AOF 方法，好处是每次执行只需要记录操作命令，需要持久化的数据量不大，只要你不是采用的 Always 的持久化策略，就不会对性能造成太大影响。

但由于记录的命令而不是实际数据，因此使用 AOF 日志进行故障恢复时需要重放一遍，如果日志过多会耗费很长时间。那有没有既可以保证可靠性，还能在宕机时实现快速恢复的其他方法呢？这就是这节要学习的持久化方法——内存快照。

<mark>内存快照</mark>：指内存中的数据在某一个时刻的状态记录。

这就像平时拍照片一样，内存快照把某一时刻的状态以文件的形式写到磁盘上，这样即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 <mark>RDB 文件</mark>。

> RDB: Redis DataBase

和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。

但拍快照就涉及到两个关键问题：

+ 给哪些数据拍快照？这涉及到快照的执行效率的问题。
+ 拍快照时还能增删改吗？这涉及 Redis 是否被阻塞。

### 2.2 给哪些数据拍快照？

Redis的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是**全量快照**，也就是说，把内存中的所有数据都记录到磁盘中。

但全量快照全部写入磁盘会花费很多时间，而 Redis 的单线程模型又决定了我们要尽量避免所有会阻塞主线程的操作。那 **RDB 文件的生成是否会阻塞主线程**？

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave：

+ **save**：在主线程中执行，会导致阻塞；
+ **bgsave**：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

接下来需要考虑，使用 bgsave 来执行全量快照时，Redis 能否正常处理写操作？

### 2.3 快照时数据能修改吗？

在拍快照时，如果发生数据改动，则很容易产生数据不一致现象。如果不想让数据发生改动，那拍快照期间 Redis 无法接收写请求，这在生产环境下是不被允许的。这时，Redis 就借助了操作系统提供的**写时复制技术**（Copy-On-Write，COW），在执行快照的同时，正常处理写操作。

简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。

+ 此时，如果主线程对这些数据都是读操作（如图中的键值对 A），那么，主线程和bgsave子进程相互不影响。
+ 但如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后，主线程在这个数据副本上进行修改。同时，bgsave子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214194653.png" alt="20230214194653" style="zoom:70%;" /></center>

这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。

到这里，我们就解决了对“哪些数据做快照”以及“做快照时数据能否修改”这两大问题：<font color=blue>Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据</font>。

### 2.4 拍快照的频率

快照间隔时间也是一个关键问题。

拍快照的间隔越小，发生宕机时丢失的数据也就越少，那能不能每秒拍一次快照？

这种想法是错误的。频繁执行全量快照会带来两方面的开销：

+ 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
+ 另一方面，bgsave子进程需要通过fork操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，**fork这个创建过程本身会阻塞主线程**，而且主线程的内存越大，阻塞时间越长。如果频繁fork出bgsave子进程，这就会频繁阻塞主线程了（所以，在Redis中如果有一个bgsave在运行，就不会再启动第二个bgsave子进程）。那么，有什么其他好方法吗？

此时，我们可以做<mark>增量快照</mark>：做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。

在第一次做完全量快照后，T1 和 T2 时刻如果再做快照，我们只需要将被修改的数据写入快照文件就行。但是，这么做的前提是，**我们需要记住哪些数据被修改了**。这个“记住”需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214200409.png" alt="20230214200409" style="zoom:70%;" /></center>

如果我们对每一个键值对的修改，都做个记录，那么，如果有 1 万个被修改的键值对，我们就需要有 1 万条额外的记录。而且，有的时候，键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息，可能就需要 8 字节，这样的画，为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说，有些得不偿失。

到这里，你可以发现，**RDB 快照虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握**，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销，那么，还有什么方法既能利用RDB的快速恢复，又能以较小的开销做到尽量少丢数据呢？

Redis 4.0中提出了一个<mark>混合使用AOF日志和内存快照</mark>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

如下图所示，T1和T2时刻的修改，用AOF日志记录，等到第二次做全量快照时，就可以清空AOF日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214200035.png" alt="20230214200035" style="zoom:70%;" /></center>

**这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势**，颇有点“鱼和熊掌可以兼得”的感觉，建议你在实践中用起来。

### 2.5 小结

这一大节，介绍了 Redis 用于避免数据丢失的 RDB 内存快照的方法，它可以快速恢复数据库。

Redis 设计 bgsave 和写时复制的方式来尽可能减少了内存快照对正常读写的影响。

但频繁快照又是不可接受的，于是出现了混合使用 RDB 和 AOF 的方式，正好可以取两者之长，避两者之短，以较小的性能开销保证数据可靠性和性能。

<font color=red>最后，关于 AOF 和 RDB 的选择问题，我想提三点建议</font>：

+ 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
+ 如果允许分钟级别的数据丢失，可以只使用 RDB；
+ 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。
