---
title: 影响 Redis 性能的 5 个方面
date: 2023-03-20 15:32:29
permalink: /pages/6a57ad/
categories:
  - 数据科学
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

> 参考：
>
> + [16 异步机制：如何避免单线程模型的阻塞？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)

Redis 因其高性能而被广泛应用，我们需要避免性能异常的情况出现。这一大章将讨论影响 Redis 性能的 5 大方面因素：

+ Redis内部的阻塞式操作
+ CPU核和NUMA架构的影响
+ Redis关键系统配置
+ Redis内存碎片
+ Redis缓冲区

## 1. 异步机制：如何避免单线程模型的阻塞？

### 1.1 Redis 实例有哪些阻塞点？

Redis 的网络 IO 和键值对读写是由主线程完成的，这些不同的交互要涉及不同的操作。我们看一下 Redis 有哪些交互操作：

+ 客户端：网络 IP、KV 的 CRUD 等
+ 磁盘：AOF 与 RDB 操作
+ 主从节点：数据复制操作
+ 切片集群：向其他实例传输哈希槽信息、数据迁移

这四类交互对象和操作之间的关系如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230320210811.png" alt="20230320210811" style="zoom:75%;" /></center>

下面我们逐个分析哪些操作会引起阻塞：

#### 1）和客户端交互时的阻塞点

由于 Redis 使用了 IO 多路复用机制避免了主线程的一直等待，所以网络 IO 不是导致 Redis 阻塞的因素。

CRUD 操作是 Redis 与客户端交互的主要部分，也是 Redis 主线程执行的主要任务。所以，复杂度高的增删改查操作肯定会阻塞 Redis。

那怎么判断操作复杂度高不高呢？这里有一个最基本的标准，就是看操作的复杂度是否为 O(N)。

Redis中涉及集合的操作复杂度通常为O(N)，我们要在使用时重视起来。例如集合元素全量查询操作HGETALL、SMEMBERS，以及集合的聚合统计操作，例如求交、并和差集。这些操作可以作为 Redis 的<font color=blue>第一个阻塞点：集合全量查询和聚合操作</font>。

除此之外，集合自身的删除操作同样也有潜在的阻塞风险。因为删除操作的本质是要释放键值对占用的内存空间，而操作系统在释放内存时需要把所释放的内存块插入空闲链表中以便管理，这个过程可能会阻塞程序。所以，**如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞**。

在删除大量键值对数据的时候，最典型的就是删除包含了大量元素的集合，也称为 <mark>bigkey 删除</mark>。下图测试了不同元素数量的集合进行删除操作所耗费的时间：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230320212855.png" alt="20230320212855" style="zoom:75%;" /></center>

从这张表里，我们可以得出三个结论：

1. 当元素数量从10万增加到100万时，4大集合类型的删除时间的增长幅度从5倍上升到了近20倍；
2. 集合元素越大，删除所花费的时间就越长；
3. 当删除有100万个元素的集合时，最大的删除时间绝对值已经达到了1.98s（Hash类型）。Redis的响应时间一般在微秒级别，所以，一个操作达到了近2s，不可避免地会阻塞主线程。

所以，<font color=blue>bigkey 删除操作就是 Redis 的第二个阻塞点</font>。删除操作对Redis实例性能的负面影响很大，而且在实际业务开发时容易被忽略，所以一定要重视它。

::: note 小建议
当遇到 bigkey 删除时，有一个小建议：先使用集合类型提供的 SCAN 命令读取数据，然后再进行删除。因为用 SCAN 命令可以每次只读取一部分数据并进行删除，这样可以避免一次性删除大量 key 给主线程带来的阻塞。

例如，对于 Hash 类型的 bigkey 删除，你可以使用 HSCAN 命令，每次从Hash集合中获取一部分键值对（例如200个），再使用 HDEL 删除这些键值对，这样就可以把删除压力分摊到多次操作中，那么，每次删除操作的耗时就不会太长，也就不会阻塞主线程了。
:::

容易联想到，清空数据库（flushdb 和 flushall 操作）也必然是一个潜在的阻塞风险，因为它们也涉及到大量 KV 的删除。所以，<font color=blue>Redis 的第三个阻塞点：清空数据库</font>。

#### 2）和磁盘交互时的阻塞点

由于磁盘 IO 一般比较慢，因此需要重点关注。Redis 采用子进程的方式来执行 RDB 的生成和 AOF 的重写，从而避免了对主线程的阻塞。

但 Redis 直接记录 AOF 时，会根据不同的写回策略对数据做落盘保存。一次同步写磁盘大约耗时 1~2ms，如果存在大量同步写操作的话，就会阻塞主线程。因此 <font color=blue>Redis 的四个阻塞点：AOF 日志同步写</font>。

#### 3）主从节点交互时的阻塞点

在主从复制时，从库接收 RDB 文件后，需要使用 flushdb 命令来清空当前数据库，**这正好装上了刚刚分析的第三个阻塞点**。

此外，从库在清空数据库后，还需要把 RDB 加载到内存中，这个过程与 RDB 文件的大小密切相关，RDB 越大，加载过程越慢。所以，<font color=blue>加载 RDB 文件就成为了 Redis 的第五个阻塞点</font>。

#### 4）切片集群实例交互时的阻塞点

最后，当我们部署Redis切片集群时，每个Redis实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对 Redis 主线程的阻塞风险不大。

不过，**如果你使用了 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话，就会造成主线程的阻塞**，因为 Redis Cluster 使用了同步迁移。我将在第33讲中向你介绍不同切片集群方案对数据迁移造成的阻塞的解决方法，这里你只需要知道，**当没有 bigkey 时，切片集群的各实例在进行交互时不会阻塞主线程，就可以了**。

<font color=red>现在我们总结了刚刚找到的五个阻塞点</font>：

+ 集合全量查询和聚合操作
+ bigkey 删除
+ 清空数据库
+ AOF 日志同步写
+ 从库加载 RDB 文件

如果在主线程中执行这些操作，必然会导致主线程长时间无法服务其他请求。**为了避免阻塞式操作，Redis 提供了异步线程机制**。所谓的<mark>异步线程机制</mark>：指 Redis 会启动一些子线程，然后把一些任务交给这些子线程，让它们在后台完成，而不再由主线程来执行这些任务。使用异步线程机制执行操作，可以避免阻塞主线程。

不过问题来了，这五个阻塞式操作都可以被异步执行吗？

### 1.2 哪些阻塞点可以异步执行？

先看一下异步执行对操作的要求。

如果一个操作能被异步执行，就意味着，它并不是 Redis 主线程的关键路径上的操作。关键路径上的操作是说，客户端把请求发给 Redis 后就等着返回数据结果。如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230320231654.png" alt="20230320231654" style="zoom:75%;" /></center>

+ 左图的操作 1 就不算关键路径上的操作，因此可以让后台子线程来异步执行；
+ 右图的操作 2 就是关键路径上的操作，所以主线程必须立即把这个操作执行完。

对 Redis 来说，**读操作是典型的关键路径操作**。Redis 的第一个阻塞点“集合全量查询和聚合操作”都涉及到了读操作，所以，它们是不能进行异步操作了。

而删除操作不需要立刻返回具体的结果，不算是关键路径操作，因此我们**可以使用后台子线程来异步执行删除操作**。

对于第四个阻塞点“AOF日志同步写”来说，为保证数据可靠性，Redis 实例需要保证 AOF 日志中的操作记录已经落盘，这个操作虽然需要实例等待，但它并不会返回具体的数据结果给实例。所以，**我们也可以启动一个子线程来执行AOF日志的同步写**，而不用让主线程等待AOF日志的写完成。

最后再看下“从库加载 RDB 文件”这个阻塞点。从库必须把 RDB 加载完，这操作也属于关键路径上的操作，所以我们必须让从库的主线程来执行。

对于 Redis 的五大阻塞点来说，除了“集合全量查询和聚合操作”和“从库加载 RDB 文件”，其他三个阻塞点涉及的操作都不在关键路径上，所以可以使用 Redis 的异步子线程机制来实现 bigkey 删除，清空数据库，以及 AOF 日志同步写。

::: note 小建议
集合全量查询和聚合操作、从库加载RDB文件是在关键路径上，无法使用异步操作来完成。对于这两个阻塞点也有两个小建议：

+ 集合全量查询和聚合操作：可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算；
+ 从库加载 RDB 文件：把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。
:::

那 Redis 实现的异步子线程机制具体是怎么执行呢？

### 1.3 异步的子线程机制

Redis 主线程启动后，会使用操作系统提供的 `pthread_create` 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。

**主线程通过一个链表形式的任务队列和子线程进行交互**。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此，我们把这种异步删除也称为<mark>惰性删除</mark>（**lazy free**）。此时，删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响。

和惰性删除类似，**当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中**。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。

下面这张图展示了 Redis 中的异步子线程执行机制：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230320233059.png" alt="20230320233059" style="zoom:75%;" /></center>

**异步的键值对删除和数据库清空操作**是 Redis 4.0 后提供的功能，Redis也提供了新的命令来执行这两个操作：

+ 键值对删除：当你的集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，我建议你使用 <mark>UNLINK 命令</mark>。
+ 清空数据库：可以在 FLUSHDB 和 FLUSHALL 命令后加上 **ASYNC 选项**，这样就可以让后台子线程异步地清空数据库，如下所示：

```plain
FLUSHDB ASYNC
FLUSHALL AYSNC
```

### 1.4 小结

这一节主要讲了 Redis 运行时的交互对象和交互操作，并对其中不属于关键路径的操作讲解使用异步子线程机制来完成。
