---
title: Redis 中的数据结构
date: 2023-02-28 10:02:03
permalink: /pages/a17e12/
categories:
  - 数据科学
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

> 参考：
>
> + [11 “万金油”的 String，为什么不好用了？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)
> + [12 有一亿个 keys 要统计，应该用哪种集合？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)

这一章将学习“数据结构”，介绍内存开销以及保存和统计海量数据的数据类型及其底层数据结构，还会围绕典型的应用场景（例如地址位置查询、时间序列数据库读写和消息队列存取），跟你分享使用 Redis 的数据类型和 module 扩展功能来满足需求的具体方案。

## 1. “万金油”的 String，为什么不好用了？

这一节了解一下 String 类型的内存空间消耗问题，以及选择节省内存开销的数据类型的解决方案。

先分享一个实际的需求。当时要开发一个图片存储系统，要求能快速根据图片 ID 找到对应的图片存储对象 ID，即 photo\_id -> photo\_obj\_id。由于图片数量巨大，我们就使用 10 位数来保存这个 ID，例如：

```plain
photo_id: 1101000051
photo_obj_id: 3301000051
```

可以看到 photo\_id 与 photo\_obj\_id 一一对应，是典型的“<mark>键-单值</mark>”模式。所谓的“**单值**”，就是指键值对中的值就是一个值，而不是一个集合，这和 String 类型提供的“一个键对应一个值的数据”的保存形式刚好契合。

而且，**String 类型可以保存二进制字节流，就像“万金油”一样，只要把数据转成二进制字节数组，就可以保存了**。

所以，我们的第一个方案就是用 String 保存数据。我们把图片 ID 和图片存储对象 ID 分别作为键值对的 key 和 value 来保存，其中，图片存储对象 ID 用了 String 类型。

刚开始，我们保存了1亿张图片，大约用了6.4GB的内存。但随着图片数据量的不断增加，Redis 内存使用量也在增加，导致因生成RDB而响应变慢的问题。很显然，String类型并不是一种好的选择，我们还需要进一步寻找能节省内存开销的数据类型方案。

在这个过程中，我们研究发现：**String类型并不是适用于所有场合的，它有一个明显的短板，就是它保存数据时所消耗的内存空间较多**。

同时，我们还仔细研究了集合类型的数据结构，发现，**集合类型有非常节省内存空间的底层实现结构，但是，集合类型保存的数据模式，是一个键对应一系列值，并不适合直接保存单值的键值对**。所以，我们就使用二级编码的方法，实现了用集合类型保存单值键值对，Redis 实例的内存空间消耗明显下降了。

这节课，我就把在解决这个问题时学到的经验和方法分享给你，**包括 String 类型的内存空间消耗在哪儿了、用什么数据结构可以节省内存，以及如何用集合类型保存单值键值对**。如果你在使用String类型时也遇到了内存空间消耗较多的问题，就可以尝试下今天的解决方案了。

接下来，我们先来看看 String 类型的内存都消耗在哪里了。

### 1.1 为什么 String 类型内存开销大？

在刚才的案例中，我们保存了1亿张图片的信息，用了约6.4GB的内存，一个图片ID和图片存储对象ID的记录平均用了64字节。但问题是，一组图片ID及其存储对象ID的记录，实际只需要16字节就可以了。

我们来分析一下。如果我们可以用两个8字节的 Long 类型表示这两个 ID，因为 8 字节的Long类型最大可以表示 $2^{64}$，所以肯定可以表示10位数。但是，为什么String类型却用了64字节呢？

<font color=blue>其实，除了记录实际数据，String类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据。当实际保存的数据较小时，元数据的空间开销就显得比较大了，有点“喧宾夺主”的意思</font>。

那么，String类型具体是怎么保存数据的呢？

当你保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 long 类型整数，这种方式通常也称为 <mark>int 编码方式</mark>。

但当你保存的数据中包含字符时，String 类型就会用<mark>简单动态字符串</mark>（Simple Dynamic String，<mark>SDS</mark>）的 struct 来保存：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228103326.png" alt="20230228103326" style="zoom:75%;" /></center>

+ buf：char[] 类型，保存实际数据，同时会在尾部加一个 `\0`。
+ len：4 byte，表示 buf 的长度。
+ alloc：4 byte，表示 buf 的分配长度。

可以看到，len 和 alloc 就是 SDS 结构体的额外开销。另外，对于 String 类型来说，除了 SDS，还有一个来自于 RedisObject 结构体的开销。

Redis 使用 <mark>RedisObject</mark> 结构体来统一记录不同的数据结构的元数据和实际数据位置。其结构示意图如下：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228103830.png" alt="20230228103830" style="zoom:75%;" /></center>

为了节省内存，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计：

+ 当保存的是 Long 类型时，RedisObject 中的 ptr 就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的开销。这也是前面说的 <mark>int 编码方式</mark>。
+ 当保存的是字符串时，且字符串小于等于 44 byte 时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 <mark>embstr编码方式</mark>。
+ 当字符串大于 44 byte 时，SDS 数据量就开始变多，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 <mark>raw 编码模式</mark>。

三种编码方式如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228104806.png" alt="20230228104806" style="zoom:75%;" /></center>

现在知道了 RedisObject 的额外开销，我们就可以计算 String 类型的内存使用量了。

因为10位数的图片ID和图片存储对象ID是Long类型整数，所以可以直接用int编码的RedisObject保存。每个int编码的RedisObject元数据部分占8字节，指针部分被直接赋值为8字节的整数了。此时，每个ID会使用16字节，加起来一共是32字节。但是，另外的32字节去哪儿了呢？其实，Redis 是使用一个全局 hash table 来保存所有的键值对的，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个 kv pair。其中 dictEntry 有三个 8 byte 的指针，分别指向 key、value 以及下一个 dictEntry。一个 dictEntry 如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228105208.png" alt="20230228105208" style="zoom:75%;" /></center>

但 dictEntry 只占了 24 byte，那为啥会占用 32 byte 呢？这就要提到 Redis 使用的内存分配库 jemalloc 了。

<mark>jemalloc</mark> 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。举个例子。如果你申请6字节空间，jemalloc实际会分配8字节空间；如果你申请24字节空间，jemalloc则会分配32字节。所以，在我们刚刚说的场景里，dictEntry结构就占用了32字节。

好了，到这里你就能理解，为什么用String类型保存图片ID和图片存储对象ID时需要用64个字节了。你看，明明有效信息只有 16 byte，使用 String 类型保存却需要 64 byte 的内存空间，有 48 byte 都是额外开销。那有没有更节省内存的方法呢？

### 1.2 用什么数据结构可以节省内存？

Redis 有一种底层数据结构，叫**压缩列表**（ziplist），这是一种非常节省内存的结构。

我们先回顾下压缩列表的构成：表头有三个字段zlbytes、zltail和zllen，分别表示列表长度、列表尾的偏移量，以及列表中的entry个数。压缩列表尾还有一个zlend，表示列表结束。如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228110005.png" alt="20230228110005" style="zoom:85%;" /></center>

压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分：

+ prev\_len：表示前一个entry的长度。prev\_len有两种取值情况：1字节或5字节。取值1字节时，表示上一个entry的长度小于254字节。虽然1字节的值能表示的数值范围是0到255，但是压缩列表中zlend的取值默认是255，因此，就默认用255表示整个压缩列表的结束，其他表示长度的地方就不能再用255这个值了。所以，当上一个entry长度小于254字节时，prev\_len取值为1字节，否则，就取值为5字节。
+ len：表示自身长度，4 byte
+ encoding：表示编码方式，1 byte
+ content：保存实际数据

这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。

我们以保存图片存储对象ID为例，来分析一下压缩列表是如何节省内存空间的。每个entry保存一个图片存储对象ID（8字节），此时，每个entry的prev\_len只需要1个字节就行，因为每个entry的前一个entry长度都只有8字节，小于254字节。这样一来，一个图片的存储对象ID所占用的内存大小是14字节（1+4+1+8=14），实际分配16字节。

**Redis基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型**，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。

这个方案听起来很好，但还存在一个问题：在用集合类型保存键值对时，一个键对应了一个集合的数据，但是在我们的场景中，一个图片ID只对应一个图片的存储对象ID，我们该怎么用集合类型呢？换句话说，**在一个键对应一个值（也就是单值键值对）的情况下，我们该怎么用集合类型来保存这种单值键值对呢**？

### 1.3 如何用集合类型保存单值的键值对？

在保存单值的键值对时，可以采用基于 <mark>Hash 类型的二级编码方法</mark>。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为Hash集合的key，后一部分作为Hash集合的value，这样一来，我们就可以把单值数据保存到Hash集合中了。

以图片ID 1101000060和图片存储对象ID 3302000080为例，我们可以把图片ID的前7位（1101000）作为Hash类型的键，把图片ID的最后3位（060）和图片存储对象ID分别作为Hash类型值中的key和value。

按照这种设计方法，我在Redis中插入了一组图片ID及其存储对象ID的记录，并且用info命令查看了内存开销，我发现，增加一条记录后，内存占用只增加了16字节，如下所示：

```plain
127.0.0.1:6379> info memory
# Memory
used_memory:1039120
127.0.0.1:6379> hset 1101000 060 3302000080
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:1039136
```

在使用 String 类型时，每个记录需要消耗 64 字节，这种方式却只用了 16 字节，所使用的内存空间是原来的 1/4，满足了我们节省内存空间的需求。

不过，你可能也会有疑惑：“二级编码一定要把图片ID的前7位作为Hash类型的键，把最后3位作为Hash类型值中的key吗？” **其实，二级编码方法中采用的ID长度是有讲究的**。

我们之前讲过，Redis 的 Hash 类型有两种底层实现结构，分别是压缩列表和哈希表。Hash 类型设置了一个用压缩列表保存数据时的阈值，一旦超过阈值，Hash 类型就会用哈希表来保存数据了。这两个阈值分别对应以下两个配置项：

+ hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。
+ hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。

如果我们往Hash集合中写入的元素个数超过了 hash-max-ziplist-entries，或者写入的单个元素大小超过了 hash-max-ziplist-value，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。

一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。

**为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在Hash集合中的元素个数**。所以，在刚才的二级编码中，我们只用图片ID最后3位作为Hash集合的key，也就保证了Hash集合的元素个数不超过1000，同时，我们把 hash-max-ziplist-entries 设置为 1000，**这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了**。

### 1.4 小结

这一节我们打破了对 String 的认知误区，了解到 **String 并非万金油，当保存的 kv pair 本身占用内存空间不大时，String 类型的元数据开销就占据主导了**，这包括了 RedisObject、SDS、dictEntry 结构的内存开销。

针对这种情况，我们可以借助压缩列表这种底层结构，使用 Hash 类型的二级编码方法来保存单值 kv pair 的数据。也就是需要将原 kv pair 的 key 拆成两部分，前一部分作为 Hash 集合的 key，后一部分与原 kv pair 的 value 组合成一个新 kv 来作为 Hash 集合的 value。

**小妙招**：如果你想知道 kv pair 采用不同类型保存时的内存开销，可以在[Redis 容量预估](http://www.redis.cn/redis_memory/)这个网站上进行估计。

## 2. 有一亿个keys要统计，应该用哪种集合？

很多场景需要保存这样一种数据：一个 key 对应了一个数据集合。比如用户 ID -> 登录设备，员工 -> 一天打卡记录。

Redis 的集合类型很适合存储这些数据，但在这些场景中，除了记录信息，我们往往还需要对集合中的数据进行统计，比如统计每天新增用户数、一个月连续打卡的员工数等。通常我们会面临巨大的访问量，比如百万、千万级别。所以，我们必须要能够选择非常高效地统计大量数据（例如亿级）的集合类型。

**要想选择合适的集合，我们就得了解常用的集合统计模式**。这一节将介绍集合类型的常见四种统计模式：聚合统计、排序统计、二值状态统计和基数统计，并介绍这些统计场景下什么数据结构更加合适。

### 2.1 聚合统计

<mark>聚合统计</mark>：**指统计多个集合元素的聚合结果**，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。

比如统计手机 App 每天的新增用户数和第二天的留存用户数就是聚合统计。要完成这个统计任务，我们可以用一个集合记录所有登录过App的用户ID，同时，用另一个集合记录每一天登录过App的用户ID。然后，再对这两个集合做聚合统计。我们来看下具体的操作。

可以使用 Set 类型来记录所有登录过 App 的用户 ID，把 key 设置成 `user:id`，value 就是保存了所有登陆过 App 的用户 ID 的 Set，如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228213007.png" alt="20230228213007" style="zoom:75%;" /></center>

还需要记录每一天登录的用户 ID，可以让 key 设为 `user:id:<datetime>`，比如 `user:id:20200803`，value 是记录了当天登录的所有用户 ID 的 Set。如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228213152.png" alt="20230228213152" style="zoom:75%;" /></center>

在统计每天的新增用户时，我们只用计算每日用户 Set 和累计用户 Set 的差集就行。

**当你需要对多个集合进行聚合计算时，Set 类型会是一个非常不错的选择**。不过，这里有一个潜在的风险：**Set 的差集、并集和交集的计算复杂度较高**，在数据量较大的情况下，如果直接执行这些计算，会导致Redis实例阻塞。所以这里给一个小建议：<font color=blue>你可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计</font>，这样就可以规避阻塞主库实例和其他从库实例的风险了。

### 2.2 排序统计

这一小节讲应对集合元素排序的需求的方法，这里以电商网站提供最新评论列表的场景为例进行讲解。

最新评论列表包含了所有评论中的最新留言，**这就要求集合类型能对元素保序**，这种对元素保序的集合类型叫作**有序集合**。在 Redis 的四个集合类型中（List、Hash、Set 和 Sorted Set），**List 和 Sorted Set 就属于有序集合**。

+ List 按照元素添加的顺序进行排序；
+ Sorted Set 按照元素的权重来排序，其中权重值可以自己决定（比如让插入时间作为权重）。

貌似都符合需求，接下来看一下如何选择。

---

**如果使用 List 的话**。每个商品对应一个 List，这个 List 包含了该商品的全部评论，并按照评论时间保存，每来一个新评论就用 LPUSH 命令把它插入到 List 的队头。

在只有一页评论的时候，我们可以很清晰地看到最新的评论，但是，在实际应用中，网站一般会分页显示最新的评论列表，**一旦涉及到分页操作，List就可能会出现问题了**。

假设当前的评论List是{A, B, C, D, E, F}（其中，A是最新的评论，以此类推，F是最早的评论），在展示第一页的3个评论时，我们可以用下面的命令，得到最新的三条评论A、B、C：

```plain
LRANGE product1 0 2
1) "A"
2) "B"
3) "C"
```

然后，再用下面的命令获取第二页的3个评论，也就是D、E、F：

```plain
LRANGE product1 3 5
1) "D"
2) "E"
3) "F"
```

但是，如果在展示第二页前，又产生了一个新评论G，评论G就会被LPUSH命令插入到评论List的队头，评论List就变成了{G, A, B, C, D, E, F}。此时，再用刚才的命令获取第二页评论时，就会发现，评论C又被展示出来了，也就是C、D、E：

```plain
LRANGE product1 3 5
1) "C"
2) "D"
3) "E"
```

之所以会这样，关键原因就在于，List是通过元素在List中的位置来排序的，当有一个新元素插入时，原先的元素在List中的位置都后移了一位，比如说原来在第1位的元素现在排在了第2位。所以，**对比新元素插入前后，List 相同位置上的元素就会发生变化，用 LRANGE 读取时，就会读到旧元素**。

---

和 List 相比，Sorted Set 就不存在这个问题，因为它是根据元素的实际权重来排序和获取数据的。

我们可以按评论时间的先后给每条评论设置一个权重值，然后再把评论保存到 Sorted Set 中。Sorted Set 的 ZRANGEBYSCORE 命令就可以按权重排序后返回元素。这样的话，即使集合中的元素频繁更新，Sorted Set 也能通过 ZRANGEBYSCORE 命令准确地获取到按序排列的数据。

假设越新的评论权重越大，目前最新评论的权重是N，我们执行下面的命令时，就可以获得最新的10条评论：

```plain
ZRANGEBYSCORE comments N-9 N
```

所以，<font color=blue>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，建议你优先考虑使用 Sorted Set</font>。

### 2.3 二值状态统计
