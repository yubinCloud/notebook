---
title: Redis 中的数据结构
date: 2023-02-28 10:02:03
permalink: /pages/a17e12/
categories:
  - 数据科学
  - Redis
  - 专栏：Redis 核心技术与实战
tags:
  - 
---

> 参考：
>
> + [11 “万金油”的 String，为什么不好用了？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)
> + [12 有一亿个 keys 要统计，应该用哪种集合？| 极客时间](https://time.geekbang.org/column/intro/100056701?tab=catalog)

这一章将学习“数据结构”，介绍内存开销以及保存和统计海量数据的数据类型及其底层数据结构，还会围绕典型的应用场景（例如地址位置查询、时间序列数据库读写和消息队列存取），跟你分享使用 Redis 的数据类型和 module 扩展功能来满足需求的具体方案。

## 1. “万金油”的 String，为什么不好用了？

这一节了解一下 String 类型的内存空间消耗问题，以及选择节省内存开销的数据类型的解决方案。

先分享一个实际的需求。当时要开发一个图片存储系统，要求能快速根据图片 ID 找到对应的图片存储对象 ID，即 photo\_id -> photo\_obj\_id。由于图片数量巨大，我们就使用 10 位数来保存这个 ID，例如：

```plain
photo_id: 1101000051
photo_obj_id: 3301000051
```

可以看到 photo\_id 与 photo\_obj\_id 一一对应，是典型的“<mark>键-单值</mark>”模式。所谓的“**单值**”，就是指键值对中的值就是一个值，而不是一个集合，这和 String 类型提供的“一个键对应一个值的数据”的保存形式刚好契合。

而且，**String 类型可以保存二进制字节流，就像“万金油”一样，只要把数据转成二进制字节数组，就可以保存了**。

所以，我们的第一个方案就是用 String 保存数据。我们把图片 ID 和图片存储对象 ID 分别作为键值对的 key 和 value 来保存，其中，图片存储对象 ID 用了 String 类型。

刚开始，我们保存了1亿张图片，大约用了6.4GB的内存。但随着图片数据量的不断增加，Redis 内存使用量也在增加，导致因生成RDB而响应变慢的问题。很显然，String类型并不是一种好的选择，我们还需要进一步寻找能节省内存开销的数据类型方案。

在这个过程中，我们研究发现：**String类型并不是适用于所有场合的，它有一个明显的短板，就是它保存数据时所消耗的内存空间较多**。

同时，我们还仔细研究了集合类型的数据结构，发现，**集合类型有非常节省内存空间的底层实现结构，但是，集合类型保存的数据模式，是一个键对应一系列值，并不适合直接保存单值的键值对**。所以，我们就使用二级编码的方法，实现了用集合类型保存单值键值对，Redis 实例的内存空间消耗明显下降了。

这节课，我就把在解决这个问题时学到的经验和方法分享给你，**包括 String 类型的内存空间消耗在哪儿了、用什么数据结构可以节省内存，以及如何用集合类型保存单值键值对**。如果你在使用String类型时也遇到了内存空间消耗较多的问题，就可以尝试下今天的解决方案了。

接下来，我们先来看看 String 类型的内存都消耗在哪里了。

### 1.1 为什么 String 类型内存开销大？

在刚才的案例中，我们保存了1亿张图片的信息，用了约6.4GB的内存，一个图片ID和图片存储对象ID的记录平均用了64字节。但问题是，一组图片ID及其存储对象ID的记录，实际只需要16字节就可以了。

我们来分析一下。如果我们可以用两个8字节的 Long 类型表示这两个 ID，因为 8 字节的Long类型最大可以表示 $2^{64}$，所以肯定可以表示10位数。但是，为什么String类型却用了64字节呢？

<font color=blue>其实，除了记录实际数据，String类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作元数据。当实际保存的数据较小时，元数据的空间开销就显得比较大了，有点“喧宾夺主”的意思</font>。

那么，String类型具体是怎么保存数据的呢？

当你保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 long 类型整数，这种方式通常也称为 <mark>int 编码方式</mark>。

但当你保存的数据中包含字符时，String 类型就会用<mark>简单动态字符串</mark>（Simple Dynamic String，<mark>SDS</mark>）的 struct 来保存：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228103326.png" alt="20230228103326" style="zoom:75%;" /></center>

+ buf：char[] 类型，保存实际数据，同时会在尾部加一个 `\0`。
+ len：4 byte，表示 buf 的长度。
+ alloc：4 byte，表示 buf 的分配长度。

可以看到，len 和 alloc 就是 SDS 结构体的额外开销。另外，对于 String 类型来说，除了 SDS，还有一个来自于 RedisObject 结构体的开销。

Redis 使用 <mark>RedisObject</mark> 结构体来统一记录不同的数据结构的元数据和实际数据位置。其结构示意图如下：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228103830.png" alt="20230228103830" style="zoom:75%;" /></center>

为了节省内存，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计：

+ 当保存的是 Long 类型时，RedisObject 中的 ptr 就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的开销。这也是前面说的 <mark>int 编码方式</mark>。
+ 当保存的是字符串时，且字符串小于等于 44 byte 时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 <mark>embstr编码方式</mark>。
+ 当字符串大于 44 byte 时，SDS 数据量就开始变多，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 <mark>raw 编码模式</mark>。

三种编码方式如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228104806.png" alt="20230228104806" style="zoom:75%;" /></center>

现在知道了 RedisObject 的额外开销，我们就可以计算 String 类型的内存使用量了。

因为10位数的图片ID和图片存储对象ID是Long类型整数，所以可以直接用int编码的RedisObject保存。每个int编码的RedisObject元数据部分占8字节，指针部分被直接赋值为8字节的整数了。此时，每个ID会使用16字节，加起来一共是32字节。但是，另外的32字节去哪儿了呢？其实，Redis 是使用一个全局 hash table 来保存所有的键值对的，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个 kv pair。其中 dictEntry 有三个 8 byte 的指针，分别指向 key、value 以及下一个 dictEntry。一个 dictEntry 如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228105208.png" alt="20230228105208" style="zoom:75%;" /></center>

但 dictEntry 只占了 24 byte，那为啥会占用 32 byte 呢？这就要提到 Redis 使用的内存分配库 jemalloc 了。

<mark>jemalloc</mark> 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。举个例子。如果你申请6字节空间，jemalloc实际会分配8字节空间；如果你申请24字节空间，jemalloc则会分配32字节。所以，在我们刚刚说的场景里，dictEntry结构就占用了32字节。

好了，到这里你就能理解，为什么用String类型保存图片ID和图片存储对象ID时需要用64个字节了。你看，明明有效信息只有 16 byte，使用 String 类型保存却需要 64 byte 的内存空间，有 48 byte 都是额外开销。那有没有更节省内存的方法呢？

### 1.2 用什么数据结构可以节省内存？

Redis 有一种底层数据结构，叫**压缩列表**（ziplist），这是一种非常节省内存的结构。

我们先回顾下压缩列表的构成：表头有三个字段zlbytes、zltail和zllen，分别表示列表长度、列表尾的偏移量，以及列表中的entry个数。压缩列表尾还有一个zlend，表示列表结束。如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230228110005.png" alt="20230228110005" style="zoom:85%;" /></center>

压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分：

+ prev\_len：表示前一个entry的长度。prev\_len有两种取值情况：1字节或5字节。取值1字节时，表示上一个entry的长度小于254字节。虽然1字节的值能表示的数值范围是0到255，但是压缩列表中zlend的取值默认是255，因此，就默认用255表示整个压缩列表的结束，其他表示长度的地方就不能再用255这个值了。所以，当上一个entry长度小于254字节时，prev\_len取值为1字节，否则，就取值为5字节。
+ len：表示自身长度，4 byte
+ encoding：表示编码方式，1 byte
+ content：保存实际数据

这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。

我们以保存图片存储对象ID为例，来分析一下压缩列表是如何节省内存空间的。每个entry保存一个图片存储对象ID（8字节），此时，每个entry的prev\_len只需要1个字节就行，因为每个entry的前一个entry长度都只有8字节，小于254字节。这样一来，一个图片的存储对象ID所占用的内存大小是14字节（1+4+1+8=14），实际分配16字节。

**Redis基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型**，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。

这个方案听起来很好，但还存在一个问题：在用集合类型保存键值对时，一个键对应了一个集合的数据，但是在我们的场景中，一个图片ID只对应一个图片的存储对象ID，我们该怎么用集合类型呢？换句话说，**在一个键对应一个值（也就是单值键值对）的情况下，我们该怎么用集合类型来保存这种单值键值对呢**？

### 1.3 如何用集合类型保存单值的键值对？

在保存单值的键值对时，可以采用基于 <mark>Hash 类型的二级编码方法</mark>。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为Hash集合的key，后一部分作为Hash集合的value，这样一来，我们就可以把单值数据保存到Hash集合中了。

以图片ID 1101000060和图片存储对象ID 3302000080为例，我们可以把图片ID的前7位（1101000）作为Hash类型的键，把图片ID的最后3位（060）和图片存储对象ID分别作为Hash类型值中的key和value。

按照这种设计方法，我在Redis中插入了一组图片ID及其存储对象ID的记录，并且用info命令查看了内存开销，我发现，增加一条记录后，内存占用只增加了16字节，如下所示：

```plain
127.0.0.1:6379> info memory
# Memory
used_memory:1039120
127.0.0.1:6379> hset 1101000 060 3302000080
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:1039136
```

在使用 String 类型时，每个记录需要消耗 64 字节，这种方式却只用了 16 字节，所使用的内存空间是原来的 1/4，满足了我们节省内存空间的需求。

不过，你可能也会有疑惑：“二级编码一定要把图片ID的前7位作为Hash类型的键，把最后3位作为Hash类型值中的key吗？” **其实，二级编码方法中采用的ID长度是有讲究的**。

我们之前讲过，Redis 的 Hash 类型有两种底层实现结构，分别是压缩列表和哈希表。Hash 类型设置了一个用压缩列表保存数据时的阈值，一旦超过阈值，Hash 类型就会用哈希表来保存数据了。这两个阈值分别对应以下两个配置项：

+ hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。
+ hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。

如果我们往Hash集合中写入的元素个数超过了 hash-max-ziplist-entries，或者写入的单个元素大小超过了 hash-max-ziplist-value，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。

一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。

**为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在Hash集合中的元素个数**。所以，在刚才的二级编码中，我们只用图片ID最后3位作为Hash集合的key，也就保证了Hash集合的元素个数不超过1000，同时，我们把 hash-max-ziplist-entries 设置为 1000，**这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了**。

### 1.4 小结

这一节我们打破了对 String 的认知误区，了解到 **String 并非万金油，当保存的 kv pair 本身占用内存空间不大时，String 类型的元数据开销就占据主导了**，这包括了 RedisObject、SDS、dictEntry 结构的内存开销。

针对这种情况，我们可以借助压缩列表这种底层结构，使用 Hash 类型的二级编码方法来保存单值 kv pair 的数据。也就是需要将原 kv pair 的 key 拆成两部分，前一部分作为 Hash 集合的 key，后一部分与原 kv pair 的 value 组合成一个新 kv 来作为 Hash 集合的 value。

**小妙招**：如果你想知道 kv pair 采用不同类型保存时的内存开销，可以在[Redis 容量预估](http://www.redis.cn/redis_memory/)这个网站上进行估计。

## 2. 有一亿个keys要统计，应该用哪种集合？
