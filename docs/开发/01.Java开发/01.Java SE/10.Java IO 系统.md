---
title: Java I/O 系统
date: 2022-01-25 01:07:44
permalink: /pages/33057b/
categories:
  - 开发
  - Java开发
  - Java SE
tags:
  - 
---

> 整体思路：先学会使用File类定位文件以及操作文件本身，然后学习 IO 流读写文件数据。
>
> + **File 类**可以定位文件：进行删除、获取文本本身信息等操作，**但是不能读写文件内容**；
> + **IO 流**技术可以对硬盘中的文件进行读写。

[[toc]]

## 1. File 类

File：它是文件和目录路径名的**抽象表示**：

+ **文件和目录都**可以通过 File 封装成对象；
+ 对于 File 而言，**其封装的并不是一个真正存在的文件**，仅仅是一个路径名而已。他可以是存在的，也可以是不存在的。

### 1.1 创建 File 类对象

|                   方法名称                   | 说明                                               |
| :------------------------------------------: | -------------------------------------------------- |
|       **public** File(String pathname)       | 根据文件路径创建文件对象                           |
| **public** File(String parent, String child) | 从父路径名字符串和子路径名字符串创建文件对象       |
|  **public** File(File parent, String child)  | 根据父路径对应文件对象和子路径名字符串创建文件对象 |

+ File 对象可以定位文件和目录。

▲ **`File.separator`** 表示系统的路径分隔符（Windows 与 Linux 不同）。

### 1.2 绝对路径和相对路径

**绝对路径**：从盘符开始

```java
File file1 = new File("D:\\itheima\\a.txt"); 
```

**相对路径**：一般定位模块中的文件的，<u>默认直接**到当前工程下**的目录寻找文件</u>

```java
File file3 = new File("模块名\\a.txt"); 
```

### 1.3 判断文件类型、获取文件信息

|         方法名称         | 说明                                       |
| :----------------------: | :----------------------------------------- |
|  boolean isDirectory()   | 测试此抽象路径名表示的File是否为文件夹     |
|     boolean isFile()     | 测试此抽象路径名表示的File是否为文件       |
|     boolean exists()     | 测试此抽象路径名表示的File是否存在         |
| String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串         |
|     String getPath()     | 将此抽象路径名转换为路径名字符串           |
|     String getName()     | 返回由此抽象路径名表示的文件或文件夹的名称 |
|         length()         | 获取文件的大小：**字节**个数               |
|   long lastModified()    | 返回文件最后修改的时间毫秒值               |

### 1.4 创建、删除文件

#### 创建文件：

|            方法名称            | 说明                       |
| :----------------------------: | -------------------------- |
| public boolean createNewFile() | 创建一个新的空的文件       |
|     public boolean mkdir()     | **只**能创建**一级**文件夹 |
|    public boolean mkdirs()     | 可以创建多级文件夹         |

+ 当文件已存在时，`createNewFile()` 会创建失败并返回 false。
+ 当想创建 `/resource/img/` 目录时，若 `/resource` 不存在，则 `mkdir` 会返回 false。

#### 删除文件：

|         方法名称         | 说明                                       |
| :----------------------: | ------------------------------------------ |
| public  boolean delete() | 删除由此抽象路径名表示的文件或**空文件夹** |

+ `delete` 在占用该文件时依然可以删除。
+ `delete` 只能删除空文件夹，**不能删除非空文件夹**

### 1.5 遍历文件夹

|        方法名称        | 说明                                                         |
| :--------------------: | ------------------------------------------------------------ |
|    String[] list()     | 获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回。 |
| **File[] listFiles()** | 获取当前目录下所有的"一级**文件对象**"到一个文件对象数组中去返回（**重点**） |

`listFiles` 方法的注意事项：

+ 当调用者不存在时，返回null
+ 当调用者**是一个文件时，返回null**
+ 当调用者是一个空文件夹时，返回一个长度为0的数组
+ 当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回
+ 当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，**包含隐藏内容**
+ 当调用者是一个需要权限才能进入的文件夹时，返回null

## 2. 字符集

计算机可以给人类字符进行编号存储，这套编号规则就是**字符集**。

### 2.1 常见字符集

#### 1）ASCII 字符集

ASCII 使用1个字节存储一个字符，总共可以表示128个字符信息。

#### 2）GBK

<u>Windows 系统默认的码表</u>，兼容 ASCII 码表，也包含了几万个汉字，并支持繁体汉字以及部分日韩文字。注意，GBK 是中国的码表，<u>一个中文以**两个字节**的形式存储</u>。但不包含世界上所有国家的文字。

#### 3）Unicode

计算机科学领域里的一项业界字符编码标准，容纳世界上大多数国家的所有常见文字和符号。由于Unicode会先通过 UTF-8，UTF-16，以及 UTF-32 的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。

+ UTF-8 编码后一个中文一般以 **3 个字节**的形式存储。
+ UTF-8 也要兼容 ASCII 编码表。

### 2.2 字符集的编码、解码操作

#### String 编码

|              方法名称               | 说明                                                         |
| :---------------------------------: | ------------------------------------------------------------ |
|          byte[] getBytes()          | 使用平台的默认字符集将该 String 编码为一系列字节，将结果存储到新的字节数组中 |
| byte[] getBytes(String charsetName) | 使用指定的字符集将该 String 编码为一系列字节，将结果存储到新的字节数组中 |

#### String 解码

|                  构造器                  | 说明                                                         |
| :--------------------------------------: | ------------------------------------------------------------ |
|           String(byte[] bytes)           | 通过使用**平台的默认字符集**解码指定的字节数组来构造新的  String |
| String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来构造新的 String          |

## 3. I/O 流

### 3.1 I/O 流概述

IO 流也称为输入、输出流，就是**用来读写数据**的。

+ I 表示 intput，是数据从硬盘文件**读入内存**的过程，称之输入，负责读。
+ O 表示 output，是内存程序的数据**从内存写出**到硬盘文件的过程，称之输出，负责写。

> 所谓的“输入/输出”是**以内存为基准**的。

按照流中数据的最小单位，又可以分成字节流（操作所有类型文件）和字符流（操作纯文本文件）。

![image-20220125135058804](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220125135058804.png)

这些流都是**抽象类**，不能直接使用。

### 3.2 字节流的使用

InputStream、OutputStream 的一个实现是 FileInputStream 和 FileOutputStream，用于操作文件。

#### 3.2.1 文件字节输入流：FileInputStream

|                  构造器                  | 说明                               |
| :--------------------------------------: | ---------------------------------- |
|    public  FileInputStream(File file)    | 创建字节输入流管道与源文件对象接通 |
| public  FileInputStream(String pathname) | 创建字节输入流管道与源文件路径接通 |

|            方法名称             | 说明                                                    |
| :-----------------------------: | ------------------------------------------------------- |
|       public int  read()        | 每次读取一个字节返回，如果字节已经没有可读的返回 -1     |
| public int  read(byte[] buffer) | 每次读取一个字节数组返回，如果字节已经没有可读的返回 -1 |

示例：【每次读取一个字节】

```java
int c;
while ((c = fs.read()) != -1) {
    System.out.print((char) b);
}
```

+ 这种方式其实并不好，效率较低，且对于多字节编码的汉字会出现乱码问题。

示例：【每次读取一个字节数组】

```java
byte[] buf = new byte[3];
int len; // 记录读取的字节数
while ((len = fs.read(buf)) != -1) {
    System.out.print(new String(buf, 0, len));
}
```

+ `new String(buf, 0, len)` 表示使用 buf 中偏移为 0~len 的字节来构造一个 String，这会使用平台默认的编码方案来解码。同时**注意**，构造 String 时要 read 了多少就使用多少来创建 String，否则可能会使用到上次读取所用到的字符，因此需要显式传入一个 len。
+ 性能优于上面的代码，但依然可能会导致多字节编码的汉字出现乱码问题。

Java 标准库提供了一个用于**将文件所有字节一次性读入**的  API：

|                    方法名称                     | 说明                                                         |
| :---------------------------------------------: | ------------------------------------------------------------ |
| public byte[] readAllBytes() throws IOException | 直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回 |

+ 将文件过大时会抛出异常，但在实际业务中，几乎不会出现读过大的文件，比如读一个 100 G 的文件读入内存没有意义，所以这个 API 绝大部分情况下是可以用的。
+ 可以解决多字节编码的问题。

#### 3.2.2 文件字节输出流：FileOutputStream

|                          构造器                          | 说明                                               |
| :------------------------------------------------------: | :------------------------------------------------- |
|            public FileOutputStream(File file)            | 创建字节输出流管道与源文件对象接通                 |
|    public FileOutputStream(File file，boolean append)    | 创建字节输出流管道与源文件对象接通，可**追加数据** |
|         public FileOutputStream(String filepath)         | 创建字节输出流管道与源文件路径接通                 |
| public FileOutputStream(String filepath，boolean append) | 创建字节输出流管道与源文件路径接通，可追加数据     |

|                       方法名称                       | 说明                         |
| :--------------------------------------------------: | ---------------------------- |
|               public void write(int a)               | 写一个字节出去               |
|           public void write(byte[] buffer)           | 写一个字节数组出去           |
| public void write(byte[] buffer , int pos , int len) | 写一个字节数组的一部分出去。 |

示例：

```java
byte[] buf1 = {'a', 97, 100};
os.write(buf1);

byte[] buf2 = "我是中国人".getBytes();
os.write(buf2);

os.write("\r\n".getBytes());  // 写入换行
```

+ 注意写英文和写中文的区别。
+ 写入换行时用 `\r\n` 可以兼容 Windows 和 Linux，而只写 `\n` 只在 Windows 上有效。

|  方法   | 说明                                                         |
| :-----: | ------------------------------------------------------------ |
| flush() | 刷新流，还可以继续写数据                                     |
| close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |

+ write 完后一定要 flush 一下，因为 FileOutputStream 内部也有缓冲。
+ 操作完数据后要 close。

![image-20220125144911628](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220125144911628.png)

### 3.3 资源释放方式

#### 3.3.1 try-catch-finally

**finally**：在异常处理时提供 finally 块来执行所有清除操作，比如说 IO 流中的释放资源。<u>被 finally 控制的语句最终**一定会执行**，除非JVM退出</u>。

try-catch-finally 格式：

```java
try {
    FileOutputStream fos = new FileOutputStream("a.txt");
    fos.write(97); 
    fos.close();
} catch (IOException e) {
    e.printStackTrace();
} finally {
    System.out.println("----- finally -----")
}
```

也许会想将 `fos.close()` 放到 finally 里，但是 close 本身也可能出问题，而且在 fos 在被定义之前也可能出异常导致 fos 为 null，因此使用这种格式写出来的代码很难保证文件正常关闭。

::: tip finally 中有 return 的情况

一个易错的情况是：

```java
public static int add(int a, int b) {
    try {
        int c = a + b;
        return c;
    } catch (Exception e) {
        e.printStackTrace();
        return -1;
    } finally {
        return 100;
    }
}
```

当我们调用 `add(1, 1)` 后返回的是 100 而不是 2。在开发中，**不建议在 finally 中出现 return**。

:::

#### 3.3.2 try-with-resource

JDK 7 和 JDK 9 都简化了资源释放操作。

![image-20220125154304638](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220125154304638.png)

+ 常用的是 JDK 7 的方式。
+ JDK 7 以及 JDK 9的 `try()` 中**只能放置资源对象**，否则报错。**资源**都是实现了 `Closeable/AutoCloseable` 接口的类对象

```java
public abstract class InputStream implements Closeable {
    ...
}

public abstract class OutputStream implements Closeable, Flushable {
    ...
} 
```

### 3.4 字符流的使用

读取中文是使用字符流更合适，其最小单位是按照单个字符读取的。

Reader、Writer 的一个实现类是 FileReader 和 FileWriter。

#### 3.4.1 文件字符输入流：FileReader

|               构造器                | 说明                               |
| :---------------------------------: | ---------------------------------- |
|    public FileReader(File file)     | 创建字符输入流管道与源文件对象接通 |
| public FileReader(String  pathname) | 创建字符输入流管道与源文件路径接通 |

|            方法名称             | 说明                                                         |
| :-----------------------------: | ------------------------------------------------------------ |
|        public int read()        | 每次读取一个字符返回，如果字符已经没有可读的返回-1           |
| public int  read(char[] buffer) | 每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1 |

示例：【每次读取一个字符】

```java
int c;
while ((c = fr.read()) != -1) {
    System.out.print((char) c);
}
```

+ 读取中文字符不会出现乱码（如果代码编码与文件编码一致）
+ 每次读取一个的性能较差

示例：【每次读取一个字符数组】

```java
char[] buf = new char[1024];
int len;
while ((len = fr.read(buf)) != -1) {
    String s = new String(buf, 0, len);
    System.out.print(s);
}
```

+ 性能不错，也不会出现中文乱码问题

#### 3.4.2 文件字符输出流：FileWriter

|                       构造器                       | 说明                                           |
| :------------------------------------------------: | :--------------------------------------------- |
|            public FileWriter(File file)            | 创建字符输出流管道与源文件对象接通             |
|    public FileWriter(File file，boolean append)    | 创建字符输出流管道与源文件对象接通，可追加数据 |
|         public FileWriter(String filepath)         | 创建字符输出流管道与源文件路径接通             |
| public FileWriter(String filepath，boolean append) | 创建字符输出流管道与源文件路径接通，可追加数据 |

|                  方法名称                  | 说明                 |
| :----------------------------------------: | :------------------- |
|             void  write(int c)             | 写一个字符           |
|          void  write(char[] cbuf)          | 写入一个字符数组     |
| void  write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |
|          void  write(String str)           | 写一个字符串         |
| void  write(String str, int off, int len)  | 写一个字符串的一部分 |
|             void  write(int c)             | 写一个字符           |

+ 如何实现写出去的数据能换行？`fw.write("\r\n")`

|  方法   | 说明                                                         |
| :-----: | ------------------------------------------------------------ |
| flush() | 刷新流，还可以继续写数据                                     |
| close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |

写字符示例：

```java
fw.write('中');  // 不会出问题了

fw.write("中文汉字");  // write(String s);
fw.write("中国人".toCharArray());  // write(char[] buf);

fw.flush();
fw.close();
```

::: tip 字节流 VS. 字符流

+ 字节流适合做一切文件数据的拷贝（音视频，文本）
+ 字节流不适合读取中文内容输出
+ 字符流适合做文本文件的操作（读，写）

:::