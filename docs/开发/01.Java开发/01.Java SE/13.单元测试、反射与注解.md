---
title: 单元测试、反射与注解
date: 2022-01-30 19:33:54
permalink: /pages/e204eb/
categories:
  - 开发
  - Java开发
  - Java SE
tags:
  - 
---
## 1. 单元测试

### 1.1 单元测试概述

**单元测试**就是针对最小的功能单元编写测试代码，Java 程序最小的功能单元是方法，因此，单元测试就是**针对 Java 方法的测试**，进而检查方法的正确性。

**JUnit** 是使用 Java 语言实现的单元测试框架，几乎所有的 IDE 工具都集成了 JUnit，这样我们就可以直接在 IDE 中编写并运行 JUnit 测试。

JUnit **优点**：

+ 可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法
+ 可以生成全部方法的测试报告
+ 单元测试中的某个方法测试失败了，不会影响其他测试方法的测试

### 1.2 单元测试快速入门

需求：使用单元测试进行业务方法预期结果、正确性测试的快速入门

过程：

1. 将 JUnit 的 jar 包导入到项目中；
2. 编写测试方法：该测试方法必须是公共的无参数无返回值的非静态方法；
3. 在测试方法上使用 `@Test `注解：标注该方法是一个测试方法；
4. 在测试方法中完成被测试方法的预期正确性测试（用 `Assert` 类）；
5. 选中测试方法，选择“JUnit运行” ：红色失败，绿色成功。

进行预期的**正确性测试**：断言——`Assert.assertEquals(...)`。

### 1.3 单元测试常用注解

Junit 常用注解(Junit **4**.xxxx版本)：

| 注解         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| @Test        | 测试方法                                                     |
| @Before      | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。 |
| @After       | 用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。 |
| @BeforeClass | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。     |
| @AfterClass  | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。     |

+ 开始执行的方法:初始化资源。
+ 执行完之后的方法:释放资源。

Junit 常用注解(Junit **5**.xxxx版本)：

| 注解        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| @Test       | 测试方法                                                     |
| @BeforeEach | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。 |
| @AfterEach  | 用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。 |
| @BeforeAll  | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。     |
| @AfterAll   | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。     |

## 2. 反射

### 2.1 概述

**反射**是指对于任何一个Class类，在"运行的时候"都可以直接得到这个类全部成分。

+ 在运行时,可以直接得到这个类的构造器对象：Constructor
+ 在运行时,可以直接得到这个类的成员变量对象：Field
+ 在运行时,可以直接得到这个类的成员方法对象：Method

这种运行时动态获取类信息以及动态调用类中成分的能力称为 Java 语言的**反射机制**。

反射的核心思想和**关键**就是：得到编译以后的 class 文件对象

HelloWorld.java -> javac -> HelloWorld.class

```java
Class c = HelloWorld.class;
```

### 2.2 获取 Class 对象

![image-20220131150236109](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220131150236109.png)

三种方式：

1. `Class.forName("com.example.Student")`
2. `Student.class`
3. `s.getClass()`

### 2.3 获取 Constructor 对象

| 方法                                                         | 说明                                           |
| ------------------------------------------------------------ | ---------------------------------------------- |
| `Constructor<?>[]  getConstructors()`                        | 返回所有构造器对象的数组（**只能拿public的**） |
| `Constructor<?>[]  getDeclaredConstructors()`                | 返回所有构造器对象的数组，**存在就能拿到**     |
| `Constructor<T>  getConstructor(Class<?>...  parameterTypes)` | 返回单个构造器对象（只能拿public的）           |
| `Constructor<T>  getDeclaredConstructor(Class<?>...  parameterTypes)` | 返回单个构造器对象，存在就能拿到               |

获取构造器的作用依然是初始化一个对象。Constructor 类中用于创建对象的方法：

| 符号                                          | 说明                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| T **newInstance**(Object...  initargs)        | 根据指定的构造器创建对象                                     |
| public  void **setAccessible**(boolean  flag) | 设置为true，表示取消访问检查，进行**暴力反射**，从而可以拿到私有的构造器来创建对象，这个方式**破坏了封装性**。 |

### 2.4 获取 Field 对象

| 方法                                  | 说明                                         |
| ------------------------------------- | -------------------------------------------- |
| Field[]  getFields()                  | 返回所有成员变量对象的数组（只能拿public的） |
| Field[]  getDeclaredFields()          | 返回所有成员变量对象的数组，存在就能拿到     |
| Field  getField(String  name)         | 返回单个成员变量对象（只能拿public的）       |
| Field  getDeclaredField(String  name) | 返回单个成员变量对象，存在就能拿到           |

 获取成员变量可以在某个对象中取值、赋值，Field 类中用于取值、赋值的方法：

|                 符号                  | 说明     |
| :-----------------------------------: | -------- |
| void  set(Object obj, Object value)： | 赋值     |
|        Object  get(Object obj)        | 获取值。 |

如果成员是非 public 的，那可以用 `setAccessible` 打开权限。

### 2.5 获取 Method 对象

| 方法                                                         | 说明                                         |
| ------------------------------------------------------------ | -------------------------------------------- |
|Method[]  getMethods()                                       | 返回所有成员方法对象的数组（只能拿public的） |
|Method[]  getDeclaredMethods()                               | 返回所有成员方法对象的数组，存在就能拿到     |
|Method  getMethod(String  name, Class<?>... parameterTypes)  | 返回单个成员方法对象（只能拿public的）       |
|Method  getDeclaredMethod(String  name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到           |

l获取成员方法后可以在某个对象中进行执行此方法，Method 类中用于触发执行的方法：

| 符号                                          | 说明                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| Object **invoke**(Object obj, Object... args) | 运行方法。参数一：用obj对象调用该方法； 参数二：调用方法的传递的参数（如果没有就不写）；返回值：方法的返回值（如果没有就不写） |

如果方法是非 public 的，那可以用 `setAccessible` 打开权限。

### 2.6 反射的作用 —— 绕过编译阶段为集合添加数据

反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以**为集合存入其他任意类型的元素**。因为泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成 Class 文件进入运行阶段的时候，其真实类型都是原生 ArrayList 了，泛型相当于被擦除了。**反射是作用在运行时的技术，此时已经不存在泛型了**。

### 2.7 反射的作用 —— 通用框架的底层原理

需求：给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。比如：

![image-20220131154633699](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220131154633699.png)

分析：

1. 定义一个方法，可以接收任意类的对象；
2. 使用反射获取对象的Class类对象，然后获取全部成员变量信息；
3. 遍历成员变量信息，然后提取本成员变量在对象中的具体值；
4. 存入成员变量名称和值到文件中去即可。

基本上主流框架都会基于反射设计一些通用技术功能。

## 3. 注解

