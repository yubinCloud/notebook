---
title: 多线程
date: 2022-01-29 14:54:12
permalink: /pages/458e89/
categories:
  - 开发
  - Java开发
  - Java SE
tags:
  - 
---

## 1. 基本概念：程序、进程、线程

+ **程序**（program）：指一段静态的代码，是静态的。
+ **进程**（process）：正在运行的一个程序，是一个动态的过程。进程作为**资源分配的单位**，系统在运行时会为每个进程分配不同的内存区域（虚拟内存）。
+ **线程**（thread）：一个程序内部的一条执行路径。
  + 若一个进程同一时间**并行**执行多个线程，就是支持多线程的。
  + 线程作为**调度和执行的单位**，每个线程<u>拥有独立的运行栈和程序计数器(pc)</u>，线程切换的开销小。
  + 一个进程中的**多个线程共享相同的内存地址空间** —> 它们从同一堆中分配对象，可以访问相同的变量和对象。

#### 单核CPU & 多核CPU

单核 CPU 为在一个时间单元内，也只能执行一个线程的任务。如果是多核的话，才能更好的发挥多线程的效率。

> 一个 Java 应用程序其实至少有三个线程：main() 主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。

#### 并行 & 并发

**并发**（Concurrent）：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。

**并行**（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行。

> 并发是在一段时间内宏观上多个程序同时运行，并行是在某一时刻，真正有多个程序在运行。

## 2. 线程的创建和使用

### 2.1 API 中创建线程的两种方式

JDK1.5 之前创建新执行线程有两种方法：

+ 继承 Thread 类的方式
+ 实现 Runnable 接口的方式

#### 2.1.1 继承 Thread 类的方式

1. 定义子类继承 Thread 类，并**重写 Thread 类中的 run 方法**
2. 实例化这个类，即创建了线程对象
3. **调用线程对象的 `start` 方法**，这是会启动线程，并自动调用之前定义的 `run` 方法

**示例**：一个线程，计算比给定值大的素数：

```java {7, 14}
class PrimeThread extends Thread {
    long minPrime;
    PrimeThread(long minPrime) {
        this.minPrime = minPrime;
    }

    public void run() {
        // compute primes larger than minPrime
        . . .
    }
}

PrimeThread p = new PrimeThread(143);
p.start();
```

::: warning 区分好 start 和 run 方法

+ 如果自己手动调用 run() 方法，那么就只是普通方法，没有启动多线程模式。
+ run() 方法由 JVM 调用，什么时候调用，执行的过程控制都有操作系统的 CPU 调度决定。
+ 想要启动多线程，必须调用 start 方法。
+ **一个线程对象只能调用一次 start() 方法启动**，如果重复调用了，则将抛出以上的异常 `IllegalThreadStateException`。

:::



::: details 示例：多窗口买票

```java
public class Window extends Thread {
    
    private static int ticket = 100;

    @Override
    public void run() {
        while(true) {
            if (ticket > 0) {
                System.out.println(getName() + "：卖票，票号为：" + ticket);
                ticket--;
            } else
                break;
        }
    }
}

public class WindowTest {
    public static void main(String[] args) {
        Window t1 = new Window();
        Window t2 = new Window();
        Window t3 = new Window();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

运行结果如下：

```
窗口3：卖票，票号为：100
窗口1：卖票，票号为：100
窗口2：卖票，票号为：100
...
```

可以看到产生了不符合预期的行为，这是因为多个线程操作共享的系统资 源可能就会带来**安全的隐患**。之后我们要想办法解决这个问题。

:::

#### 2.2.2 实现 Runnable 接口的方式

1. 定义子类，**实现 Runnable 接口**，并**重写 run 方法**
2. 通过 Thread 类含参构造器创建线程对象
3. 将 Runnable 接口的子类对象作为实际参数传递给 Thread 类的构造器中
4. **调用对象的 start 方法**：开启线程，调用Runnable子类接口的run方法

示例：

```java
class PrimeRun implements Runnable {
    long minPrime;
    PrimeRun(long minPrime) {
        this.minPrime = minPrime;
    }

    public void run() {
        // compute primes larger than minPrime
        . . .
    }
}

PrimeRun p = new PrimeRun(143);
new Thread(p).start();
```

::: tip 继承方式 VS. 实现方式

+ 区别
  + 继承 Thread：线程代码存放Thread子类 run 方法中
  + 实现 Runnable：线程代码存在接口的子类的 run 方法
+ 实现方式的好处
  + 避免了单继承的局限性
  + 实现方式中**多个线程可以共享同一个接口实现类的对象**，非常适合多个相同线程来处理同一份资源
+ 相同
  + 两种方式都需要重写 `run()`，将线程要执行的逻辑声明在 run() 中。

:::

### 2.2 Thread 类的常用方法

#### 1）Thread 获取和设置线程名称

| 方法名称                        | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| String  **getName**()           | 获取当前线程的名称，默认线程名称是 “Thread-索引”             |
| void  **setName**(String  name) | 将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称 |

#### 2）Thread 类获得当前线程的对象

| 方法名称                                        | 说明                               |
| ----------------------------------------------- | ---------------------------------- |
| public  **static** Thread **currentThread**()： | 返回对当前正在执行的线程对象的引用 |

+ 此方法是 Thread 类的**静态方法**，可以直接使用Thread类调用。
+ 这个方法是在**哪个线程执行中调用的，就会得到哪个线程对象**。

#### 3）常用构造器

| 方法名称                                         | 说明                                         |
| ------------------------------------------------ | -------------------------------------------- |
| public  Thread(String name)                      | 可以为当前线程指定名称                       |
| public  Thread(Runnable target)                  | 封装Runnable对象成为线程对象                 |
| public  Thread(Runnable target  ，String  name ) | 封装Runnable对象成为线程对象，并指定线程名称 |

#### 4）线程休眠方法

| 方法名称                                   | 说明                                                   |
| ------------------------------------------ | ------------------------------------------------------ |
| public  **static** void sleep(long millis) | 让当前线程休眠指定的时间后再继续执行，**单位为毫秒**。 |

```java
// 项目经理要求这里运行缓慢，好让客户给钱优化
Thread.sleep(2000);
```

#### 5）与调度相关的方法

| 方法名称                    | 说明                                                         |
| --------------------------- | :----------------------------------------------------------- |
| **static** void **yield**() | 线程**让步**。暂停当前正在执行的线程，**把执行机会让给优先级相同或更高的线程**，若队列中没有同优先级的线程，则忽略此方法继续执行。 |
| **join**()                  | 当某个程序执行流中**调用<u>其他线程</u>的 join() 方法**时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止。比如在 A 线程中调用了 B.join()，那么 A 将被阻塞，直到 B 执行完后 A 才继续执行。 |
| ~~stop()~~                  | 强制线程生命期结束，<u>已过时</u>。                          |

#### 6）判断当前进程是否存活

| 方法名称          | 说明               |
| ----------------- | ------------------ |
| boolean isAlive() | 判断线程是否还活着 |

### 2.3 线程的调度

#### 2.3.1 调度策略

两种调度策略：

+ **时间片**式
+ **抢占**式：高优先级的线程抢占CPU

Java 的调度方法：

+ 同优先级线程组成先进先出队列（先到先服务），使用时间片策略；
+ 对高优先级，使用优先调度的抢占式策略

#### 2.3.2 线程的优先级

优先级等级：

+ MAX_PRIORITY：10  
+ MIN _PRIORITY：1 
+ NORM_PRIORITY：5

涉及的方法：

+ **getPriority()**：返回线程优先值
+ **setPriority(int newPriority)** ：改变线程的优先级

::: tip

+ 线程创建时**继承父线程的优先级**
+ 低优先级只是获得调度的概率低，**并非**一定是在高优先级线程之后才被调用

:::

### 2.4 线程的分类

Java中的线程分为两类：一种是**守护线程**，一种是**用户线程**。

+ 它们在几乎每个方面都是相同的，唯一的区别是判断 JVM 何时离开。
+ 守护线程是用来服务用户线程的，通过在 start() 方法前调用。thread.setDaemon(true) 可以把一个用户线程变成一个守护线程。
+ Java 垃圾回收就是一个典型的守护线程。
+ 若 JVM 中都是守护线程，当前 JVM 将退出【兔死狗烹，鸟尽弓藏】。

## 3. 线程的声明周期

// TODO