---
title: 持有对象（集合）
date: 2022-02-01 16:53:54
permalink: /pages/652e31/
categories:
  - 开发
  - Java开发
  - Java SE
tags:
  - 
---

Java 提供了一套**容器类**用来“保存对象”，并将其划分为两个不同的概念：

+ **Collection**：一个独立元素的序列，包括 List、Set 和 Queue
+ **Map**：一组“键值对”的映射表

这些类型统称为**集合类**，但由于 Collection 又是其中一个特定子集的术语，所以往往也使用更宽泛的术语“容器”。

![java_collections_overview](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/java_collections_overview.png)

## 1. Collection 集合体系

Collection 是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。

### 1.1 Collection 常用 API

| 方法名称                             | 说明                             |
| ------------------------------------ | -------------------------------- |
| public  boolean add(E e)             | 把给定的对象添加到当前集合中     |
| public  void clear()                 | 清空集合中所有的元素             |
| public  boolean remove(E e)          | 把给定的对象在当前集合中删除     |
| public  boolean contains(Object obj) | 判断当前集合中是否包含给定的对象 |
| public  boolean isEmpty()            | 判断当前集合是否为空             |
| public  int size()                   | 返回集合中元素的个数。           |
| public  Object[] toArray()           | 把集合中的元素，存储到数组中     |

### 1.2 Collection 的遍历方式

#### 1）方式一：迭代器

Collection 集合获取迭代器：

| 方法名称                  | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `Iterator<E>  iterator()` | 返回集合中的迭代器对象，该迭代器对象**默认指向当前集合的 0 索引** |

Iterator 中的常用方法：

| 方法名称          | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| boolean hasNext() | 询问当前位置是否有元素存在，存在返回true ,不存在返回false    |
| E  next()         | 获取当前位置的元素，并同时将迭代器对象移向下一个位置，注意防止取出越界。 |

+ 迭代器取元素时越界会出现 NoSuchElementException 异常。

```java
Iterator<String> it = lists.iterator();
while(it.hasNext()){
    String ele = it.next();
    System.out.println(ele);
}
```

 #### 2）方式二：foreach

```java
for(Type varName : 数组或者Collection集合) {
	// ...
}
```

+ 既可以遍历集合也可以遍历数组。

#### 3）方式三：lambda 表达式

JDK 8 的新技术 Lambda 表达式，提供了一种更简单、更直接的遍历集合的方式。

Collection 结合 Lambda 遍历的 API：

| 方法名称                                           | 说明                 |
| -------------------------------------------------- | -------------------- |
| `default void forEach(Consumer<? super T> action)` | 结合 lambda 遍历集合 |

```java
lists.forEach(s -> {
    System.out.println(s);
});
```

## 2. List 系列集合

特点：有序、可重复、有索引。

### 2.1 List 特有方法

List 集合因为支持索引，所以多了很多索引操作的独特 API，其他 Collection 的功能List也都继承了。

| 方法名称                       | 说明                                   |
| ------------------------------ | -------------------------------------- |
| void add(int  index,E element) | 在此集合中的指定位置插入指定的元素     |
| E remove(int  index)           | 删除指定索引处的元素，返回被删除的元素 |
| E set(int index, E element)    | 修改指定索引处的元素，返回被修改的元素 |
| E get(int  index)              | 返回指定索引处的元素                   |

+ ArrayList 底层是基于数组实现的，根据查询元素快，增删相对慢（但在实际上也非常快）。
+ LinkedList 底层**基于双链表**实现的，查询元素慢，增删首尾元素是非常快的（多了很多增删首尾的 API）。

### 2.2 List 的遍历

① 迭代器 ② foreach ③ Lambda ④ 普通 for 循环（因为 List 支持索引） 

## 3. 泛型深入

### 3.1 泛型概述

泛型是 JDK5 中引入的特性，可以**在编译阶段**约束操作的数据类型，并进行检查。

格式：`<Type>`，只支持引用数据类型。

泛型**好处**：

+ 统一数据类型
+ 把运行时期的问题**提前到了编译期间**，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来

泛型可以在很多地方使用：泛型**类**、泛型**方法**、泛型**接口**。

### 3.2 自定义泛型类

格式示例：`public class MyArrayList<T> {}`

+ 泛型变量常用的标识是：T、E、K、V 等

核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型

类似地可定义泛型方法和泛型接口。

### 3.3 泛型通配符、上下限

通配符：`?`

+ ? 可以在“使用泛型”的时候代表一切类型
+ E T K V 是在定义泛型的时候使用的

**案例导学**：

+ 开发一个极品飞车的游戏，所有的汽车都能一起参与比赛

```java
class Car {
    ...
}

/** 宝马 */
class BMW extends Car {
    ...
}

/** 奔驰 */
class BENZ extends Car {
    ...
}
```

**注意**：<Badge text="易错" />  虽然 BMW 和 BENZ 都继承了 Car 但是 `ArrayList<BMW>` 和 `ArrayList<BENZ>` 与 `ArrayList<Car>` 没有关系的！!

泛型的上下限：

+ `? extends Car`：其中的 `?` 必须是 Car 或者其**子类**，泛型上限
+ `? super Car`：其中的 `?` 必须是 Car 或者其**父类**，泛型下限

::: tip 助记

extends —— 子类

super —— 父类

:::