---
title: Spring 拦截器、异常处理与 AOP
date: 2022-02-11 14:12:00
permalink: /pages/b1a585/
categories:
  - 开发
  - Java开发
  - SSM
tags:
  - 
---
## 1. Spring MVC 拦截器

Spring MVC 的**拦截器**类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行**预处理和后处理**。

将拦截器按一定的顺序联结成一条链，这条链称为**拦截器链**（Interceptor Chain）。<u>在访问被拦截的方 法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用</u>。拦截器也是 AOP 思想的具体实现。

::: tip 拦截器 VS. 过滤器

| 区别     | 过滤器（Filter）                                             | 拦截器（Interceptor）                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 使用范围 | 是 servlet 规范中的一部分，任何 Java Web 工程都可以使用      | 是 Spring MVC 框架自己的，**只有使用了 Spring MVC 框架的工程才能用** |
| 拦截范围 | 在 url-pattern 中配置了 `/*` 之后， 可以对所有要访问的资源拦截 | 在 `<mvc:mapping path=""/>` 中配置了 `/**` 之后，也可以多所有资源进行拦截，但是可以通过 `<mvc:exclude-mapping path=""/>` 标签排除不需要拦截的资源 |

+ 这俩的功能很多重叠，但在 Spring 中往往使用 Interceptor

:::

### 1.1 拦截器快速入门

自定义拦截器很简单，只有如下三步：

1. 创建拦截器类实现 HandlerInterceptor 接口
2. 配置拦截器
3. 测试拦截器的拦截效果

#### 1）创建拦截器类实现 HandlerInterceptor 接口

```java {2,6,9}
public class MyHandlerInterceptor1 implements HandlerInterceptor {
    // 目标方法执行前
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
		System.out.println("preHandle running...");
		return true;
	}
    
    // 目标方法执行后
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {
		System.out.println("postHandle running...");
	}
    
    // 在流程都执行完毕后
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
		System.out.println("afterCompletion running...");
	}
}
```

+ 实现了 HandlerInterceptor 接口并重写相应的方法

#### 2）配置拦截器

```xml
<!--配置拦截器-->
<mvc:interceptors>
	<mvc:interceptor>
		<mvc:mapping path="/**"/>
		<bean class="com.itheima.interceptor.MyHandlerInterceptor1"/>
	</mvc:interceptor>
</mvc:interceptors>
```

+ `<mvc:mapping>` 标签表示对哪些资源执行拦截操作

#### 3）测试拦截器的拦截效果

对之前配置的资源进行访问时都会被拦截。

### 1.2 拦截器方法说明

|      方法名       | 说明                                                         |
| :---------------: | ------------------------------------------------------------ |
|    preHandle()    | **在请求处理之前调用**，该方法的返回值是 boolean 类型的， 当它返回为 false 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 true 时就会继续调用下一个 Interceptor 的 preHandle 方法.。 |
|   postHandle()    | **在当前请求进行处理之后被调用**，它会在 DispatcherServlet 进行视图返回渲染之前被调用，所以我们<u>可以在这个方法中对 Controller 处理之后的 ModelAndView 对象进行操作</u> |
| afterCompletion() | **在整个请求结束后**，也就是在 DispatcherServlet 渲染了对应的视图之后执行 |

### 1.3 多拦截器操作

与之前相同，再编写一个 MyHandlerInterceptor2 类即可。

## 2. Spring MVC 异常处理机制

### 2.1 异常处理的思路

系统中异常包括两类：**预期异常**和**运行时异常** RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。

系统的 Dao、Service、Controller 出现都通过 throws Exception 向上抛出，最后由 Spring MVC 前端控制器交由异常处理器进行异常处理，如下图：

![image-20220211165904793](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220211165904793.png)

### 2.2 异常处理的两种方式

+ 方式一：使用 Spring MVC 提供的简单异常处理器 SimpleMappingExceptionResolver
+ 方式二：实现 Spring 的异常处理接口 HandlerExceptionResolver 自定义自己的异常处理器

### 2.3 简单异常处理器 —— SimpleMappingExceptionResolver

Spring MVC 已经定义好了该类型转换器，在使用时可以根据项目情况进行相应**异常与视图的映射配置**。

```xml
<!--配置简单映射异常处理器-->
<bean 
class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”>
  <property name=“defaultErrorView” value=“error”/>
  <property name=“exceptionMappings”>
    <map>
      <entry key="com.itheima.exception.MyException" value="error"/>
      <entry key="java.lang.ClassCastException" value="error"/>
    </map>
  </property>
</bean>
```

+ line 4 的 property 表示**默认错误视图**。
+ `<map>` 下面的每个 `<entry>` 配置异常类型（key）与错误视图（value）的映射。

### 2.4 自定义异常处理步骤

1. 创建异常处理器类实现 HandlerExceptionResolver
2. 配置异常处理器
3. 编写异常页面
4. 测试异常跳转

#### 1）创建异常处理器类实现 HandlerExceptionResolver

```java
public class MyExceptionResolver implements HandlerExceptionResolver {
	@Override
	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
		//处理异常的代码实现
		ModelAndView modelAndView = new ModelAndView();
		modelAndView.setViewName("exceptionPage");
		return modelAndView;
	}
}
```

+ 参数 Exception：异常对象
+ 返回值 ModelAndView：跳转到错误视图信息

#### 2）配置异常处理器

```html
<bean id="exceptionResolver" 
      class="com.itheima.exception.MyExceptionResolver"/>
```

#### 3）编写异常页面

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
  <title>Title</title>
</head>
<body>
  这是一个最终异常的显示页面
</body>
</html>
```

#### 4）测试异常跳转

```java
@RequestMapping("/quick22")
@ResponseBody
public void quickMethod22() throws IOException, ParseException {
	SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
	simpleDateFormat.parse("abcde");
}
```

