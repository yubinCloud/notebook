---
title: Spring Cloud 快速入门 3：服务异步通讯
date: 2022-03-10 14:23:34
permalink: /pages/84183c/
categories:
  - 开发
  - Java开发
  - 微服务技术栈
tags:
  - 
---
## 1. RabbitMQ 服务异步通讯

### 1.1 初始 MQ

微服务间通讯有同步和异步两种方式：

+ 同步通讯：就像打电话，需要实时响应。
+ 异步通讯：就像发邮件，不需要马上回复。

#### 1.1.1 同步通讯

Feign 调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的**问题**：

+ 耦合度高：每次加入新的需求，都需要改动原来的代码
+ 性能下降：需等待服务提供者，如果调用链过长，则等待时长等于每次调用的时长之和
+ 资源浪费：在等待响应过程中不能释放请求占用，高并发下占用过多系统资源
+ 级联失败：如果服务提供者出现问题，那么所有的调用方都会出现问题

#### 1.1.2 异步通讯

异步调用的常见实现就是事件驱动模式：为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到 Broker，不关心谁来订阅事件。订阅者从 Broker 订阅事件，不关心谁发来的消息。

![image-20210422095356088](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20210422095356088.png)

Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。

![image-20220310143507278](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220310143507278.png)

好处：

+ 吞吐量提升：无需等待订阅者处理完成，响应更快速
+ 故障隔离：服务没有直接调用，不存在级联失败问题
+ 调用间没有阻塞，不会造成无效的资源占用
+ 耦合度极低，每个服务都可以灵活插拔，可替换
+ 流量削峰：不管发布事件的流量波动多大，都由 Broker 接收，订阅者可以按照自己的速度去处理事件

#### 1.1.3 技术对比

MQ，中文是消息队列（Message Queue），字面来看就是存放消息的队列。也就是事件驱动架构中的 Broker。常见实现：ActiveMQ，RabbitMQ，RocketMQ，Kafka。

### 1.2 安装 RabbitMQ

建议在 Docker 中安装：

+ 在线拉取镜像：`docker pull rabbitmq:3-management`
+ 安装 MQ：

```sh
docker run \
 -e RABBITMQ_DEFAULT_USER=yubin \
 -e RABBITMQ_DEFAULT_PASS=123456 \
 --name mq \
 --hostname mq1 \
 -p 15672:15672 \
 -p 5672:5672 \
 -d \
 rabbitmq:3-management
```

之后可以访问 `host:15672` 查看。

RabbitMQ 中的一些概念：

- publisher：生产者
- consumer：消费者
- exchange个：交换机，负责消息路由
- queue：队列，存储消息
- virtual host：虚拟主机，隔离不同租户的 exchange、queue、消息的隔离

### 1.3 RabbitMQ 消息模型

RabbitMQ 官方提供了多个不同的Demo示例，对应了不同的消息模型：

![image-20210717163332646](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20210717163332646.png)

### 1.4 入门案例

[RabbitMQ tutorial - "Hello World!" — RabbitMQ](https://www.rabbitmq.com/tutorials/tutorial-one-java.html)