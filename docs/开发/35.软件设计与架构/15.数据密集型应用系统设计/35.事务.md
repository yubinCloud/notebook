---
title: 事务
date: 2023-01-29 17:04:59
permalink: /pages/DDIA/note/transaction/
categories:
  - 开发
  - 软件设计与架构
  - 数据密集型应用系统设计
tags:
  - 
---

在分布式数据系统中，任何问题都有可能发生：

1. 系统侧：数据库系统和硬件系统任何时间都有可能发生故障
2. 应用侧：使用数据库的应用程序任何时刻都有可能故障。
3. 网络侧：应用程序和数据库间，数据库的多个节点间，随时都有可能断开连接。
4. 多个客户端：并发写入时，可能会有竞态条件和相互覆盖。
5. 半读：一个客户端可能会读到部分更新的数据库。

复杂度不会凭空消失，只会发生转移。如果数据库对这些故障不做任何处理，应用层就需要处理上述所有相关问题，会极大增加应用侧编程复杂度。事务就是数据库为了解决类似的问题，所提供的一种保证，**以简化应用层的编程模型**。

<mark>事务</mark>将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元，并提供一种保证，这一组操作要么全部成功（ **commit**，应用到数据库里），要么全部失败（被动 **abort**，或者主动 **rollback**），而不会存在只执行了一半的中间状态。此外，如果多个客户端的事务并发执行，会涉及到隔离性的问题，一般来说，数据库允许用户在隔离级别和性能之间做选择。

事务也可以从**时间**和**空间**两个角度来理解：

+ 从生命周期（**时间**）来讲：事务要保证一组操作的整体性
+ 从并发控制（**空间**）来讲：事务要做好多个事务间的并发控制

有了这种语义上的保证，用户在发现事务失败后，可以放心的进行重试，直到成功，就可以确定事务中的所有操作都生效了。但任何便利性都是有代价的，<u>事务便是在一定程度上牺牲了性能和可用性</u>。

几乎所有的关系型数据库和一些非关系型都支持事务处理，然而到了 21 世纪末，NoSQL 开始兴起，它们的目标是通过提供新的数据模型以及内置的复制和分区来改进传统的关系模型，然而事务却成为了这场变革的受害者：<u>很多新一代的数据库完全放弃了事务支持，或者将其重新定义，即替换为比以前弱得多的保证</u>。

> 很多数据库不再支持完整的事务，而是偷换概念，说成“xxx事务”，这其实是换个名词来骗外行。

有人认为大规模系统为了性能和高可用将不得不牺牲事务的支持，也有人坚持事务是保证高价值数据和关键应用的必备功能。其实这两个观点都有点夸大其词，应该根据实际情况来做 trade-off。

本章首先讨论事务的基本概念，然后针对隔离级别（并发控制）做了详细探讨，包括读已提交、快照隔离和可串行化。事务保证和是否分布式在概念上相对正交，但在实现上，分布式系统中事务的实现难度要大的多。

## 1. ACID 的含义

Theo Härder 和 Andreas Reuter 于 1983 提出的 ACID，它最初是为了数据库中的容错保证给出一种相对精确的描述，但实际上各家数据库的实现并不相同，现在的 ACID 更像是一个市场营销术语。

不符合 ACID 标准的系统有时被冠以“BASE”，是指基本可用性（**B**asically Available）、软状态（**S**oft state）和最终一致性（**E**ventual consistency）

下面，将逐一探究 Atomicity、Consistency、Isolation 和 Durability 的精确含义，以此来对事务所要做出的保证建立一个基本的认识。

### 1.1 原子性（Atomicity）

> 一句话：要么全成功，要么全失败

<mark>原子性</mark>：在单个客户端/线程内，一组操作可以被原子的执行，如果执行到一半失败，已经执行的操作可以被全部回滚。

因此，ACID 中原子性所提供的保证是：**在发生错误时，会回滚该事务所有已经写入的变更**。

这个保证很重要，否则用户在执行到一半出错时，很难知道哪些操作已经生效、哪些操作尚未生效。有了此保证，用户如果发现出错，可以安全的进行重试。

> 注意与并发编程中的“原子性”相区分，在并发编程中，原子性通常和可见性关联，即一个线程无法看到另一个线程执行的原子操作的中间结果。但 <u>ACID 的原子性并不关心多个操作的并发性</u>，它没有描述多个线程试图访问相同的数据会发生什么情况。

### 1.2 一致性（Consistency）

<mark>一致性</mark>：是指对某些**不变性**（invariants）的维持，所谓不变性，即某些约束条件。如，在银行账户中，在任何时刻，账户余额须等于收入减去支出。

不同于 ACID 中其他性质，**一致性是需要应用侧和数据库侧共同维护的**：

1. 应用侧需要写入满足应用侧视角约束要求的数据。
2. 数据库侧需要保证多次写入前后，尤其是遇到问题时，维持该约束。

因此，一致性可以表述为，应用侧依赖数据库提供的原子性、隔离性来实现一致性。可见，一致性并非数据库事务本身的一种特性，更多的是应用侧的一种属性。据此，乔・海勒斯坦（Joe Hellerstein）认为，在 Härder 与 Reuter 的论文中，“ACID 中的 C 是 用来凑数的”。

> 在不同的上下文中，“一致性”这个词有着不同的含义：
>
> + 多副本：之前讨论了多副本一致性和最终一致性的问题
> + 一致性哈希：一种分区和调度的方式
> + CAP 定理：一致性指的是线性一致性，是多副本间一致性的一种特例
> + ACID：数据库在应用程序的视角处于某种”一致性的状态“

### 1.3 隔离性（Isolation）

多个客户端并发访问数据库时，如果访问的数据没有交集，是可以随意并发的。但如果有交集，则会产生**并发问题**，或称**竞态条件**（race condition）。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230129174731936.png" alt="image-20230129174731936" style="zoom: 67%;" /></center>

设有一个计数器，且数据库没有内置原子的自增操作，有两个用户，各自读取当前值，加 1 后写回。如图，期望计数器由 42 变为 44，但由于并发问题，最终变成了 43 。

<mark>隔离性</mark>是指，每个事务的执行是互相隔离的，每个事务都可以认为自己是系统中唯一正在运行的事务，因此传统上，教科书将事务隔离形式称为：**可串行化（Serializability）**。

但在实践中，由于性能问题很少使用串行化隔离。实际上隔离性强弱类似于一个光谱，数据库系统提供商一般会实现其中几个，用户可以根据业务情况在隔离性和性能间进行选择。

> 隔离性是最重要、最难理解的一个概念，之后会讨论除了可串行化之外的几种弱隔离级别。

### 1.4 持久性（Durability）

<mark>持久性</mark>是一种保证：事务一旦提交，即使服务器宕机重启、甚至发生硬件故障，已写入的数据就不会丢失。

+ 对于单节点数据库，持久性意味着数据已被写入非易失性存储设备，这可能是以 page 或 WAL 的形式写入的
+ 对于多副本数据库，持久性意味着数据已成功复制到多个节点，因此为了实现这种保证，数据库必须等到复制完成之后才能报告事务成功提交

但，**持久性都只能做到某种程度的保证，而非绝对保证**，比如：

1. 对于单机，可以容忍宕机。但磁盘坏了就完犊子。
2. 对于多机，可以容忍少数副本损坏，但是多数副本完后也没辙。

所以我们也往往分“物理”和“抽象”两种视角来审视一个系统，这里所说的持久性更像是一个抽象层面的保证。

在实践中，要通过多种手段，比如强制刷盘、校验码、异地复制、定时备份等多种手段来保证数据的持久性，但也只能做到大概率的保证（比如五个九），而非绝对保证。现实就是没有哪一项技术可以提供绝对的持久性保证，这些都是降低风险的手段。

### 1.5 Summary

|         ACID          | 描述                                 |
| :-------------------: | ------------------------------------ |
|  原子性（Atomicity）  | 一组操作，要么全成功，要么全失败     |
| 一致性（Consistency） | 对不变性的维持（用户 -50，商家 +50） |
|  隔离性（Isolation）  | 多个事务的执行相互隔离               |
| 持久性（Durability）  | 一旦提交，永不丢失                   |

## 2. 单对象与多对象的事务操作

ACID 是数据库对同一事务中包含多个写操作时所提供的保证。相比**单对象事务**，这种**多对象事务**是一种更强的保证，且更常用，因为通常的多个写入不会只针对单个对象。

举一个例子，设有电子邮件情景，邮箱首页需要如下语句来展示未读邮件数：

```sql
 SELECT COUNT(*) FROM emails WHERE recipient_id = 2 AND unread_flag = true
```

如果邮件过多，为了加快查询，可以使用额外字段将未读邮件数存储存储起来（术语：<mark>denormalization</mark>），但每次新增、读过邮件之后都要更新该计数值。这时可能会产生下面这种情况：如下图，用户 1 插入一封邮件，然后更新未读邮件数；用户 2 先读取读取邮件列表，后读取未读计数。但邮箱列表中显示有新邮件，但未读计数却显示 0 。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230130184332802.png" alt="image-20230130184332802" style="zoom: 67%;" /></center>

这种问题其实就是某个事务读取了另一个事务中尚未提交的写入（“脏读”），从而违反了隔离性。

这个例子是想说，<u>多对象操作往往需要事务的保证来防止出现错误的现象</u>。

在多对象事务中，一个关键点是如何确定多个操作是否属于同一事务：

1. **从物理上来考虑**：可以通过 TCP 连接来确定，在同一个连接中，`BEGIN TRANSACTION` 和 `COMMIT`语句之间的所有内容，可以认为属于同一个事务。但会有一些 corner case，如在客户端提交请求后，服务器确认提交之前，网络中断，连接断开，此时客户端则无从得知事务是否被成功提交。
2. **从逻辑上来考虑**：使用事务管理器，为每个事务分配一个唯一标识符，从而对操作进行分组。

实际中基本上使用第二种方法。

::: danger 
有一些非关系型数据库，**虽然提供 Batch 操作接口（如批量更新），但它们并不一定有事务语义**，即可能有些对象成功，另外一些对象操作却失败。
:::

### 2.1 单对象写入

当只更改单个对象时，仍会面临原子性和隔离性的问题。假设，在文档数据库中，你正在写入一个 20 KB 的 JSON 文档：

1. 如果发送了前 10 kb 数据后，网络断开，数据库是否已经存储了这不完整的 10k 数据？
2. 如果该操作是正在覆盖一个老版本同 id 数据，覆盖一半时电源发生故障，数据库是否会存在一半旧值一半新值？
3. 如果有另一个客户端同时在读取该文档，是否会看到半更新状态？

这些问题都很棘手，如果数据库不提供任何保证，用户侧得写很多的错误处理逻辑。因此，**一般的数据库哪怕不支持完整的事务，也会提供针对单个对象的原子性和隔离性**。比如，可以使用写前日志来保证原子性，使用锁来保证隔离性。

其他一些数据库，也会提供更复杂的原子支持，如原子的自增操作。另一种**更泛化的原子性保证是提供单个对象上的 CAS 操作**，允许用户原子的执行针对单个对象的 read-modify-write 操作。当然，如果咬文嚼字一下，**原子自增**（atomic increment），在 ACID 中应该是属于隔离性（ Isolation ）的范畴，此处的原子自增其实是多线程的概念。

有的 NoSQL 数据库将上述支持宣传为”轻量级事务“，甚而 PR 成 ”ACID”。但这是极其不负责任的，通常来说，事务是一种将针对**多个对象**的**多个操作**封装为一个执行单元的机制。

### 2.2 界定对多对象事务的需求

跨机器的多对象事务难以正确实现，且非常损失性能（可能在一个数量级），因此数据库大多将是否打开事务设置为一个开关。

因此，用户在数据库选型时，有必要审视一下是否真的需要多对象事务，普通的键值对模型和单对象事务是否能够满足需求。一些情况下，这是足够的，但更多的场景仍然需要协同操作多个对象：

+ 在关系型数据库中，一些表通常会有一些外键。在更新时，需要进行同步更新。
+ 在文档型数据库中，相关的数据通常会放到一个文档中，缺少 Join 支持的文档型数据库往往会滋生反规范化的数据，当更新这种数据时，就需要一次更新多个文档，这就涉及到多对象操作的问题了。
+ 在支持次级索引的数据库中，数据和对应的多个索引需要进行同步更新。

> 非规范化的数据其实就是出现某些数据被冗余存储了，这是便产生了同步更新的需求。

如果没针对多对象事务，上述保证只能在应用侧实现，徒增复杂度，而且容易出错。

### 2.3 故障和终止

事务的一个重要特点是在执行到一半时，可以安全的终止并重试。事务的**设计哲学是**：当出现违反原子性、隔离性和持久性的危险时，就**丢弃而非保留**已经发生的修改。

但，另一些场景，如多副本中的无主模型，就采用了“**尽力而为**”的模型，即尽可能的保证完成任务，如不能完成，也不会回滚已经发生的修改。因此，**应用侧需要处理这种半完成的状态**。

> 事务的“重试中止”虽然是一个简单有效的错误处理机制，但并不完美：
>
> 1. 事务已经被成功提交，但返回给用户时出错。用户如果简单重试，就会使该事务中的操作执行两次，从而造成数据冗余，除非用户在应用代码侧进行去重（如多次执行这些语句，效果一样）。
> 2. 由于系统负载过高，而造成事务执行失败。如果无脑重试，会进一步加重系统负担。此时可以使用指数后退方式重试，并且限制最大重试次数。
> 3. 一些临时错误，如死锁、异常、网络抖动和故障切换时，重试才有效；对于一些永久故障，重试是没有意义的。
> 4. 某事务在数据库之外如有副作用，重试事务时，会造成副作用的多次发生。如果某个事务的副作用是发送邮件，则肯定不希望事务每次重试时都发送一次电子邮件。如果想进行多个系统间的协同，可以考虑两阶段提交。
> 5. 如果客户端在写入数据时故障，则所有该客户端正在执行的事务所涉及的数据修改都会丢失。

## 3. 几种弱隔离性级别

如果两个事务修改的数据没有交集，则可以安全的并发；否则，就会出现竞态条件。一旦出现并发 BUG，通常很难复现和修复。单客户端的并发已经足够麻烦，多客户端并发访问更加剧了并发问题。

数据库试图通过**事务隔离**（transaction isolation）来给用户提供一种隔离保证，从而降低应用侧的编程复杂度。最强的隔离性，**可串行化**（Serializability），可以对用户提供一种保证：任意时刻，可以认为只有一个事务在运行。可串行化的隔离严重影响性能，因此实践中往往都是放松要求，采用弱隔离级别。

::: note 总览
初学者对几种隔离级别的递进关系通常难以理解，往往是找不到一个合适的角度。我的经验是，从实现的角度对几种隔离级别进行理解，会简单一些。如 ANSI SQL 定义的四种隔离级别：读未提交、读已提交、可重复读和可串行化，可以从使用锁实现事务的角度来理解。

+ 最强的隔离性——可串行化，可以理解为全局一把大排它锁，每个事务在启动时获取，在提交、回滚或终止时释放，但无疑这种隔离级别性能最差.。
+ 而其他几种弱隔离级别，可以理解为是为了提高性能，缩小了加锁的粒度、减小了加锁的时间，从而牺牲部分一致性换取性能。
	+ 从上锁的强弱考虑，我们有互斥锁（Mutex Lock，又称写锁）和共享锁（Shared Lock，又称读锁）；
	+ 从上锁的长短来考虑，我们有长时锁（Long Period Lock，事务开始获取锁，到事务结束时释放）和短时锁（Short Period Lock，访问时获取，用完旋即释放）；
	+ 从上锁的粗细来考虑，我们有对象锁（Row Lock，锁一行）和谓词锁（Predicate Lock，锁一个范围）。

但这没有覆盖到到另一个常见的隔离级别——**快照隔离**（Snapshot Isolation），因为它引出了另一种实现族——MVCC。由于属于不同的实现，快照隔离和可重复读在隔离级别的光谱上属于一个偏序关系，不能说谁强于谁。
:::

接下来几个小节，将依次考察读已提交、快照隔离、可重复读三个隔离级别。以及隔离级别不够导致的几种现象——更新丢失（Lost Update）、写偏序（Write Skew）和幻读（Phantom Read）。

### 3.1 读已提交

<mark>读已提交</mark>（**RC**，Read Committed）是最基本的事务隔离级别，它提供了如下两个保证：

1. 读数据库时，只能看到已成功提交的数据（防止“脏读”）
2. 写数据库时，只能覆盖已成功提交的数据（防止“脏写”）

#### 3.1.1 无脏读

<mark>脏读</mark>（dirty reads）：如果一个事务 A 能够读到另一个未提交事务 B 的中间状态，则称有脏读。

下图展示了一个没有脏读的示例：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230130192513943.png" alt="image-20230130192513943" style="zoom: 67%;" /></center>

+ 在上图中，在 User 1 的事务提交前，User 2 看到的 x 值一直是 2 。

当有以下需求时，需要防止脏读：

+ 一个事务如果更新多个对象，另外的一个事务就可能看到中间状态，产生“脏读”
+ 如果事务终止并回滚，允许脏读的系统可能会让其他的事务看到被回滚的数据

#### 3.1.2 无脏写

<mark>脏写</mark>（dirty writes）：如果一个事务 A 的中间状态被另一个事务 B 给修改了，那称有脏写。

下面是一个脏写的示例，在一个售车网站中，两个人试图购买同一辆车，而购车需要两步操作：更新买主和开发票，那就有可能 Alice 先更新了买主，还没开完发票就被 Bob 又给更新买主了：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230130193339284.png" alt="image-20230130193339284" style="zoom:67%;" /></center>

**用途和局限**：当多个事务更新同一个对象时，防止脏写会防止带来非预期的结果。但防止脏写并不能防止图 7-1 所示的计数器的竞态条件，那是一种更新丢失的问题，两个事务都是读写的已提交的数据，但仍无法避免写入丢失的问题。

#### 3.1.3 “读已提交”的实现

+ **防止脏写的方法**：最简单常见的是使用**行锁**，即针对单条数据的长时写锁（Long Period Write Lock）。当事务想要修改某行数据时，必须先获得这行的行锁，事务提交时释放。
+ **防止脏读的方法**：
  + 一种方法可以使用**读锁**，读之前必须先申请锁，读完释放，读锁可以并发，但与写锁互斥。【性能差，可能“饿死”】
  + 一种方法是数据库维护旧值和当前持锁事务将要设置的新值两个版本，在持有写锁的事务提交之前，数据库对外只返回旧值。【常用手段】

### 3.2 快照隔离

