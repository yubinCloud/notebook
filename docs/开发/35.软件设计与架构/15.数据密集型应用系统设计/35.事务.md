---
title: 事务
date: 2023-01-29 17:04:59
permalink: /pages/DDIA/note/transaction/
categories:
  - 开发
  - 软件设计与架构
  - 数据密集型应用系统设计
tags:
  - 
---

在分布式数据系统中，任何问题都有可能发生：

1. 系统侧：数据库系统和硬件系统任何时间都有可能发生故障
2. 应用侧：使用数据库的应用程序任何时刻都有可能故障。
3. 网络侧：应用程序和数据库间，数据库的多个节点间，随时都有可能断开连接。
4. 多个客户端：并发写入时，可能会有竞态条件和相互覆盖。
5. 半读：一个客户端可能会读到部分更新的数据库。

复杂度不会凭空消失，只会发生转移。如果数据库对这些故障不做任何处理，应用层就需要处理上述所有相关问题，会极大增加应用侧编程复杂度。事务就是数据库为了解决类似的问题，所提供的一种保证，**以简化应用层的编程模型**。

<mark>事务</mark>将应用程序的多个读、写操作捆绑在一起成为一个逻辑操作单元，并提供一种保证，这一组操作要么全部成功（ **commit**，应用到数据库里），要么全部失败（被动 **abort**，或者主动 **rollback**），而不会存在只执行了一半的中间状态。此外，如果多个客户端的事务并发执行，会涉及到隔离性的问题，一般来说，数据库允许用户在隔离级别和性能之间做选择。

事务也可以从**时间**和**空间**两个角度来理解：

+ 从生命周期（**时间**）来讲：事务要保证一组操作的整体性
+ 从并发控制（**空间**）来讲：事务要做好多个事务间的并发控制

有了这种语义上的保证，用户在发现事务失败后，可以放心的进行重试，直到成功，就可以确定事务中的所有操作都生效了。但任何便利性都是有代价的，<u>事务便是在一定程度上牺牲了性能和可用性</u>。

几乎所有的关系型数据库和一些非关系型都支持事务处理，然而到了 21 世纪末，NoSQL 开始兴起，它们的目标是通过提供新的数据模型以及内置的复制和分区来改进传统的关系模型，然而事务却成为了这场变革的受害者：<u>很多新一代的数据库完全放弃了事务支持，或者将其重新定义，即替换为比以前弱得多的保证</u>。

> 很多数据库不再支持完整的事务，而是偷换概念，说成“xxx事务”，这其实是换个名词来骗外行。

有人认为大规模系统为了性能和高可用将不得不牺牲事务的支持，也有人坚持事务是保证高价值数据和关键应用的必备功能。其实这两个观点都有点夸大其词，应该根据实际情况来做 trade-off。

本章首先讨论事务的基本概念，然后针对隔离级别（并发控制）做了详细探讨，包括读已提交、快照隔离和可串行化。事务保证和是否分布式在概念上相对正交，但在实现上，分布式系统中事务的实现难度要大的多。

## 1. ACID 的含义

Theo Härder 和 Andreas Reuter 于 1983 提出的 ACID，它最初是为了数据库中的容错保证给出一种相对精确的描述，但实际上各家数据库的实现并不相同，现在的 ACID 更像是一个市场营销术语。

不符合 ACID 标准的系统有时被冠以“BASE”，是指基本可用性（**B**asically Available）、软状态（**S**oft state）和最终一致性（**E**ventual consistency）

下面，将逐一探究 Atomicity、Consistency、Isolation 和 Durability 的精确含义，以此来对事务所要做出的保证建立一个基本的认识。

### 1.1 原子性（Atomicity）

> 一句话：要么全成功，要么全失败

<mark>原子性</mark>：在单个客户端/线程内，一组操作可以被原子的执行，如果执行到一半失败，已经执行的操作可以被全部回滚。

因此，ACID 中原子性所提供的保证是：**在发生错误时，会回滚该事务所有已经写入的变更**。

这个保证很重要，否则用户在执行到一半出错时，很难知道哪些操作已经生效、哪些操作尚未生效。有了此保证，用户如果发现出错，可以安全的进行重试。

> 注意与并发编程中的“原子性”相区分，在并发编程中，原子性通常和可见性关联，即一个线程无法看到另一个线程执行的原子操作的中间结果。但 <u>ACID 的原子性并不关心多个操作的并发性</u>，它没有描述多个线程试图访问相同的数据会发生什么情况。

### 1.2 一致性（Consistency）

<mark>一致性</mark>：是指对某些**不变性**（invariants）的维持，所谓不变性，即某些约束条件。如，在银行账户中，在任何时刻，账户余额须等于收入减去支出。

不同于 ACID 中其他性质，**一致性是需要应用侧和数据库侧共同维护的**：

1. 应用侧需要写入满足应用侧视角约束要求的数据。
2. 数据库侧需要保证多次写入前后，尤其是遇到问题时，维持该约束。

因此，一致性可以表述为，应用侧依赖数据库提供的原子性、隔离性来实现一致性。可见，一致性并非数据库事务本身的一种特性，更多的是应用侧的一种属性。据此，乔・海勒斯坦（Joe Hellerstein）认为，在 Härder 与 Reuter 的论文中，“ACID 中的 C 是 用来凑数的”。

> 在不同的上下文中，“一致性”这个词有着不同的含义：
>
> + 多副本：之前讨论了多副本一致性和最终一致性的问题
> + 一致性哈希：一种分区和调度的方式
> + CAP 定理：一致性指的是线性一致性，是多副本间一致性的一种特例
> + ACID：数据库在应用程序的视角处于某种”一致性的状态“

### 1.3 隔离性（Isolation）

多个客户端并发访问数据库时，如果访问的数据没有交集，是可以随意并发的。但如果有交集，则会产生**并发问题**，或称**竞态条件**（race condition）。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230129174731936.png" alt="image-20230129174731936" style="zoom: 67%;" /></center>

设有一个计数器，且数据库没有内置原子的自增操作，有两个用户，各自读取当前值，加 1 后写回。如图，期望计数器由 42 变为 44，但由于并发问题，最终变成了 43 。

<mark>隔离性</mark>是指，每个事务的执行是互相隔离的，每个事务都可以认为自己是系统中唯一正在运行的事务，因此传统上，教科书将事务隔离形式称为：**可串行化（Serializability）**。

但在实践中，由于性能问题很少使用串行化隔离。实际上隔离性强弱类似于一个光谱，数据库系统提供商一般会实现其中几个，用户可以根据业务情况在隔离性和性能间进行选择。

> 隔离性是最重要、最难理解的一个概念，之后会讨论除了可串行化之外的几种弱隔离级别。

### 1.4 持久性（Durability）

<mark>持久性</mark>是一种保证：事务一旦提交，即使服务器宕机重启、甚至发生硬件故障，已写入的数据就不会丢失。

+ 对于单节点数据库，持久性意味着数据已被写入非易失性存储设备，这可能是以 page 或 WAL 的形式写入的
+ 对于多副本数据库，持久性意味着数据已成功复制到多个节点，因此为了实现这种保证，数据库必须等到复制完成之后才能报告事务成功提交

但，**持久性都只能做到某种程度的保证，而非绝对保证**，比如：

1. 对于单机，可以容忍宕机。但磁盘坏了就完犊子。
2. 对于多机，可以容忍少数副本损坏，但是多数副本完后也没辙。

所以我们也往往分“物理”和“抽象”两种视角来审视一个系统，这里所说的持久性更像是一个抽象层面的保证。

在实践中，要通过多种手段，比如强制刷盘、校验码、异地复制、定时备份等多种手段来保证数据的持久性，但也只能做到大概率的保证（比如五个九），而非绝对保证。现实就是没有哪一项技术可以提供绝对的持久性保证，这些都是降低风险的手段。

### 1.5 Summary

|         ACID          | 描述                                 |
| :-------------------: | ------------------------------------ |
|  原子性（Atomicity）  | 一组操作，要么全成功，要么全失败     |
| 一致性（Consistency） | 对不变性的维持（用户 -50，商家 +50） |
|  隔离性（Isolation）  | 多个事务的执行相互隔离               |
| 持久性（Durability）  | 一旦提交，永不丢失                   |

