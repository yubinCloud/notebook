---
title: Java 代码的运行和 Java 的基本类型
date: 2023-07-05 15:37:53
permalink: /pages/java/jvm/geektime/disassembling/run-java/
categories:
  - 开发
  - Java开发
  - JVM
  - 专栏：深入拆解 Java 虚拟机
tags:
  - 
---

> 参考：
>
> - [01 Java代码是怎么运行的？| 极客时间](https://time.geekbang.org/column/intro/100010301)

## 1. Java 代码是怎么运行的

### 1.1 为什么 Java 要在虚拟机里运行？

在 Java 代码到底层硬件的过程中，需要将其转换成 Java 字节码并运行到 JVM 中。JVM 可以由硬件实现，也可以软件实现，从而实现”一次编写，到处运行“。

虚拟机的另外一个好处是它带来了一个托管环境（Managed Runtime），这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。其中最广为人知的当属自动内存管理与垃圾回收，这部分内容甚至催生了一波垃圾回收调优的业务。除此之外，托管环境还提供了诸如数组越界、动态类型、安全权限等等的动态检测，使我们免于书写这些无关业务逻辑的代码。

### 1.2 Java 虚拟机具体是怎样运行 Java 字节码的？

这里以标准 JDK 中的 HotSpot 虚拟机为例，从虚拟机以及底层硬件两个角度，给你讲一讲 Java 虚拟机具体是怎么运行 Java 字节码的。

#### 1.2.1 从虚拟机的视角来看

从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于**方法区**（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。

> 如果你熟悉 X86 的话，你会发现这和段式内存管理中的代码段类似。

Java 虚拟机也会将内存划分出堆和栈来存储运行时的数据，并将栈细分为面向 Java 方法的 **Java 方法栈**、面向本地方法（用 C++ 写的 native 方法）的**本地方法栈**、以及存放各个线程执行位置的 **PC 寄存器**。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230705154825.png" alt="20230705154825" style="zoom:75%;" /></center>

在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。

当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。

#### 1.2.2 从硬件视角来看

从硬件视角来看，Java 字节码无法直接执行。因此，**Java 虚拟机需要将字节码翻译成机器码**。

在 HotSpot 里面，上述翻译过程有两种形式：

1. 第一种是**解释执行**，即逐条将字节码翻译成机器码并执行；
2. 第二种是**即时编译**（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230705155008.png" alt="20230705155008" style="zoom:75%;" /></center>

前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。

### 1.3 Java 虚拟机的运行效率究竟是怎么样的？

HotSpot 采用了多种技术来提升启动性能以及峰值性能，刚刚提到的****即时编译便是其中最重要的技术之一**。

即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源：

- 对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；
- 另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。

**理论上讲，即时编译后的 Java 程序的执行效率，是可能超过 C++ 程序的**。这是因为与静态编译相比，即时编译拥有程序的运行时信息，并且能够根据这个信息做出相应的优化。举个例子，我们知道虚方法是用来实现面向对象语言多态性的。对于一个虚方法调用，尽管它有很多个目标方法，但在实际运行过程中它可能只调用其中的一个。这个信息便可以被即时编译器所利用，来规避虚方法调用的开销，从而达到比静态编译的 C++ 程序更高的性能。

为了满足不同用户场景的需要，**HotSpot 内置了多个即时编译器**：C1、C2 和 Graal。

> Graal 是 Java 10 正式引入的实验性即时编译器，在专栏的第四部分我会详细介绍，这里暂不做讨论。

之所以引入多个即时编译器，是为了在编译时间和生成代码的执行效率之间进行取舍：

- C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。
- C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。

从 Java 7 开始，HotSpot 默认采用**分层编译**的方式：**热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译**。为了不干扰应用的正常运行，HotSpot 的即时编译是放在额外的编译线程中进行的。HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器。

在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。

### 1.4 小结

这一章主要介绍了 Java 代码为何在虚拟机中运行，以及如何在虚拟机中运行。

- 之所以要在虚拟机中运行，是因为它提供了可移植性和代码托管的环境；
- Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。
- 为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。
  - 它解释执行 Java 字节码，并将热点代码以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。
  - HotSpot 装载了多个不同的即时编译器进行分层编译。

## 2. Java 的基本类型

在古老的 SmallTalk 语言中，所有的值都是对象，但 Java 引进了 8 个基本类型来支持数值计算，来兼顾工程中执行效率和内存使用。今天就来了解一下 Java 基本类型在 JVM 中的实现。

### 2.1 Java 虚拟机的 boolean 类型

在 Java 语言规范中，boolean 类型的值只有两种可能，它们分别用符号 `true` 和 `false` 来表示。 但在 在 Java 虚拟机规范中，**boolean 类型则被映射成 int 类型**。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。

Java 虚拟机规范同时也要求 Java 编译器遵守这个编码规则，并且用整数相关的字节码来实现逻辑运算，以及基于 boolean 类型的条件跳转。这样一来，在编译而成的 class 文件中，除了字段和传入参数外，基本看不出 boolean 类型的痕迹了。

> 如果你使用 AsmTools 或 ASM 等工具来修改 class 字节码，发现是可以将一个 boolean 变量的值赋予 2 等数值的。

### 2.2 Java 的基本类型

除了上面提到的 boolean 类型外，Java 的基本类型还包括整数类型 byte、short、char、int 和 long，以及浮点类型 float 和 double。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230706105127.png" alt="20230706105127" style="zoom:75%;" /></center>

> 尽管他们的默认值看起来不一样，但在内存中都是 0。

在这些基本类型中，boolean 和 char 是唯二的无符号类型。在不考虑违反规范的情况下，boolean 类型的取值范围是 0 或者 1。char 类型的取值范围则是 [0, 65535]。**通常我们可以认定 char 类型的值为非负数**。这种特性十分有用，比如说作为数组索引等。

> 这些类型的局部变量都有可能存储超出它们取值范围的数值，而且，这些超出取值范围的数值同样会带来一些麻烦。比如说，声明为 char 类型的局部变量实际上有可能为负数。当然，在正常使用 Java 编译器的情况下，生成的字节码会遵守 Java 虚拟机规范对编译器的约束，因此你无须过分担心局部变量会超出它们的取值范围。

Java 的浮点类型采用 IEEE 754 浮点数格式。以 float 为例，浮点类型通常有两个 0，+0.0F 以及 -0.0F。前者在 Java 里是 0，后者是符号位为 1、其他位均为 0 的浮点数，在内存中等同于十六进制整数 0x8000000（即 -0.0F 可通过 Float.intBitsToFloat(0x8000000) 求得）。尽管它们的内存数值不同，但是在 Java 中 `+0.0F == -0.0F` 会返回真。

在有了 +0.0F 和 -0.0F 这两个定义后，我们便可以定义浮点数中的正无穷及负无穷。**正无穷**就是任意正浮点数（不包括 +0.0F）除以 +0.0F 得到的值，而**负无穷**是任意正浮点数除以 -0.0F 得到的值。**在 Java 中，正无穷和负无穷是有确切的值**，在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。

你也许会好奇，既然整数 0x7F800000 等同于正无穷，那么 0x7F800001 又对应什么浮点数呢？这个数字对应的浮点数是 **NaN**（Not-a-Number）。不仅如此，[0x7F800001, 0x7FFFFFFF] 和 [0xFF800001, 0xFFFFFFFF] 对应的都是 NaN。当然，一般我们计算得出的 NaN，比如说通过 +0.0F/+0.0F，在内存中应为 0x7FC00000。这个数值，我们称之为**标准的 NaN**，而其他的我们称之为**不标准的 NaN**。

**NaN 有一个有趣的特性：除了“!=”始终返回 true 之外，所有其他比较结果都会返回 false**。

> 举例来说，“NaN<1.0F”返回 false，而“NaN>=1.0F”同样返回 false。对于任意浮点数 f，不管它是 0 还是 NaN，“f!=NaN”始终会返回 true，而“f==NaN”始终会返回 false。

因此，我们在程序里做浮点数比较的时候，需要考虑上述特性。在本专栏的第二部分，我会介绍这个特性给向量化比较带来什么麻烦。

### 2.3 Java 基本类型的大小

#### 2.3.1 在 JVM 中的存储

前面说过，Java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便理解，这里我只讨论供解释器使用的**解释栈帧**（interpreted frame）。这种栈帧有两个主要的组成部分，分别是局部变量区，以及字节码的操作数栈。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还包含实例方法的“this 指针”以及方法所接收的参数。

在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。**除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元**。也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。

当然，**这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上**。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。

因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”

boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，**boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现**。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。

#### 2.3.2 在 JVM 中的加载

讲完了存储，现在我来讲讲加载。**Java 虚拟机的算数运算几乎全部依赖于操作数栈**。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。

对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。

对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。

### 2.4 总结

这一章主要介绍了 Java 里的基本类型。

- boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。
- 除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。
- 除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。
