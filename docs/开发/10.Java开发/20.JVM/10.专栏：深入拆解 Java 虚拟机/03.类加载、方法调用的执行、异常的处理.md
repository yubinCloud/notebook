---
title: 类加载、方法调用的执行、异常的处理
date: 2023-07-06 11:14:00
permalink: /pages/java/jvm/geektime/disassembling/class-load/
categories:
  - 开发
  - Java开发
  - JVM
  - 专栏：深入拆解 Java 虚拟机
tags:
  - 
---

## 1.Java 虚拟机是如何加载 Java 类的？

从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。那么，是否所有的 Java 类都需要经过这几步呢？

Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。其中基本类型是预先定义好的，**引用类型则进一步细分为四种：类、接口、数组类和泛型参数**。由于泛型参数会在编译过程中被擦除，因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。

**字节流**最常见的形式就是 Java 编译器生成的 class 文件，除此之外还可以在程序内部直接生成，或从网络中获取字节流。这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。后面会统一用“类”来统称他们。

无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。接下来，我会详细给你介绍一下每个步骤具体都在干些什么。

### 1.1 加载

<mark>加载</mark>，是指查找字节流，并且据此创建类的过程。

- 对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。
- 对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。

类加载器有着共同的祖师爷：<mark>启动类加载器</mark>（**bootstrap class loader**）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。

**除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类**，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。

在 Java 虚拟机中，类加载有个潜规则：<mark>双亲委派模型</mark>，**每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载**。

在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。

<mark>扩展类加载器</mark>，它的父类加载器是启动类加载器，负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。

<mark>应用类加载器</mark>，它的父类加载器则是扩展类加载器，负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。

Java 9 引入了模块系统，并且略微更改了上述的类加载器。**扩展类加载器被改名为平台类加载器**（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。

除了由 Java 核心类库提供的类加载器外，**我们还可以加入自定义的类加载器，来实现特殊的加载方式**。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。

除了加载功能之外，类加载器还提供了命名空间的作用。在 Java 虚拟机中，**类的唯一性是由类加载器实例以及类的全名一同确定的**。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。

### 1.2 链接

<mark>链接</mark>，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。

#### 1.2.1 验证阶段

**验证阶段的目的，在于确保被加载类能够满足** Java 虚拟机的约束条件**。通常而言，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。这部分内容会在后面讲解字节码注入时再详细介绍。

#### 1.2.2 准备阶段

**准备阶段的目的，则是为被加载类的静态字段分配内存**。而 Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。

除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。

#### 1.2.3 解析阶段

在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。

**解析阶段的目的，正是将这些符号引用解析成为实际引用**。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

> 如果将这段话放在盖房子的语境下，那么符号引用就好比“Tony 的房子”这种说法，不管它存在不存在，我们都可以用这种说法来指代 Tony 的房子。实际引用则好比实际的通讯地址，如果我们想要与 Tony 通信，则需要启动盖房子的过程。解析的任务就将将“Tony的房子”转换成房子的实际通讯地址。

Java 虚拟机规范并没有要求在链接过程中完成解析。**它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析**。

### 1.3 初始化

在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。

- 如果直接赋值的静态字段被 final 所修饰（即 `static final`），并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成<mark>常量值</mark>（ConstantValue），其初始化直接由 Java 虚拟机完成。
- 除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 `<clinit>`。

类加载的最后一步是<mark>初始化</mark>，**便是为标记为常量值的字段赋值，以及执行 `<clinit>` 方法的过程**。Java 虚拟机会通过加锁来确保类的 `<clinit>` 方法仅被执行一次。

只有当初始化完成之后，类才正式成为可执行的状态。

那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

下面是一个单例模式中单例延迟初始化的例子，只有当调用 Singleton.getInstance 时，程序才会访问 `LazyHolder.INSTANCE`，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。

```java
public class Singleton {
    private Singleton() {}

    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。

### 1.4 总结

这一大章介绍了 Java 虚拟机将字节流转化为 Java 的过程，这个过程可分为加载、链接以及初始化三大步骤：

- 加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。
- 链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。
- 初始化，则是为标记为常量值的字段赋值，以及执行 `<clinit>` 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。

## 2. JVM 是如何执行方法调用的？（上）

这一章主要来看一下 Java 虚拟机是怎么识别目标方法的。

### 2.1 重载与重写

#### 2.1.1 重载

同一个类中定义名字相同、参数类型不同的方法，叫做<mark>重载</mark>。**重载的方法在编译过程中即可完成识别**，具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。

> 比如 `Human w = new Man()` 中，Human 是 w 的**静态类型**，Man 是 w 的**动态类型**。

除了同一个类中的方法，**重载也可以作用于这个类所继承而来的方法**。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

#### 2.1.2 重写

如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？

- 如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。
- 如果这两个方法都不是静态的，且都不是私有的，那么子类的方法<mark>重写</mark>了父类中的方法。

方法重写就是多态最重要的一种体现形式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

### 2.2 JVM 的静态绑定和动态绑定

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。这里的方法描述符是由方法的参数类型以及返回类型所构成。JVM 与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

> 简单来说，JVM 会把”方法的返回类型“也作为方法唯一性的其中因素之一，而 Java 不关心返回类型作为唯一性。

由于对重载方法的区分在编译阶段已经完成，因此重载也被称为**静态绑定**（static binding）。对应的，重写则被称为**动态绑定**。

这个说法在 Java 虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。确切地说，Java 虚拟机中的**静态绑定指的是在解析时便能够直接识别目标方法的情况**，而**动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况**。

具体来说，Java 字节码中与调用相关的指令共有五种：

1. invokestatic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。

### 2.3 调用指令的符号引用

在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。符号引用存储在 class 文件的常量池之中。**根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用**。

之前说过，在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。

在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。下面看看如何将符号引用转换为实际引用。

#### 2.3.1 非接口符号引用的转换

对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找：

1. 在 C 中查找符合名字及描述符的方法。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。

#### 2.3.2 接口符号引用的转换

对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找：

1. 在 I 中查找符合名字及描述符的方法。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。

### 2.4 总结

这一章主要介绍了 Java 以及 Java 虚拟机是如何识别目标方法的。

- 在 Java 中，方法存在重载以及重写的概念，重载指的是方法名相同而参数类型不相同的方法之间的关系，重写指的是方法名相同并且参数类型也相同的方法之间的关系。
- Java 虚拟机识别方法的方式略有不同，除了方法名和参数类型之外，它还会考虑返回类型。
- 在 Java 虚拟机中，静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。
- 在 class 文件中，Java 编译器会用符号引用指代目标方法。在执行调用指令前，它所附带的符号引用需要被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用为目标方法的指针。对于需要动态绑定的方法调用而言，实际引用为辅助动态绑定的信息。

## 3. JVM 是如何执行方法调用的？（下）

这一节主要聊一聊 JVM 中虚方法调用的具体实现。

首先看一下模拟出国边检的小例子：

```java
abstract class Passenger {
    abstract void passThroughImmigration();
    
    @Override
    public String toString() { ... }
}

class ForeignerPassenger extends Passenger {
    @Override
    void passThroughImmigration() { /* 进外国人通道 */ }
}

class ChinesePassenger extends Passenger {
    @Override
    void passThroughImmigration() { /* 进中国人通道 */ }
    
    void visitDutyFreeShops() { /* 逛免税店 */ }
}
 
Passenger passenger = ...
passenger.passThroughImmigration();
```

这里我定义了一个抽象类，叫做 Passenger，这个类中有一个名为 passThroughImmigration 的抽象方法，以及重写自 Object 类的 toString 方法。

然后，我将 Passenger 粗暴地分为两种：ChinesePassenger 和 ForeignerPassenger。

两个类分别实现了 passThroughImmigration 这个方法，具体来说，就是中国人走中国人通道，外国人走外国人通道。由于咱们储蓄较多，所以我在 ChinesePassenger 这个类中，还特意添加了一个叫做 visitDutyFreeShops 的方法。

那么在实际运行过程中，Java 虚拟机是如何高效地确定每个 Passenger 实例应该去哪条通道的呢？我们一起来看一下。

### 3.1 虚方法调用

Java 里所有非私有实例方法调用都会被编译成 **invokevirtual** 指令，而接口方法调用都会被编译成 **invokeinterface** 指令。这两种指令，均属于 Java 虚拟机中的<mark>虚方法调用</mark>。

在绝大多数情况下，Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为动态绑定。那么，相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。

在 Java 虚拟机中，静态绑定包括用于调用静态方法的 invokestatic 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 invokespecial 指令。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。

Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。那么方法表具体是怎样实现的呢？

### 3.2 方法表

之前提到说，在类加载的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。

这个数据结构，便是 Java 虚拟机实现动态绑定的关键所在。下面我将以 invokevirtual 所使用的<mark>虚方法表</mark>（virtual method table，vtable）为例介绍方法表的用法。invokeinterface 所使用的接口方法表（interface method table，itable）稍微复杂些，但是原理其实是类似的。

**方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法**。这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：

- 其一，子类方法表中包含父类方法表中的所有方法；
- 其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。**对于动态绑定的方法调用而言，实际引用则是方法表的索引值**（实际上并不仅是索引值）。

在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230706173827.png" alt="20230706173827" style="zoom:75%;" /></center>

在我们的例子中，Passenger 类的方法表包括两个方法：

- `toString`
- `passThroughImmigration`

它们分别对应 0 号和 1 号。之所以方法表调换了 toString 方法和 passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与 Object 类中同名方法的索引值一致。为了保持简洁，这里我就不考虑 Object 类中的其他方法。

ForeignerPassenger 的方法表同样有两行。其中，0 号方法指向继承而来的 Passenger 类的 toString 方法。1 号方法则指向自己重写的 passThroughImmigration 方法。

ChinesePassenger 的方法表则包括三个方法，除了继承而来的 Passenger 类的 toString 方法，自己重写的 passThroughImmigration 方法之外，还包括独有的 visitDutyFreeShops 方法。

可以看到这个**动态绑定的过程与静态绑定相比，仅仅多出几个内存解引用操作**：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。**相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计**。

那么我们是否可以认为虚方法调用对性能没有太大影响呢？其实是不能的，上述优化的效果看上去十分美好，但实际上仅存在于解释执行中，或者即时编译代码的最坏情况中。这是因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）。下面我便来介绍第一种内联缓存。

### 3.3 内联缓存

<mark>内联缓存</mark>是一种加快动态绑定的优化技术。**它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法**。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。

> 在我们的例子中，这相当于导航员记住了上一个出境乘客的国籍和对应的通道，例如中国人，走了左边通道出境。那么下一个乘客想要出境的时候，导航员会先问是不是中国人，是的话就走左边通道。如果不是的话，只好拿出外国人的小册子，翻到第 1 页，再告知查询结果：右边。

在针对多态的优化手段中，我们通常会提及以下三个术语：

1. **单态**（monomorphic）指的是仅有一种状态的情况。
2. **多态**（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
3. **超多态**（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。

对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。

多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。

一般来说，我们会将更加热门的动态类型放在前面。在实践中，大部分的虚方法调用均是单态的，也就是只有一种动态类型。**为了节省内存空间，Java 虚拟机只采用单态内联缓存**。

前面提到，当内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定。对于内联缓存中的内容，我们有两种选择。一是替换单态内联缓存中的纪录。这种做法就好比 CPU 中的数据缓存，它对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存。

因此，在最坏情况下，我们用两种不同类型的调用者，轮流执行该方法调用，那么每次进行方法调用都将替换内联缓存。也就是说，只有写缓存的额外开销，而没有用缓存的性能提升。

另外一种选择则是劣化为超多态状态。这也是 Java 虚拟机的具体实现方式。处于这种状态下的内联缓存，实际上放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法。与替换内联缓存纪录的做法相比，它牺牲了优化的机会，但是节省了写缓存的额外开销。

> 具体到我们的例子，如果来了一队乘客，其中外国人和中国人依次隔开，那么在重复使用的单态内联缓存中，导航员需要反复记住上个出境的乘客，而且记住的信息在处理下一乘客时又会被替换掉。因此，倒不如一直不记，以此来节省脑细胞。

虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，**任何方法调用除非被内联，否则都会有固定开销**。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。

> 对于极其简单的方法而言，比如说 getter/setter，这部分固定开销占据的 CPU 时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性，我们会在专栏的第二部分详细介绍方法内联的内容。

### 3.4 总结

