---
title: 类加载、方法调用的执行、异常的处理
date: 2023-07-06 11:14:00
permalink: /pages/java/jvm/geektime/disassembling/class-load/
categories:
  - 开发
  - Java开发
  - JVM
  - 专栏：深入拆解 Java 虚拟机
tags:
  - 
---

> 参考：
>
> - [03 Java 虚拟机是如何加载 Java 类的?| 极客时间](https://time.geekbang.org/column/intro/100010301)
> - [04 JVM 是如何执行方法调用的？（上）| 极客时间](https://time.geekbang.org/column/intro/100010301)
> - [05 JVM 是如何执行方法调用的？（下）| 极客时间](https://time.geekbang.org/column/intro/100010301)
> - [06 JVM是如何处理异常的？| 极客时间](https://time.geekbang.org/column/intro/100010301)

## 1.Java 虚拟机是如何加载 Java 类的？

从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。其中，链接过程中同样需要验证；而内存中的类没有经过初始化，同样不能使用。那么，是否所有的 Java 类都需要经过这几步呢？

Java 语言的类型可以分为两大类：基本类型（primitive types）和引用类型（reference types）。其中基本类型是预先定义好的，**引用类型则进一步细分为四种：类、接口、数组类和泛型参数**。由于泛型参数会在编译过程中被擦除，因此 Java 虚拟机实际上只有前三种。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。

**字节流**最常见的形式就是 Java 编译器生成的 class 文件，除此之外还可以在程序内部直接生成，或从网络中获取字节流。这些不同形式的字节流，都会被加载到 Java 虚拟机中，成为类或接口。后面会统一用“类”来统称他们。

无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。接下来，我会详细给你介绍一下每个步骤具体都在干些什么。

### 1.1 加载

<mark>加载</mark>，是指查找字节流，并且据此创建类的过程。

- 对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。
- 对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。

类加载器有着共同的祖师爷：<mark>启动类加载器</mark>（**bootstrap class loader**）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。

**除了启动类加载器之外，其他的类加载器都是 java.lang.ClassLoader 的子类**，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。

在 Java 虚拟机中，类加载有个潜规则：<mark>双亲委派模型</mark>，**每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载**。

在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。

<mark>扩展类加载器</mark>，它的父类加载器是启动类加载器，负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。

<mark>应用类加载器</mark>，它的父类加载器则是扩展类加载器，负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。

Java 9 引入了模块系统，并且略微更改了上述的类加载器。**扩展类加载器被改名为平台类加载器**（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。

除了由 Java 核心类库提供的类加载器外，**我们还可以加入自定义的类加载器，来实现特殊的加载方式**。举例来说，我们可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。

除了加载功能之外，类加载器还提供了命名空间的作用。在 Java 虚拟机中，**类的唯一性是由类加载器实例以及类的全名一同确定的**。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。

### 1.2 链接

<mark>链接</mark>，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。

#### 1.2.1 验证阶段

**验证阶段的目的，在于确保被加载类能够满足** Java 虚拟机的约束条件**。通常而言，Java 编译器生成的类文件必然满足 Java 虚拟机的约束条件。这部分内容会在后面讲解字节码注入时再详细介绍。

#### 1.2.2 准备阶段

**准备阶段的目的，则是为被加载类的静态字段分配内存**。而 Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。

除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如说用来实现虚方法的动态绑定的方法表。

#### 1.2.3 解析阶段

在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。

**解析阶段的目的，正是将这些符号引用解析成为实际引用**。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

> 如果将这段话放在盖房子的语境下，那么符号引用就好比“Tony 的房子”这种说法，不管它存在不存在，我们都可以用这种说法来指代 Tony 的房子。实际引用则好比实际的通讯地址，如果我们想要与 Tony 通信，则需要启动盖房子的过程。解析的任务就将将“Tony的房子”转换成房子的实际通讯地址。

Java 虚拟机规范并没有要求在链接过程中完成解析。**它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析**。

### 1.3 初始化

在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。

- 如果直接赋值的静态字段被 final 所修饰（即 `static final`），并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成<mark>常量值</mark>（ConstantValue），其初始化直接由 Java 虚拟机完成。
- 除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 `<clinit>`。

类加载的最后一步是<mark>初始化</mark>，**便是为标记为常量值的字段赋值，以及执行 `<clinit>` 方法的过程**。Java 虚拟机会通过加锁来确保类的 `<clinit>` 方法仅被执行一次。

只有当初始化完成之后，类才正式成为可执行的状态。

那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

下面是一个单例模式中单例延迟初始化的例子，只有当调用 Singleton.getInstance 时，程序才会访问 `LazyHolder.INSTANCE`，才会触发对 LazyHolder 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。

```java
public class Singleton {
    private Singleton() {}

    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

由于类初始化是线程安全的，并且仅被执行一次，因此程序可以确保多线程环境下有且仅有一个 Singleton 实例。

### 1.4 总结

这一大章介绍了 Java 虚拟机将字节流转化为 Java 的过程，这个过程可分为加载、链接以及初始化三大步骤：

- 加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。
- 链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。
- 初始化，则是为标记为常量值的字段赋值，以及执行 `<clinit>` 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。

## 2. JVM 是如何执行方法调用的？（上）

这一章主要来看一下 Java 虚拟机是怎么识别目标方法的。

### 2.1 重载与重写

#### 2.1.1 重载

同一个类中定义名字相同、参数类型不同的方法，叫做<mark>重载</mark>。**重载的方法在编译过程中即可完成识别**，具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。

> 比如 `Human w = new Man()` 中，Human 是 w 的**静态类型**，Man 是 w 的**动态类型**。

除了同一个类中的方法，**重载也可以作用于这个类所继承而来的方法**。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

#### 2.1.2 重写

如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？

- 如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。
- 如果这两个方法都不是静态的，且都不是私有的，那么子类的方法<mark>重写</mark>了父类中的方法。

方法重写就是多态最重要的一种体现形式：它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

### 2.2 JVM 的静态绑定和动态绑定

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。这里的方法描述符是由方法的参数类型以及返回类型所构成。JVM 与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

> 简单来说，JVM 会把”方法的返回类型“也作为方法唯一性的其中因素之一，而 Java 不关心返回类型作为唯一性。

由于对重载方法的区分在编译阶段已经完成，因此重载也被称为**静态绑定**（static binding）。对应的，重写则被称为**动态绑定**。

这个说法在 Java 虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。确切地说，Java 虚拟机中的**静态绑定指的是在解析时便能够直接识别目标方法的情况**，而**动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况**。

具体来说，Java 字节码中与调用相关的指令共有五种：

1. invokestatic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。

### 2.3 调用指令的符号引用

在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。符号引用存储在 class 文件的常量池之中。**根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用**。

之前说过，在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。

在执行使用了符号引用的字节码前，Java 虚拟机需要解析这些符号引用，并替换为实际引用。下面看看如何将符号引用转换为实际引用。

#### 2.3.1 非接口符号引用的转换

对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找：

1. 在 C 中查找符合名字及描述符的方法。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。

#### 2.3.2 接口符号引用的转换

对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找：

1. 在 I 中查找符合名字及描述符的方法。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。

### 2.4 总结

这一章主要介绍了 Java 以及 Java 虚拟机是如何识别目标方法的。

- 在 Java 中，方法存在重载以及重写的概念，重载指的是方法名相同而参数类型不相同的方法之间的关系，重写指的是方法名相同并且参数类型也相同的方法之间的关系。
- Java 虚拟机识别方法的方式略有不同，除了方法名和参数类型之外，它还会考虑返回类型。
- 在 Java 虚拟机中，静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。
- 在 class 文件中，Java 编译器会用符号引用指代目标方法。在执行调用指令前，它所附带的符号引用需要被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用为目标方法的指针。对于需要动态绑定的方法调用而言，实际引用为辅助动态绑定的信息。

## 3. JVM 是如何执行方法调用的？（下）

这一节主要聊一聊 JVM 中虚方法调用的具体实现。

首先看一下模拟出国边检的小例子：

```java
abstract class Passenger {
    abstract void passThroughImmigration();
    
    @Override
    public String toString() { ... }
}

class ForeignerPassenger extends Passenger {
    @Override
    void passThroughImmigration() { /* 进外国人通道 */ }
}

class ChinesePassenger extends Passenger {
    @Override
    void passThroughImmigration() { /* 进中国人通道 */ }
    
    void visitDutyFreeShops() { /* 逛免税店 */ }
}
 
Passenger passenger = ...
passenger.passThroughImmigration();
```

这里我定义了一个抽象类，叫做 Passenger，这个类中有一个名为 passThroughImmigration 的抽象方法，以及重写自 Object 类的 toString 方法。

然后，我将 Passenger 粗暴地分为两种：ChinesePassenger 和 ForeignerPassenger。

两个类分别实现了 passThroughImmigration 这个方法，具体来说，就是中国人走中国人通道，外国人走外国人通道。由于咱们储蓄较多，所以我在 ChinesePassenger 这个类中，还特意添加了一个叫做 visitDutyFreeShops 的方法。

那么在实际运行过程中，Java 虚拟机是如何高效地确定每个 Passenger 实例应该去哪条通道的呢？我们一起来看一下。

### 3.1 虚方法调用

Java 里所有非私有实例方法调用都会被编译成 **invokevirtual** 指令，而接口方法调用都会被编译成 **invokeinterface** 指令。这两种指令，均属于 Java 虚拟机中的<mark>虚方法调用</mark>。

在绝大多数情况下，Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为动态绑定。那么，相对于静态绑定的非虚方法调用来说，虚方法调用更加耗时。

在 Java 虚拟机中，静态绑定包括用于调用静态方法的 invokestatic 指令，和用于调用构造器、私有实例方法以及超类非私有实例方法的 invokespecial 指令。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用的目标方法。

Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。那么方法表具体是怎样实现的呢？

### 3.2 方法表

之前提到说，在类加载的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。

这个数据结构，便是 Java 虚拟机实现动态绑定的关键所在。下面我将以 invokevirtual 所使用的<mark>虚方法表</mark>（virtual method table，vtable）为例介绍方法表的用法。invokeinterface 所使用的接口方法表（interface method table，itable）稍微复杂些，但是原理其实是类似的。

**方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法**。这些方法可能是具体的、可执行的方法，也可能是没有相应字节码的抽象方法。方法表满足两个特质：

- 其一，子类方法表中包含父类方法表中的所有方法；
- 其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

我们知道，方法调用指令中的符号引用会在执行之前解析成实际引用。对于静态绑定的方法调用而言，实际引用将指向具体的目标方法。**对于动态绑定的方法调用而言，实际引用则是方法表的索引值**（实际上并不仅是索引值）。

在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230706173827.png" alt="20230706173827" style="zoom:75%;" /></center>

在我们的例子中，Passenger 类的方法表包括两个方法：

- `toString`
- `passThroughImmigration`

它们分别对应 0 号和 1 号。之所以方法表调换了 toString 方法和 passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与 Object 类中同名方法的索引值一致。为了保持简洁，这里我就不考虑 Object 类中的其他方法。

ForeignerPassenger 的方法表同样有两行。其中，0 号方法指向继承而来的 Passenger 类的 toString 方法。1 号方法则指向自己重写的 passThroughImmigration 方法。

ChinesePassenger 的方法表则包括三个方法，除了继承而来的 Passenger 类的 toString 方法，自己重写的 passThroughImmigration 方法之外，还包括独有的 visitDutyFreeShops 方法。

可以看到这个**动态绑定的过程与静态绑定相比，仅仅多出几个内存解引用操作**：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。**相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计**。

那么我们是否可以认为虚方法调用对性能没有太大影响呢？其实是不能的，上述优化的效果看上去十分美好，但实际上仅存在于解释执行中，或者即时编译代码的最坏情况中。这是因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）。下面我便来介绍第一种内联缓存。

### 3.3 内联缓存

<mark>内联缓存</mark>是一种加快动态绑定的优化技术。**它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法**。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。

> 在我们的例子中，这相当于导航员记住了上一个出境乘客的国籍和对应的通道，例如中国人，走了左边通道出境。那么下一个乘客想要出境的时候，导航员会先问是不是中国人，是的话就走左边通道。如果不是的话，只好拿出外国人的小册子，翻到第 1 页，再告知查询结果：右边。

在针对多态的优化手段中，我们通常会提及以下三个术语：

1. **单态**（monomorphic）指的是仅有一种状态的情况。
2. **多态**（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
3. **超多态**（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。

对于内联缓存来说，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存。单态内联缓存，顾名思义，便是只缓存了一种动态类型以及它所对应的目标方法。它的实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。

多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。

一般来说，我们会将更加热门的动态类型放在前面。在实践中，大部分的虚方法调用均是单态的，也就是只有一种动态类型。**为了节省内存空间，Java 虚拟机只采用单态内联缓存**。

前面提到，当内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定。对于内联缓存中的内容，我们有两种选择。一是替换单态内联缓存中的纪录。这种做法就好比 CPU 中的数据缓存，它对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存。

因此，在最坏情况下，我们用两种不同类型的调用者，轮流执行该方法调用，那么每次进行方法调用都将替换内联缓存。也就是说，只有写缓存的额外开销，而没有用缓存的性能提升。

另外一种选择则是劣化为超多态状态。这也是 Java 虚拟机的具体实现方式。处于这种状态下的内联缓存，实际上放弃了优化的机会。它将直接访问方法表，来动态绑定目标方法。与替换内联缓存纪录的做法相比，它牺牲了优化的机会，但是节省了写缓存的额外开销。

> 具体到我们的例子，如果来了一队乘客，其中外国人和中国人依次隔开，那么在重复使用的单态内联缓存中，导航员需要反复记住上个出境的乘客，而且记住的信息在处理下一乘客时又会被替换掉。因此，倒不如一直不记，以此来节省脑细胞。

虽然内联缓存附带内联二字，但是它并没有内联目标方法。这里需要明确的是，**任何方法调用除非被内联，否则都会有固定开销**。这些开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。

> 对于极其简单的方法而言，比如说 getter/setter，这部分固定开销占据的 CPU 时间甚至超过了方法本身。此外，在即时编译中，方法内联不仅仅能够消除方法调用的固定开销，而且还增加了进一步优化的可能性，我们会在专栏的第二部分详细介绍方法内联的内容。

### 3.4 总结

今天主要介绍了虚方法调用在 Java 虚拟机中的实现方式。

- 虚方法调用包括 invokevirtual 指令和 invokeinterface 指令。如果这两种指令所声明的目标方法被标记为 final，那么 Java 虚拟机会采用静态绑定。否则，Java 虚拟机将采用动态绑定，在运行过程中根据调用者的动态类型，来决定具体的目标方法。
- 动态绑定是通过方法表这一数据结构来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。
- 在解析虚方法调用时，Java 虚拟机会纪录下所声明的目标方法的索引值，并且在运行过程中根据这个索引值查找具体的目标方法。
- Java 虚拟机中的即时编译器会使用内联缓存来加速动态绑定。Java 虚拟机所采用的单态内联缓存将纪录调用者的动态类型，以及它所对应的目标方法。当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否则，Java 虚拟机将该内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。

## 4. JVM 是如何处理异常的？

异常处理的两大组成要素是**抛出异常**和**捕获异常**。这两大要素共同实现程序控制流的非正常转移。

Java 中抛出异常分为显式和隐式两种：

- **显式抛异常**通过 throw 关键字手动将异常实例抛出
- **隐式抛异常**的主体是 Java 虚拟机，它在执行过程中如果碰到无法继续执行的异常状态，自动抛出运行时异常。

捕获异常则涉及了如下三种代码块：

1. **try 代码块**：用来标记需要进行异常监控的代码。
2. **catch 代码块**：跟在 try 代码块之后，用来捕获在 try 代码块中触发的某种指定类型的异常。除了声明所捕获异常的类型之外，catch 代码块还定义了针对该异常类型的异常处理器。在 Java 中，try 代码块后面可以跟着多个 catch 代码块，来捕获不同类型的异常。Java 虚拟机会**从上至下匹配异常**处理器。因此，前面的 catch 代码块所捕获的异常类型不能覆盖后边的，否则编译器会报错。
3. **finally 代码块**：跟在 try 代码块和 catch 代码块之后，用来声明一段必定运行的代码。它的设计初衷是为了避免跳过某些关键的清理代码，例如关闭已打开的系统资源。

<font color=blue>finally 代码块的运行逻辑</font>：finally 代码块会在 catch 代码块之后运行，但如果 catch 代码块也触发了异常，那 finally 同样会运行，并会抛出 catch 代码块触发的异常。在某些极端不幸的情况下，finally 代码块也触发了异常，那么只好中断当前 finally 代码块的执行，并往外抛异常。

下面就介绍一下 Java 虚拟机的异常处理机制。

### 4.1 异常的基本概念

在 Java 语言规范中，**所有异常都是 Throwable 类或者其子类的实例**。Throwable 有两大直接子类：

- **Error**：涵盖程序不应捕获的异常。当程序触发 Error 时，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。
- **Exception**：涵盖程序可能需要捕获并且处理的异常。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230708212612.png" alt="20230708212612" style="zoom:75%;" /></center>

Exception 有一个特殊的子类 RuntimeException，用来表示“程序虽然无法继续执行，但是还能抢救一下”的情况。前边提到的数组索引越界便是其中的一种。

RuntimeException 和 Error 属于 Java 里的<mark>非检查异常</mark>（unchecked exception）。其他异常则属于<mark>检查异常</mark>（checked exception）。在 Java 语法中，所有的检查异常都需要程序显式地捕获，或者在方法声明中用 throws 关键字标注。**通常情况下，程序中自定义的异常应为检查异常，以便最大化利用 Java 编译器的编译时检查**。

**异常实例的构造十分昂贵**。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。当然，在生成栈轨迹时，Java 虚拟机会忽略掉异常构造器以及填充栈帧的 Java 方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。此外，Java 虚拟机还会忽略标记为不可见的 Java 方法栈帧。我们在介绍 Lambda 的时候会看到具体的例子。

> 既然异常实例的构造十分昂贵，我们是否可以缓存异常实例，在需要用到的时候直接抛出呢？从语法角度上来看，这是允许的。然而，该异常对应的栈轨迹并非 throw 语句的位置，而是新建异常的位置。这样不对应的栈轨迹会误导开发人员，所以我们往往还是选择新建异常实例并立刻抛出。

### 4.2 Java 虚拟机是如何捕获异常的？

在编译生成的字节码中，每个方法都附带一个<mark>异常表</mark>。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。如下例所示：

```java
public static void main(String[] args) {
  try {
    mayThrowException();
  } catch (Exception e) {
    e.printStackTrace();
  }
}

// 对应的 Java 字节码
public static void main(java.lang.String[]);
  Code:
    0: invokestatic mayThrowException:()V
    3: goto 11
    6: astore_1
    7: aload_1
    8: invokevirtual java.lang.Exception.printStackTrace
   11: return
  Exception table:
    from  to target type
      0   3   6  Class java/lang/Exception  // 异常表条目
```

在上图的 main 方法中，我定义了一段 try-catch 代码。其中，catch 代码块所捕获的异常类型为 Exception。编译过后，该方法的异常表拥有一个条目。其 from 指针和 to 指针分别为 0 和 3，代表它的监控范围从索引为 0 的字节码开始，到索引为 3 的字节码结束（不包括 3）。该条目的 target 指针是 6，代表这个异常处理器从索引为 6 的字节码开始。条目的最后一列，代表该异常处理器所捕获的异常类型正是 Exception。

**当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码**。如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。

finally 代码块的编译比较复杂。当前版本 Java 编译器的做法，是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230708213852.png" alt="20230708213852" style="zoom:75%;" /></center>

针对异常执行路径，Java 编译器会生成一个或多个异常表条目，监控整个 try-catch 代码块，并且捕获所有种类的异常（在 javap 中以 any 指代）。这些异常表条目的 target 指针将指向另一份复制的 finally 代码块。并且，在这个 finally 代码块的最后，Java 编译器会重新抛出所捕获的异常。

> 可以自己尝试使用 javap 工具来看看包含了 try-catch-finally 代码块的编译结果。

这里有一个小问题，如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 finally 捕获并且重抛的异常是哪个呢？答案是后者。也就是说原本的异常便会被忽略掉，这对于代码调试来说十分不利。

### 4.3 Java 7 的 Supressed 异常以及语法糖

对于刚刚提到的问题，ava 7 引入了 Supressed 异常来解决。**这个新特性允许开发人员将一个异常附于另一个异常之上。因此，抛出的异常可以附带多个异常的信息**。

然而，Java 层面的 finally 代码块缺少指向所捕获异常的引用，所以这个新特性使用起来非常繁琐。为此，Java 7 专门构造了一个名为 **try-with-resources 的语法糖**，在字节码层面自动使用 Supressed 异常。当然，该语法糖的主要目的并不是使用 Supressed 异常，而是精简资源打开关闭的用法。

在 Java 7 之前，对于打开的资源，我们需要定义一个 finally 代码块，来确保该资源在正常或者异常执行状况下都能关闭。资源的关闭操作本身容易触发异常。因此，如果同时打开多个资源，那么每一个资源都要对应一个独立的 try-finally 代码块，以保证每个资源都能够关闭。这样一来，代码将会变得十分繁琐。

Java 7 的 try-with-resources 语法糖，极大地简化了由关闭资源而导致的代码。**程序可以在 try 关键字后声明并实例化实现了 AutoCloseable 接口的类，编译器将自动添加对应的 `close()` 操作**。与手工代码相比，try-with-resources 还会使用 Supressed 异常的功能，来避免原异常“被消失”。如下是一个使用这个语法糖的示例：

```java
public class Foo implements AutoCloseable {
  private final String name;
  public Foo(String name) { this.name = name; }
 
  @Override
  public void close() {
    throw new RuntimeException(name);
  }
 
  public static void main(String[] args) {
    try (Foo foo0 = new Foo("Foo0"); // try-with-resources
         Foo foo1 = new Foo("Foo1");
         Foo foo2 = new Foo("Foo2")) {
      throw new RuntimeException("Initial");
    }
  }
}
 
// 运行结果：
Exception in thread "main" java.lang.RuntimeException: Initial
        at Foo.main(Foo.java:18)
        Suppressed: java.lang.RuntimeException: Foo2
                at Foo.close(Foo.java:13)
                at Foo.main(Foo.java:19)
        Suppressed: java.lang.RuntimeException: Foo1
                at Foo.close(Foo.java:13)
                at Foo.main(Foo.java:19)
        Suppressed: java.lang.RuntimeException: Foo0
                at Foo.close(Foo.java:13)
                at Foo.main(Foo.java:19)
 
```

除了 try-with-resources 语法糖之外，**Java 7 还支持在同一 catch 代码块中捕获多种异常**。实际实现非常简单，生成多个异常表条目即可：

```java
// 在同一 catch 代码块中捕获多种异常
try {
  ...
} catch (SomeException | OtherException e) {
  ...
}
```

### 4.4 总结

这一章总结 Java 虚拟机的异常处理机制。

Java 的异常分为 Exception 和 Error 两种，而 Exception 又分为 RuntimeException 和其他类型。RuntimeException 和 Error 属于非检查异常。其他的 Exception 皆属于检查异常，在触发时需要显式捕获，或者在方法头用 throws 关键字声明。

Java 字节码中，每个方法对应一个异常表。当程序触发异常时，Java 虚拟机将查找异常表，并依此决定需要将控制流转移至哪个异常处理器之中。Java 代码中的 catch 代码块和 finally 代码块都会生成异常表条目。

Java 7 引入了 Supressed 异常、try-with-resources，以及多异常捕获。后两者属于语法糖，能够极大地精简我们的代码。
