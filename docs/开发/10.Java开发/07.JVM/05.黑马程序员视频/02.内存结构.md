---
title: 内存结构
date: 2023-04-03 21:00:25
permalink: /pages/43329c/
categories:
  - 开发
  - Java开发
  - JVM
  - 黑马程序员视频
tags:
  - 
---

## 1. 程序计数器

Program Counter Register <mark>程序计数器</mark>

+ 作用：记住下一条 JVM 指令的执行地址
+ 在物理上，是通过**寄存器**来实现的
+ 特点：
  + 是**线程私有**的：每个线程都有自己的程序计数器，因为每个线程都有自己的一套字节码，不同线程会通过时间片来交替运行，交替过程中需要使用程序计数器来记录下当前程序运行到哪了。
  + **不会存在内存溢出**：像其他的堆、栈等都可能出现内存溢出

字节码和 JVM 指令如下图所示：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230403210649762.png" alt="image-20230403210649762" style="zoom: 80%;" />

## 2. 虚拟机栈

### 2.1 定义

<mark>栈</mark> —— 线程运行需要的内存空间。由多个栈帧组成，**栈帧**是每个方法运行时需要的内存。如下图所示：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230403211527259.png" alt="image-20230403211527259" style="zoom: 80%;" />

每个线程只能有一个**活动栈帧**，对应着当前正在执行的那个方法。

> 当你在 IDEA 中调试 debug Java 程序时，就会看到多个 frames，他们就是这里的栈帧：
>
> <img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230403212000349.png" alt="image-20230403212000349" style="zoom:80%;" />

::: note 问题辨析

1. 垃圾回收是否涉及栈内存？

不。垃圾回收只会回收堆中的内存。

2. 栈内存分配越大越好吗？

Java 启动时可以通过 `-Xss` 来设置栈内存。由于物理内存是一定的，**当把栈内存分配太大时，会让线程数变少**。

3. 方法内的局部变量是否线程安全？

局部变量是存在于栈帧中，每个线程会有一个栈，因此这个**局部变量也是线程私有的，不同线程之间不会互相干扰**。但 **static 是多个线程共享的**，多线程下必须对其进行保护：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230403213401872.png" alt="image-20230403213401872" style="zoom:70%;" />

**判断一个变量是否线程安全，不仅要看这个变量是否为局部变量，还看这个变量是否逃离了方法的作用范围**。比如你 return 一个局部变量创建的对象后，那这个对象就有可能被别的线程在调用方法后拿到。

因此可以总结：

+ 如果方法内局部变量没有逃离方法的作用访问，它是线程安全的。
+ 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

:::

### 2.2 栈内存溢出

往往是两个原因：

+ 栈帧过多导致栈内存溢出
+ 栈帧过大导致栈内存溢出

从而出现 **StackOverflowError** 的异常。

### 2.3 线程运行诊断

#### 2.3.1 案例一：CPU 占用过多

定位过程：

- 用 top 命令定位哪个进程对 CPU 的占用过高
- `ps H -eo pid,tid,%cpu | grep 进程id` （用 ps 命令进一步定位是哪个线程引起的 cpu 占用过高）
- 使用 `jstack 进程id` 可以根据线程 id（nid）找到有问题的线程id，进一步定位到问题代码的源码行号

#### 2.3.1 案例二：程序运行很长时间没有结果

使用 jstack 可以检测到死锁现象：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230403221106747.png" alt="image-20230403221106747" style="zoom:80%;" />

## 3. 本地方法栈

<mark>Native Method</mark> 是指不使用 Java 而编写的代码，比如有时为了与底层 OS 打交道，而需要调用 C 的代码等。这些 native method 运行时所使用的内存就是<mark>本地方法栈</mark>。

> Java 标准库中 Object.hashCode、Object.clone 等方法都是用 C/C++ 编写的，而 Java 是通过本地方法接口来调用这些方法。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230403222034459.png" alt="image-20230403222034459" style="zoom: 80%;" />

## 4. 堆

刚刚讲的部分都是线程私有的，而现在要讲的堆和后面要讲的方法区都是**线程共享**的。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230403222352736.png" alt="image-20230403222352736" style="zoom:80%;" />

### 4.1 定义

<mark>Heap</mark>：通过 new 关键字，创建对象都会使用堆内存

特点：

+ 它是**线程共享**的，**堆中对象都需要考虑线程安全的问题**
+ 有垃圾回收机制

### 4.2 堆内存溢出

如果不断创建大量对象，而且这些对象还被使用，那就可能产生堆内存溢出错误：**OutOfMemoryError**。

JVM 参数 `-Xmx` 可以控制最多可以使用的堆空间。

### 4.3 堆内存诊断

#### 4.3.1 jps 工具

查看当前系统中有哪些 java  进程

#### 4.3.2 jmap 工具

查看堆内存占用情况：`jmap -heap 进程id`

#### 4.3.3 jconsole 工具

图形界面的，多功能的监测工具，可以连续监测。这个工具很直观。

#### 4.3.4 jvirsualvm 工具​ :star:

监视更加直观。

+ 其中“**堆 dump**”（堆转储）工具可以抓取堆内存的快照，并对其中的对象进行分析

## 5. 方法区

