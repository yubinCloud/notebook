---
title: 可见性、原子性和有序性问题
date: 2023-12-16 15:44:57
permalink: /pages/java/juc/geektime/wbl/bug-src/
categories:
  - 开发
  - Java开发
  - Java 并发编程
  - 专栏：Java 并发编程实战
tags:
  - 
---

## 1. 可见性、原子性和有序性问题：并发编程 Bug 的源头

这一节介绍并发编程大部分 Bug 的源头。

计算机的发展中，有一个核心矛盾：**CPU、内存、IO 设备的速度差异**。为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：

1. CPU 增加了缓存，以均衡与内存的速度差异；
2. 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
3. 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

而并发程序的很多诡异问题就根源于这里。

### 1.1 源头一：缓存导致的可见性问题

单核时代，所有线程都跑在一颗 CPU 上，因为所有线程都操作同一个 CPU 缓存，所以 CPU 缓存与内存的数据一致性容易解决，如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20231216155812.png" alt="20231216155812" style="zoom:75%;" /></center>

这时，一个线程对共享变量的修改，另一个线程能够立刻看到，我们称之为<mark>可见性</mark>。

多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20231216155915.png" alt="20231216155915" style="zoom:75%;" /></center>

这时，线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。

### 1.2 源头二：线程切换带来的原子性问题

操作系统对所有进程的调度是分时调度，也就是允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为**时间片**。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20231216160146.png" alt="20231216160146" style="zoom:75%;" /></center>

例如一个进程在进行一个 IO 操作时，就可以把自己标为“休眠状态”并让出 CPU 使用权。

Java 并发是基于多线程的，这些线程也受到操作系统的调度。现代 Java 语言的一行代码会被编译为多条 CPU 指令完成，而操作系统的任务切换可能发生在任何一条 CPU 指令执行完时，这导致一行代码的执行被切分开执行了。

我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为<mark>原子性</mark>。

> CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。
>
> 比如，Java 的 long 类型是 64 位的，当运行在 32 位的机器上时，long 类型变量的加减操作都会被转换成多个指令执行，这就有可能导致并发问题的出现。

### 1.3 源头三：编译优化带来的有序性问题

<mark>有序性</mark>是指程序按照代码的先后顺序执行。

编译器为了优化性能，有时会调整语句的执行顺序，但这可能导致并发时出现意想不到的 Bug。

在 Java 领域一个经典的案例就是利用双重检查创建单例对象，代码如下：

```java
public class Singleton {

  static Singleton instance;

  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```

这段代码看上去没问题。但这个 `getInstance()` 方法并不完美，问题出在 new 操作上，我们以为的 new 操作是：

1. 分配一块内存 M；
2. 在内存 M 上初始化 Singleton 对象；
3. 然后 M 的地址赋值给 instance 变量。

但实际上优化后的执行路径却可能是：

1. 分配一块内存 M；
2. 将 M 的地址赋值给 instance 变量；
3. 最后在内存 M 上初始化 Singleton 对象。

这会导致什么问题呢？们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 `instance != null` ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。

### 总结

并发程序经常出现的诡异问题看上去非常无厘头，但是深究的话，无外乎就是直觉欺骗了我们，只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的。
