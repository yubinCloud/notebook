---
title: 共享模型之内存
date: 2023-07-02 15:21:00
permalink: /pages/java/juc/heima/sharemodel-memory/
categories:
  - 开发
  - Java开发
  - Java 并发编程
  - 黑马
tags:
  - 
---

上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性。而这一章将深入学习共享变量在多线程间的**可见性问题**与多条指令执行时的**有序性问题**。

## 1. Java 内存模型

JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。

JMM 主要要解决的三方面问题为：

- 原子性 - 保证指令不会受到线程上下文切换的影响
- 可见性 - 保证指令不会受 cpu 缓存的影响
- 有序性 - 保证指令不会受 cpu 指令并行优化的影响

## 2. 可见性

### 2.1 一个现象：退不出的循环

先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：

```java
static boolean run = true;

public static void main(String[] args) throws InterruptedException {
    
    Thread t = new Thread(()->{
        while (run) {
            // ....
        }
    });
    t.start();
    
    sleep(1);
    run = false; // 线程t不会如预想的停下来
}
```

为什么会出现这样的情况呢？下面分析一下：

初始时，t 线程从主内存中读取了 `run` 的值到工作内存中：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230702183919.png" alt="20230702183919" style="zoom:75%;" /></center>

但因为 t 线程需要频繁访问 `run` 变量，**JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中**，从而减少对主存中 run 的访问，来提高效率。但之后 main 线程修改了主存中 run 的之后，t 线程仍然是从自己的高速缓存中读取 `run` 变量的值，这样读到的就永远是旧值，从而导致了循环无法退出。这个过程如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230702184206.png" alt="20230702184206" style="zoom:75%;" /></center>

### 2.2 解决方法

解决方法：给变量加上 <mark>volatile</mark> 关键字，它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，**线程操作 volatile 变量都是直接操作主存**。，因此，<font color=blue><strong>volatile 关键字保证了在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见</strong></font>。

所以上面问题的解决方法就是这样定义 `run` 变量：

```java
volatile static boolean run = true;
```

另一种解决办法就是把对 `run` 变量的访问放到 synchronized 块里面，这样也可以保证可见性，但这样就变得有点重量级了：

```java
static boolean run = true;

...

synchronized (obj) {
    if (!run) {
        ...
    }
}
```

### 2.3 可见性 VS 原子性

前面例子体现的实际就是**可见性**，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，**不能保证原子性**，仅用在一个写线程，多个读线程的情况。

如果你真的想保证原子性，那只能老老实实地加锁了。

> synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低。
>
> ---
>
> 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？
>
> 因为其内部包含了 synchronized 的使用。

### 2.4 案例：终止模式之两阶段终止模式

Two Phrase Termination，指的是在一个线程 T1 中如何“优雅”地终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。

之前讲的方式使用打断标记来实现的，其实可以用一个 volatile 的 flag 来代替这个打断标记，实现思路类似。

### 2.5 案例：同步模式之 Balking

#### 2.5.1 定义

Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。

#### 2.5.2 实现

通过设置一个 volatile 的标记变量，来表示是否已经有其他线程做了某件事。然后每个线程在想做这件事之前，先检查一下这个标记变量：

```java
public class MonitorService {
    
    // 用来表示是否已经有线程已经在执行启动了
    private volatile boolean starting;
    
    public void start() {
        log.info("尝试启动监控线程...");
        synchronized (this) {
            if (starting) {
                return;
            }
            starting = true;
        }
        
        // 真正启动监控线程...
    }
}
```

#### 2.5.3 应用——单例模式

这种思路经常用来实现单例模式：

```java
public final class Singleton {
    
    private Singleton() { }
    
    private static Singleton INSTANCE = null;
    public static synchronized Singleton getInstance() {
        if (INSTANCE != null) {
            return INSTANCE;
        }
        
        INSTANCE = new Singleton();
        return INSTANCE;
    }
}
```

对比一下保护性暂停模式：保护性暂停模式用在一个线程等待另一个线程的执行结果，当条件不满足时线程等待。

## 3. 有序性

### 3.1 指令重排

#### 3.1.1 什么是指令重排？

JVM 会在不影响正确性的前提下，可以调整语句的执行顺序。思考下面一段代码：

```java
static int i;
static int j;

// 在某个线程内执行如下赋值操作
i = ...; 
j = ...;
```

可以看到，至于是先执行 i 还是先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是先执行对 i 的赋值，也可以是先执行对 j 的赋值。

这种特性称之为『<mark>指令重排</mark>』，**多线程下『指令重排』会影响正确性**。为什么要有重排指令这项优化呢？从 CPU 执行指令的原理来理解一下吧

#### 3.1.2 指令重排与现代处理器的关系

现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为：`取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回` 这 5 个阶段。

在不改变程序结果的前提下，这些指令的各个阶段可以通过**重排序**和**组合**来实现**指令级并行**，这一技术在 80's 中叶到 90's 中叶占据了计算架构的重要地位。

指令重排的前提是：重排指令不能影响结果。

#### 3.1.3 指令重排序导致的诡异的结果

```java
int num = 0;
boolean ready = false;

// 线程1 执行此方法
public void actor1(I_Result r) {
    if (ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}

// 线程2 执行此方法
public void actor2(I_Result r) { 
    //这里可能发生指令重排序
    num = 2;
    ready = true; 
}
```

上面两个方法并行运行，`r.r1` 的值可能是多少呢？以下是可能的情况：

- 情况 1：线程 1 先执行，这时 ready = false，所以 `r.r1` 的结果为 1
- 情况 2：线程 2 先执行 num = 2，但还没来得及对 ready 赋值为 true 就运行了线程 1，这时 `r.r1` 的结果为 1
- 情况 3：线程 2 先执行完，这时线程 1 执行 if 分支，得到结果为 4

但还有一个隐晦的可能情况，那就是因为指令重排，导致先执行了线程 2 的 `ready = true` 但还没执行  `num = 2`，而同时执行了线程 1，这样 `r.r1` 的结果就是 0。

这种比较隐晦的情况可能需要大量的测试才可能出现。这可以借助 Java 的并发压测工具 jcstress 来实现。

### 3.2 volatile 禁止指令重排

**volatile 修饰的变量，可以禁用指令重排**。可以禁止 volatile 所修饰的变量在方法中赋值之前的重排序。

这样上面的例子就可以通过给 `ready` 变量加一个 volatile 来防止因指令重排导致的错误结果：

```java
@JCStressTest
@Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
@Outcome(id = "0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
@State
public class ConcurrencyTest {
    
    int num = 0;
    volatile boolean ready = false;
    
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }
    
    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
    
}
```

## 4. volatile 原理

volatile 的底层实现原理是<mark>内存屏障</mark>，Memory Barrier（Memory Fence）：

- 对 volatile 变量的写指令后会加入写屏障
- 对 volatile 变量的读指令前会加入读屏障

### 4.1 如何保证可见性？

<mark>写屏障</mark>（**sfence**）**保证在该屏障之前的，对共享变量的改动，都同步到主存当中**：

```java
public void actor2(I_Result r) {
    num = 2;
    ready = true; // ready 是 volatile 赋值带写屏障
    // 写屏障
}
```

<mark>读屏障</mark>（**lfence**）**保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据**：

```java
public void actor1(I_Result r) {
    // 读屏障
    // ready 是 volatile 读取值带读屏障
    if(ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}
```

### 4.2 如何保证有序性

**写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后**：

```java
public void actor2(I_Result r) {
    num = 2;
    ready = true; // ready 是 volatile 赋值带写屏障
    // 写屏障
}
```

**读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前**：

```java
public void actor1(I_Result r) {
    // 读屏障
    // ready 是 volatile 读取值带读屏障
    if (ready) {
        r.r1 = num + num;
    } else {
        r.r1 = 1;
    }
}
```

**还是那句话，不能解决指令交错**：

- 写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去
- 而有序性的保证也只是保证了本线程内相关代码不被重排序

### 4.3 案例：单例模式中的 double-checked locking 问题

以著名的 double-checked locking 单例模式为例：

```java
public final class Singleton {
    private Singleton() { }
    private static Singleton INSTANCE = null;
    
    public static Singleton getInstance() { 
        if (INSTANCE == null) { // t2
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized(Singleton.class) {
                if (INSTANCE == null) { // t1
                    INSTANCE = new Singleton(); 
                } 
            }
        }
        return INSTANCE;
    }
}
```

以上的实现特点是：

- 懒惰实例化
- 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁
- 有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外，无法保证它的原子有序和可见性。
