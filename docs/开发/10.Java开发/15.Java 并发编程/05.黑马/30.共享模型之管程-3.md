---
title: 共享模型之管程 3：park、多把锁、ReentrantLock
date: 2023-06-24 22:42:00
permalink: /pages/java/juc/heima/sharemodel-monitors-3/
categories:
  - 开发
  - Java开发
  - Java 并发编程
  - 黑马
tags:
  - 
---

## 1. Park & Unpark

### 1.1 基本使用

它们都是 LockSupport 类中的方法：

- `LockSupport.park()`：暂停当前线程
- `LockSupport.unpark(暂停线程对象)`：恢复某个线程的运行

#### 1.1.1 先 park 再 unpark

使用时可以先 park 再 unpark：

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(1);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
},"t1");
t1.start();

sleep(2);
log.debug("unpark...");
LockSupport.unpark(t1);
```

输出：

```shell
18:42:52.585 c.TestParkUnpark [t1] - start... 
18:42:53.589 c.TestParkUnpark [t1] - park... 
18:42:54.583 c.TestParkUnpark [main] - unpark... 
18:42:54.583 c.TestParkUnpark [t1] - resume...
```

#### 1.1.2 先 unpark 再 park

也可以先 unpark 再 park：

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(2);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
}, "t1");
t1.start();

sleep(1);
log.debug("unpark...");
LockSupport.unpark(t1);
```

输出：

```shell
18:43:50.765 c.TestParkUnpark [t1] - start... 
18:43:51.764 c.TestParkUnpark [main] - unpark... 
18:43:52.769 c.TestParkUnpark [t1] - park... 
18:43:52.769 c.TestParkUnpark [t1] - resume...
```

这种可以先 unpark 再 park 也能运行的方式比较特别，之后会看到它的底层原理，这里先记住这个结论就好。

#### 1.1.3 特点

与 Object 的 wait & notify 相比：

- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必
- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】
- park & unpark 可以先 unpark，而 wait & notify 不能先 notify

### 1.2 原理之 park & unpark

**每个线程都有自己的一个(C代码实现的) Parker 对象**，由三部分组成 `_counter`, `_cond` 和 `_mutex`。

打个比喻，线程就像一个旅人，Parker 就像他随身携带的背包，条件变量 `_cond` 就好比背包中的帐篷。`_counter` 就好比背包中的备用干粮（0 为耗尽，1 为充足）：

- 调用 park 就是要看需不需要停下来歇息
  - 如果备用干粮耗尽，那么钻进帐篷歇息
  - 如果备用干粮充足，那么不需停留，继续前进
- 调用 unpark，就好比令干粮充足
  - 如果这时线程还在帐篷，就唤醒让他继续前进
  - 如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留,继续前进
    - 因为背包空间有限，**多次调用 unpark 仅会补充一份备用干粮，也就是多次 unpark 后只会让紧跟着的一次 park 失效**

按照这个原理，我们看一下调用 park & unpark 时发生的情况：

#### 1.2.1 先 park 再 unpark

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230629144752.png" alt="20230629144752" style="zoom:75%;" /></center>

1. 当前线程调用 `Unsafe.park()` 方法
2. 检查 `_counter` ，本情况为 0，这时，获得 `_mutex` 互斥锁
3. 线程进入 `_cond` 条件变量阻塞
4. 设置 `_counter = 0`

#### 1.2.2 先 unpark 再 park

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230629144855.png" alt="20230629144855" style="zoom:75%;" /></center>

1. 调用 `Unsafe.unpark(Thread_0)` 方法，设置 `_counter` 为 1
2. 当前线程调用 `Unsafe.park()` 方法
3. 检查 `_counter` ，本情况为 1，这时线程无需阻塞，继续运行
4. 设置 `_counter` 为 0

## 2. 重新理解线程状态转换
