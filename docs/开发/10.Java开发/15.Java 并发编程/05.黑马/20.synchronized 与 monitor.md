---
title: synchronized 与 monitor
date: 2023-06-23 11:21:00
permalink: /pages/java/juc/heima/sharemodel-monitors/
categories:
  - 开发
  - Java开发
  - Java 并发编程
  - 黑马
tags:
  - 
---

## 1. 共享带来的问题

当多个线程同时访问<mark>共享资源</mark>时，对共享资源的读写操作会发生指令交错，从而出现问题。

### 1.1 临界区 Critical Section

一段代码块内如果存在对共享资源的多线程读写操作，那这段代码块就称为<mark>临界区</mark>。

例如，下面代码中的临界区：

```java
static int counter = 0;

static void increment()
// 临界区
{
    counter++; 
}

static void decrement()
// 临界区
{
    counter--; 
}
```

### 1.2 竞态条件 Race Condition

多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<mark>竞态条件</mark>。

为避免临界区的竞态条件发生，有多种手段可以达到目的：

- 阻塞式的解决方法：synchronized、lock
- 非阻塞式的解决方法：原子变量

## 2. synchronized 解决方案

这一大节使用的是阻塞式的解决方案：synchronized，俗称<mark>对象锁</mark>，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程再想获取这个对象锁时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

::: note warning 互斥与同步
虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：

- **互斥**是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
- **同步**是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点
:::

### 2.1 synchronized 语法

synchronized 可以对一个对象进行加锁，且只有一个线程能够持有这个对象的对象锁。语法：

```java
synchronized( 对象 ) // 线程1， 线程2(blocked)
{
    临界区
}
```

示例：

```java {8,16}
static int counter = 0;
static final Object room = new Object();

public static void main(String[] args) throws InterruptedException {
    
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter++;
            }
        }
    }, "t1");
    
    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter--;
            }
        }
    }, "t2");
    
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.debug("{}",counter);
}
```

<strong><font color=blue>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断</font></strong>。

### 2.2 面向对象改进

把需要保护的共享变量放入一个类，这个类对外暴露出原子性的接口：

```java
class Room {
    int value = 0;
    public void increment() {
        synchronized (this) {
            value++;
        }
    }
    public void decrement() {
        synchronized (this) {
            value--;
        }
    }
    public int get() {
        synchronized (this) {
            return value;
        }
    }
}

@Slf4j
public class Test1 {

    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(() -> {
            for (int j = 0; j < 5000; j++) {
                room.increment();
            }
        }, "t1");
        
        Thread t2 = new Thread(() -> {
            for (int j = 0; j < 5000; j++) {
                room.decrement();
            }
        }, "t2");
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        log.debug("count: {}" , room.get());
    }
}
```

在上述优化中，Room 对象对外暴露了原子性的接口，而内部实现则使用 synchronized 来保护共享变量。

### 2.3 方法上的 synchronized

【对象锁】只能锁在 object 上，当 synchronized 加在方法上时：

- 加在普通方法上 => 等价于锁 `this`
- 加在 static 方法上 => 等价于锁 `Student.class`

示例：

```java
class Test{
    public synchronized void test() {

    }
}

等价于

class Test {
    public void test() {
        synchronized(this) {

        }
    }
}
```

```java
class Test {
    public synchronized static void test() {
        
    }
}

等价于

class Test {
    public static void test() {
        synchronized(Test.class) {

        }
    }
}
```

而不加 synchronized 的方法就好比不遵守规则的人，无法对其有什么保证。

> 在做 synchronized 相关的面试题时，**关键是要清楚对象锁是加在谁身上了**。

### 2.4 变量的线程安全分析

#### 2.4.1 成员变量和静态变量是否线程安全？

- 如果它们没有共享，则线程安全
- 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况：
  - 如果只有读操作，则线程安全
  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全

#### 2.4.2 局部变量是否线程安全？

- 局部变量是线程安全的
- 但局部变量引用的对象则未必
  - 如果该对象没有逃离方法的作用范围，那它是线程安全的
  - 如果该对象逃离方法的作用范围，需要考虑线程安全

示例：

```java
public static void test1() {
    int i = 10;
    i++; 
}
```

每个线程调用 test1() 方法时，**局部变量 `i` 会在每个线程的栈帧内存中被创建多份**，因此不存在共享。但那些如果引用的是一个作用范围超出 method 的对象，那它可能就是一个共享资源，因此需要考虑线程安全问题。

#### 2.4.3 方法修饰符的一个隐藏问题

下面是一个我们写的 ThreadSafe 类，看上去好像是安全的：

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    private void method2(ArrayList<String> list) {
        list.add("1");
    }
    private void method3(ArrayList<String> list) {
        list.remove(0);
    }
}
```

由于 `list` 是一个局部变量，每个线程调用时会创建其不同实例，没有共享，调用 `method2` 和 `method3` 也没事，因此好像是没啥问题。

但如果有个人为 ThreadSafe 添加了一个子类，子类方法覆盖了 `method3`，比如：

```java
class ThreadSafe {
    public final void method1(int loopNumber) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < loopNumber; i++) {
            method2(list);
            method3(list);
        }
    }
    public void method2(ArrayList<String> list) {
        list.add("1");
    }
    public void method3(ArrayList<String> list) {
        list.remove(0);
    }
}

class ThreadSafeSubClass extends ThreadSafe{
    @Override
    public void method3(ArrayList<String> list) {
        new Thread(() -> {
            list.remove(0);
        }).start();
    }
}
```

在使用一个 ThreadSafeSubClass 的实例对象时，`method1` 创建的 list 在交给 `method3` 时，`method3` 却开了一个新线程，让 list 变成了一个多线程间的共享变量，从而出现了线程安全问题。

从这个例子可以看出 **private 和 final 提供的【安全】的意义所在**：通过限制不能子类重写方法，保护了线程的安全。

### 2.5 常见线程安全类

常见的<mark>线程安全类</mark>有如下：

- String
- Integer
- StringBuffer
- Random
- Vector
- Hashtable
- java.util.concurrent 包下的

**这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的**。

示例：

```java
Hashtable table = new Hashtable();

new Thread(()->{
    table.put("key", "value1");
}).start();

new Thread(()->{
    table.put("key", "value2");
}).start();
```

这些线程安全的类的实例的方法是原子性的。

#### 2.5.1 线程安全类方法的组合

线程安全类的方法是原子的，但注意，它们的多个方法的组合不是原子的。如下例，请分析下面代码是否线程安全：

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
    table.put("key", value);
}
```

它只能保证 get 和 put 分别是原子的，但这两个的组合并不一定线程安全，这里仍需要加锁来让代码块变成原子性的。

#### 2.5.2 不可变类的线程安全性

String、Integer 等都是<mark>不可变类</mark>，因为其内部的状态不可以改变，因此**它们的方法都是线程安全的**。

## 3. Monitor 概念

### 3.1 Java 对象头

> 以 32 位虚拟机为例

普通对象：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623141306.png" alt="20230623141306" style="zoom:75%;" /></center>

- Mark Word 主要用来存储对象自身的运行时数据
- Klass Word 指向 Class 对象

数组对象：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623141335.png" alt="20230623141335" style="zoom:75%;" /></center>

- 相对于普通对象多了记录数组长度

其中 Mark Word 结构为：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623141504.png" alt="20230623141504" style="zoom:75%;" /></center>

64 位虚拟机的 Mark Word：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623141523.png" alt="20230623141523" style="zoom:75%;" /></center>

> 参考资料：[What is in Java object header?| Stack Overflow](https://stackoverflow.com/questions/26357186/what-is-in-java-object-header)

### 3.2 Monitor

Monitor 被翻译为**监视器**或**管程**

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针。

假如有下面一段代码：

```java
synchronized( obj ) {
    // 临界区代码
}
```

现有 thread-2 访问并获得对象锁，之后 thread-1 和 thread-3 也执行到这里想要获得对象锁，这时候发生的情况如下：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623142224.png" alt="20230623142224" style="zoom:75%;" /></center>

- obj 的 MarkWord 关联到一个操作系统分配的 Monitor 对象，刚开始 Monitor 的 owner 为 null
- 当 thread-2 执行 `synchronized(obj)` 时，就会将 monitor 的 owner 置为 thread-2，这样就完成了上锁
- 在 thread-2 加锁后，如果 thread-1 和 thread-3 也来执行 `synchronized(obj)`，那么他们会发现 obj 的 monitor 已经有 owner 了，于是会进入 monitor 的 EntryList BLOCKED 中等待
- thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的

> 图中的 WaitSet 会在之后讲 wait-notify 时进行分析

**注意**：

- synchronized 必须是进入同一个对象的 monitor 才有上述的效果
- 不加 synchronized 的对象不会关联监视器，不遵从以上规则

### 3.3 从字节码的角度看 synchronized

有下面一段代码：

```java
static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
    synchronized (lock) {
        counter++;
    }
}
```

对应的字节码如下：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623143811.png" alt="20230623143811" style="zoom:75%;" /></center>

可以看到，字节码这个层面考虑地非常完善，不管是正常执行还是出现异常，只要你的代码是在 synchronized 里面，他就会给你正确地做好加锁和释放锁。

## 4. 锁升级

### 4.1 轻量级锁

<mark>轻量级锁</mark>的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。轻量级锁对使用者是透明的，即语法仍然是 synchronized。

> 这里的轻量级锁不涉及 monitor

假设有两个方法同步块，利用同一个对象加锁：

```java
static final Object obj = new Object();

public static void method1() {
    synchronized( obj ) {
        // 同步块 A
        method2();
    }
}

public static void method2() {
    synchronized( obj ) {
        // 同步块 B
    }
}
```

上述代码的过程如下：

- 创建**锁记录**（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结果，内部可以存储锁定对象的 Mark Word：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623151119.png" alt="20230623151119" style="zoom:75%;" /></center>

- 让锁记录中的 Object reference 指向锁对象，并尝试用 CAS 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录：（红色箭头是尝试用 CAS 操作进行交换）

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623151311.png" alt="20230623151311" style="zoom:75%;" /></center>

- 如果 CAS 替换成功，对象头中存储了 `lock record 地址和状态 00`，表示由该进程给对象加锁，这时图示如下：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623151426.png" alt="20230623151426" style="zoom:75%;" /></center>

- 如果 CAS 失败，有两种情况：
  - 如果是其他线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程
  - 如果是自己持有的这个轻量级锁（如本例），那就执行 synchronized **锁重入**，再添加一条 Lock Record 作为重入的计数，如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623151627.png" alt="20230623151627" style="zoom:75%;" /></center>

- 当退出 synchronized 代码块（解锁时），如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230623151728.png" alt="20230623151728" style="zoom:75%;" /></center>

- 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 CAS 将 Mark Word 的值恢复给对象头
  - 成功，则解锁成功
  - 失败，则说明轻量级锁进行了所膨胀或已经升级为重量级锁，进入重量级锁的解锁流程

### 4.2 锁膨胀

<mark>锁膨胀</mark>是