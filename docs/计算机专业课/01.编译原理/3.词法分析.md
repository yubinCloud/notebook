---
title: 词法分析
date: 2021-12-30 12:17:15
permalink: /pages/f8ea13/
categories:
  - 编译原理
tags:
  - cs
---
## 3.1 正则表达式

**正则表达式**(Regular Expression，**RE** )是一种用来描述正则语言的 更紧凑的表示方法，可以由较小的正则表达式按照特定规则递归地构建。

每个正则表达式 r 定义（表示）一个语言，记为$L(r)$。

### 1）正则表达式定义

+ ε是一个RE，L(ε) = {ε}
+ 如果 a∈∑，则a是一个RE，L(a) = {a}
+ 假设 r 和 s 都是 RE，表示的语言分别是 L(r) 和 L(s)，则
  + r|s 是一个RE，L( r|s ) = L(r) ∪ L(s)
  + rs 是一个RE，L( rs ) = L(r) L(s) 
  + r * 是一个RE，L( r * )= (L(r))* 
  + (r) 是一个RE，L( (r) ) = L(r)

比如 $L((a|b)^*) = (L(a|b))^* = \{a, b\}^*= \{ \epsilon, a, b, aa, ab, ba, bb, aaa, \dots \}$

::: details C 语言无符号整数的 RE

十进制整数：$(1| \dots | 9)(0|\dots|9)^*|0$

八进制整数：$0(0|1|\dots|7)(0|1|\dots|7)^*$

十六进制整数：$0x(1|\dots|9|a|\dots|f|A|\dots|F)(1|\dots|9|a|\dots|f|A|\dots|F)^*$

:::

可以用 RE 定义的语言叫做**正则语言**或**正则集合**。

### 2）RE 的代数定律

|                     定律                      |        描述        |
| :-------------------------------------------: | :----------------: |
|                  $r|s = s|r$                  |   \| 是可交换的    |
|         $r｜（ s｜t ）=（r｜s ）｜t$          |    ｜是可结合的    |
|            $r（s t ）=（ r s ）t$             |   连接是可结合的   |
| $r（s｜t ）= r s｜r t ; （s｜t ）r = sr｜t r$ | 连接对｜是可分配的 |
|                 $εr = rε = r$                 |  ε 是连接的单位元  |
|             $r^* = （ r｜ε ）^*$              |  闭包中一定包含 ε  |
|               $r ^{**} = r^ *$                |   \* 具有幂等性    |

### 3）正则文法与正则表达式的等价性

+ 对任何正则文法 G，存在定义同一语言的正则表达式 r；
+ 对任何正则表达式 r，存在生成同一语言的正则文法 G。

## 3.2 正则定义

**正则定义**是具有如下形式的定义序列：$d_i \to r_i$，

+ 其中 $d_i$ 都是新符号，不再字母表$\Sigma$中，且各不相同；
+ $r_i$ 都是 $\Sigma \cup \{d_1, \dots,d_{i-1}\}$上的正则表达式

::: details 示例：C 语言标识符的正则定义

$digit → 0|1|2|…|9$

$letter\_ \to A|B|…|Z|a|b|…|z|\_ $

$id → letter\_(letter\_|digit)^*$

:::

## 3.3 单词的识别

### 1）有穷自动机

这类系统具有一系列<u>离散的输入输出</u>信息和<u>有穷数目的内部状态</u>，只需要根据当前所处的状态和当前面临的输入信息就可以决定系统的后继行为。

**FA 模型**：![image-20211230123814543](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230123814543.png)

+ **输入带**：用来存放输入符号串
+ **读头**：从左向右逐个读取输入符号，不能修改（只读）、不能往返移动
+ **有穷控制器**：具有有穷个状态数，根据当前的状态和当前输入符号控制转入下一状态

**FA 转换图**：![image-20211230123947697](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230123947697.png)

+ 结点：FA 的状态
  + 初始状态（开始状态）：只有一个，由 start 箭头指向；
  + 终止状态（接收状态）：可以有多个，用双圈表示。

给定输入串x，如果存在一个对应于串x的从初始状态到某个终止状态的转换序列，则称串x被该**FA接收**。

**最长子串匹配原则**：总是选择最长的前缀进行匹配。在到达某个终态之后，只要输入带上还有符号， FA 就继续前进，以便寻找尽可能长的匹配。

### 2）有穷自动机的分类

分为**确定的 FA**（DFA）和**非确定的 FA**（NFA）。

#### ① DFA

$M = ( S，Σ ，δ，s_0，F )$

+ S：有穷状态集
+ $\Sigma$：输入字母表
+ δ：将 S × Σ 映射到 S 的转换函数
+ $s_0$：开始状态
+ F：接收状态集合

::: details DFA 示例

![image-20211230124600558](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230124600558.png)

:::

#### ② NFA

$M = ( S，Σ ，δ，s_0，F )$

在某个状态经一个输入可能进入多个状态。

::: details NFA  示例

![image-20211230124746059](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230124746059.png)

:::

#### DFA 与 NFA 的等价性：

+ 对任何 NFA  ，存在定义同一语言的 DFA；
+ 对任何 DFA  ，存在定义同一语言的 NFA。

#### ③ 带有 “ε-边” 的 NFA

![image-20211230125016834](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230125016834.png)

带有和不带有“ε-边”的 NFA 的也具有**等价性**。

#### DFA 的算法实现

+ 输入：以文件结束符eof结尾的字符串x。开始状态 $s_0$，接收状态集 F，转换函数 move。

+ 输出：如果接收 x，则回答“yes”，否则回答“no” 。 
+ 方法：将下述算法应用于输入串 x。

```c
s = s0 ;
c = nextChar（）;
while（c! = eof ）｛
	s = move ( s , c ) ;
	c = nextChar ( ) ;
｝
if (s在F中) return “yes”;
else return “no”;
```

### 3）RE → NFA

从 RE 直接到 DFA 较困难，通常是先转换成 NFA 再转换成 DFA。

|          RE           |                          对应的 NFA                          |
| :-------------------: | :----------------------------------------------------------: |
|      $\epsilon$       | ![image-20211230125534832](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230125534832.png) |
| $\Sigma$ 中的符号 $a$ | ![image-20211230125629508](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230125629508.png) |
|     $r = r_1 r_2$     | ![image-20211230125654010](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230125654010.png) |
|   $r=r_1 \mid r_2$    | ![image-20211230125718015](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230125718015.png) |
|     $r = (r_1)^*$     | ![image-20211230125742490](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230125742490.png) |

::: details 示例

$r=(a|b)^*abb$ 对应的 NFA： 

![image-20211230130619127](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230130619127.png)

:::

### 4）NFA → DFA

DFA 的每个状态都是一个由 NFA 中的状态构成的集合，即 NFA 状态集合的一个子集

::: details 转换示例

![image-20211230130810182](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230130810182.png)

![image-20211230130836958](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230130836958.png)

:::

### 5）识别单词的 DFA

#### 识别标识符

![image-20211230131037605](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230131037605.png)

#### 识别无符号数

![image-20211230131103184](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230131103184.png)

![image-20211230131134444](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230131134444.png)

#### 识别注释

![image-20211230131209140](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230131209140.png)

#### 识别 Token

![image-20211230131226915](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20211230131226915.png)

#### 词法分析阶段的错误处理

可检测到单词拼写错误或非法字符等。如果当前状态与当前输入符号在转换表对应项中的信息为空，而当前状态又不是终止状态，则调用错误处理程序。

**错误处理程序**：查找已扫描字符串中最后一个对应于某终态的字符。**如果找到了**，将该字符与其前面的字符识别成一个单词，然后将输入指针退回到该字符，扫描器重新回到初始状态，继续识别下一个单词；**如果没找到**，则确定出错，采用错误恢复策略。

**错误恢复策略**：最简单的策略是**恐慌模式**，即从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的字符为止。

