---
title: 强化学习
date: 2022-06-30 16:39:22
permalink: /pages/lhy/RL/
categories:
  - AI
  - 深度学习
  - 深度学习-李宏毅2021春
tags:
  - 
---



之前所讲的技术基本上都是基于 Supervised Learning，它们的数据都有一个 label，但在 RL 里面就是要面对另一个问题：**机器当给我们一个 input 的时候，我们不知道最佳的 output 应该是什么**。比如下围棋，面对一个盘势，怎样的下一步是最好的答案是不知道的（尽管一些棋谱中能给出较好的答案），**在这个你不知道正确答案是什么的情况下，往往就是 RL 可以派上用场的时候**。

但是 RL 在学习时，机器也不是一无所知的，我们虽然不知道正确的答案是什么，但机器会知道什么是好，什么是不好，机器会与环境互动，得到一个叫做 reward 的东西。藉由知道什么样的输出是好的，什么是不好的，机器还是可以学出一个模型。

本章的 Outline：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630170307941.png" alt="image-20220630170307941" style="zoom:67%;" /></center>

我们想说的是 RL 也跟 Machine Learning 一样也是三个步骤，具有相同的框架，不要觉得难学。

## 1. What is RL?

### 1.1 相关概念

我们已经说了 Machine Learning 就是找一个 function，RL 同样也是如此。

在 RL 里面，会有一个 <mark>Actor</mark>，还有一个 <mark>Environment</mark>，这个 **Actor 与 Environment 会进行互动**：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630170736614.png" alt="image-20220630170736614" style="zoom: 85%;" /></center>

+ Environment 会给 Actor 一个 Observation 作为输入；
+ Actor 看到 Observation 后会有一个输出 Action，这个 Action 会去影响 Environment；
+ Actor 采取 Action 后，Environment 会给予一个新的 Observation；

这里的 Actor 本身就是一个 function，是我们所要找的 function，其输入是 Environment 给它的 Observation，输出是这个 Actor 要采取的 Action，在这个互动过程中，Environment 会不断地给 Actor 一些 Reward，来告诉它说这个 Action 是好的还是不好的。**要找的 Actor 这个 function 就是最大化最终得到的 Reward 的总和**。

### 1.2 Example: Playing Video Game

拿 Space Invader 这个简单的小游戏来作为例子。最早的几篇 RL 的论文都是让机器去玩 Space Invader 这个游戏。

> Space Invader：
>
> <img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630185529191.png" alt="image-20220630185529191" style="zoom: 88%;" />
>
> + 要操控的是下面的绿色太空梭，可以采取的 Action 有三个：左移、右移和开火，要做的就是杀掉画面上的外星人。
> + 开火几种黄色的外星人的话，外星人就死掉了。
> + 你前面橙色的东西是防护罩，你不小心打到它也会使它减小，也可以躲在它后面抵挡外星人的攻击。
> + 杀死外星人或者打掉最上面的补给包会奖励 score，这个 score 就是 Environment 给我们的 Reward。
> + 游戏的终止条件：外星人都被杀光或者你的母舰被外星人击中。

如果要用 Actor 去玩 Space Invader：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630190050323.png" alt="image-20220630190050323"  /></center>

Actor 坐在一个人的角度去操控摇杆，Environment 就是游戏的主机，Observation 是游戏的画面，Action 是向左、向右和开火三种可能的行为之一，得到的 score 就是 Reward。游戏画面改变的时候，就代表有了新的 Observation 进来，此时你的 Actor 就会决定采取新的 Action。

我们的目标就是 learn 出一个 Actor，它可以在玩这个游戏时得到的 Reward 总和是最大的。

### 1.3 Example: Learning to play Go

实如果把 RL 拿来玩围棋，那你的 Actor 就是就是 AlphaGo，Environment 就是 AlphaGo 的人类对手。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630191146451.png" alt="image-20220630191146451" style="zoom: 80%;" /></center>

在下围棋里面，Actor 所采取的行为几乎没有办法得到任何 Reward，而是定义说如果赢了就得到 1 分，输了就得到 -1 分。

### 1.4 RL 的三个步骤

课程一开始就说了 Machine Learning 就是三个步骤：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630191659242.png" alt="image-20220630191659242" style="zoom:80%;" />

1. 有一个 function，里面有一些未知的 params，这些未知数是要被找出来的；
2. 定一个 loss function
3. Optimization：想办法找出未知 params 去最小化 loss

其实 RL 也是一样的三个步骤，分别来看一下。

#### :footprints: Step 1：Function with Unknown

这里有未知数的 function 就是 Actor，这个 Actor 就是一个 Network，现在通常叫它 **Policy Network**。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630192153053.png" alt="image-20220630192153053" style="zoom:80%;" />

这个 Network 会给每个可能的 Action 输出一个得分，且这些得分总和为 1：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630192335745.png" alt="image-20220630192335745"  />

至于这个 Network 的架构，可以你自己去设计，它可以是 CNN，也可以是 RNN 甚至是 Transformer 等。

在最后机器在决定采取哪一个 Action 时取决于输出的每一个 Action 的分数。**常见的做法是把这个分数当做一个概率，然后按照这个概率去 Sample，从而随机决定要采取哪一个 Action**。比如上图中，“向左”得到 0.7 分，那就有 70% 的几率采取这个 Action。采取 Sample 这种思路的好处是机器的每一次所采取的行为会略有不同，不至于太死板。比如你剪刀石头布时，总出石头也会被打爆。

#### :footprints: Step 2：Define “Loss”

在 RL 里面，loss 长什么样呢？我们先看一下互动的过程。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630193027037.png" alt="image-20220630193027037"  />

+ 初始游戏画面 Observation $s_1$ 输给 Actor，采取 Action $a_1$，得到 Reward $r_1$，并产生 Observation $s_2$，继续刚刚的过程。

不断刚刚的过程直到机器采取某个 Action 后游戏结束了，那从游戏开始到结束的这整个过程称为一个 <mark>Episode</mark>。整个游戏过程所有得到的 Reward 累加称为 <mark>Total Reward</mark>，也称为 <mark>Return</mark>。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630193645220.png" alt="image-20220630193645220" style="zoom:80%;" /></center>

这里目标是 Total Reward 越大越好，但 loss 是越小越好，所以在 RL 的情景下，我们可以把 Total Reward 取负号当做我们的 loss。

#### :footprints: Step 3：Optimization

Actor 与 Environment 互动的过程再用图表示一次如下：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630194224430.png" alt="image-20220630194224430" style="zoom:88%;" />

$s$ 与 $a$ 形成的 sequence $s_1 \ a_1 \ s_2 \ a_2 \ s_3 \dots$ 叫做 <mark>Trajectory</mark>，也记作 $\tau$。

**Reward $r_i$ 通过 Observation $s_i$ 和 Action $a_i$ 计算得到**：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630194633904.png" alt="image-20220630194633904"  />

**整个 Optimization 的过程就是找一个 Network 的参数，让产生出来的 Return $R$ 越大越好**。乍看起来没什么难的，但 **RL 困难的地方在于，这不是一个一般的 Optimization 问题**，因为 Environment 有很多问题导致它跟一般的 Network Training 不太一样。

+ 第一个问题是，Actor 的 output 具有随机性。因为其输出的 Action 是 sample 产生的，如果把整个 Environment、Actor 和  Reward 合起来当成一个巨大的 network 来看待，那这个 network 可不一般，它里面的某一层 layer 每次产生的结果是不一样的。
+ 另一个更大的问题是，你的 Environment 和 Reward 根本就是 network，他们只是一个黑盒子而已，你根本不知道里面发生了什么事。刚刚所说的 Reward 是明确的一条规则，但更麻烦的是在一些 RL 问题中，Reward 与 Env 都是具有随机性的。比如在电玩的应用中，同样的 Action，游戏机到底给你怎样的回应是有乱数的。

目前一般的 gradient descent 还无法训练这个 network 来找出 Actor 来最大化 Return。所以 **RL 真正难点在于怎么解这个 Optimization 问题**。这就是 RL 跟一般的 ML 不一样的地方。

但我们还是可以把 RL 看成三个阶段，只是 maximize reward 时跟以前的方法有点不一样。

