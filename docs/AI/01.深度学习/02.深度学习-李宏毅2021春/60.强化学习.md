---
title: 强化学习
date: 2022-06-30 16:39:22
permalink: /pages/lhy/RL/
categories:
  - AI
  - 深度学习
  - 深度学习-李宏毅2021春
tags:
  - 
---



之前所讲的技术基本上都是基于 Supervised Learning，它们的数据都有一个 label，但在 RL 里面就是要面对另一个问题：**机器当给我们一个 input 的时候，我们不知道最佳的 output 应该是什么**。比如下围棋，面对一个盘势，怎样的下一步是最好的答案是不知道的（尽管一些棋谱中能给出较好的答案），**在这个你不知道正确答案是什么的情况下，往往就是 RL 可以派上用场的时候**。

但是 RL 在学习时，机器也不是一无所知的，我们虽然不知道正确的答案是什么，但机器会知道什么是好，什么是不好，机器会与环境互动，得到一个叫做 reward 的东西。藉由知道什么样的输出是好的，什么是不好的，机器还是可以学出一个模型。

本章的 Outline：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630170307941.png" alt="image-20220630170307941" style="zoom:67%;" /></center>

我们想说的是 RL 也跟 Machine Learning 一样也是三个步骤，具有相同的框架，不要觉得难学。

## 1. What is RL?

### 1.1 相关概念

我们已经说了 Machine Learning 就是找一个 function，RL 同样也是如此。

在 RL 里面，会有一个 <mark>Actor</mark>，还有一个 <mark>Environment</mark>，这个 **Actor 与 Environment 会进行互动**：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630170736614.png" alt="image-20220630170736614" style="zoom: 85%;" /></center>

+ Environment 会给 Actor 一个 Observation 作为输入；
+ Actor 看到 Observation 后会有一个输出 Action，这个 Action 会去影响 Environment；
+ Actor 采取 Action 后，Environment 会给予一个新的 Observation；

这里的 Actor 本身就是一个 function，是我们所要找的 function，其输入是 Environment 给它的 Observation，输出是这个 Actor 要采取的 Action，在这个互动过程中，Environment 会不断地给 Actor 一些 Reward，来告诉它说这个 Action 是好的还是不好的。**要找的 Actor 这个 function 就是最大化最终得到的 Reward 的总和**。

### 1.2 Example: Playing Video Game

拿 Space Invader 这个简单的小游戏来作为例子。最早的几篇 RL 的论文都是让机器去玩 Space Invader 这个游戏。

> Space Invader：
>
> <img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630185529191.png" alt="image-20220630185529191" style="zoom: 88%;" />
>
> + 要操控的是下面的绿色太空梭，可以采取的 Action 有三个：左移、右移和开火，要做的就是杀掉画面上的外星人。
> + 开火几种黄色的外星人的话，外星人就死掉了。
> + 你前面橙色的东西是防护罩，你不小心打到它也会使它减小，也可以躲在它后面抵挡外星人的攻击。
> + 杀死外星人或者打掉最上面的补给包会奖励 score，这个 score 就是 Environment 给我们的 Reward。
> + 游戏的终止条件：外星人都被杀光或者你的母舰被外星人击中。

如果要用 Actor 去玩 Space Invader：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630190050323.png" alt="image-20220630190050323"  /></center>

Actor 坐在一个人的角度去操控摇杆，Environment 就是游戏的主机，Observation 是游戏的画面，Action 是向左、向右和开火三种可能的行为之一，得到的 score 就是 Reward。游戏画面改变的时候，就代表有了新的 Observation 进来，此时你的 Actor 就会决定采取新的 Action。

我们的目标就是 learn 出一个 Actor，它可以在玩这个游戏时得到的 Reward 总和是最大的。

### 1.3 Example: Learning to play Go

实如果把 RL 拿来玩围棋，那你的 Actor 就是就是 AlphaGo，Environment 就是 AlphaGo 的人类对手。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630191146451.png" alt="image-20220630191146451" style="zoom: 80%;" /></center>

在下围棋里面，Actor 所采取的行为几乎没有办法得到任何 Reward，而是定义说如果赢了就得到 1 分，输了就得到 -1 分。

### 1.4 RL 的三个步骤

课程一开始就说了 Machine Learning 就是三个步骤：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630191659242.png" alt="image-20220630191659242" style="zoom:80%;" />

1. 有一个 function，里面有一些未知的 params，这些未知数是要被找出来的；
2. 定一个 loss function
3. Optimization：想办法找出未知 params 去最小化 loss

其实 RL 也是一样的三个步骤，分别来看一下。

#### :footprints: Step 1：Function with Unknown

这里有未知数的 function 就是 Actor，这个 Actor 就是一个 Network，现在通常叫它 **Policy Network**。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630192153053.png" alt="image-20220630192153053" style="zoom:80%;" />

这个 Network 会给每个可能的 Action 输出一个得分，且这些得分总和为 1：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630192335745.png" alt="image-20220630192335745"  />

至于这个 Network 的架构，可以你自己去设计，它可以是 CNN，也可以是 RNN 甚至是 Transformer 等。

在最后机器在决定采取哪一个 Action 时取决于输出的每一个 Action 的分数。**常见的做法是把这个分数当做一个概率，然后按照这个概率去 Sample，从而随机决定要采取哪一个 Action**。比如上图中，“向左”得到 0.7 分，那就有 70% 的几率采取这个 Action。采取 Sample 这种思路的好处是机器的每一次所采取的行为会略有不同，不至于太死板。比如你剪刀石头布时，总出石头也会被打爆。

#### :footprints: Step 2：Define “Loss”

在 RL 里面，loss 长什么样呢？我们先看一下互动的过程。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630193027037.png" alt="image-20220630193027037"  />

+ 初始游戏画面 Observation $s_1$ 输给 Actor，采取 Action $a_1$，得到 Reward $r_1$，并产生 Observation $s_2$，继续刚刚的过程。

不断刚刚的过程直到机器采取某个 Action 后游戏结束了，那从游戏开始到结束的这整个过程称为一个 <mark>Episode</mark>。整个游戏过程所有得到的 Reward 累加称为 <mark>Total Reward</mark>，也称为 <mark>Return</mark>。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630193645220.png" alt="image-20220630193645220" style="zoom:80%;" /></center>

这里目标是 Total Reward 越大越好，但 loss 是越小越好，所以在 RL 的情景下，我们可以把 Total Reward 取负号当做我们的 loss。

#### :footprints: Step 3：Optimization

Actor 与 Environment 互动的过程再用图表示一次如下：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630194224430.png" alt="image-20220630194224430" style="zoom:88%;" />

$s$ 与 $a$ 形成的 sequence $s_1 \ a_1 \ s_2 \ a_2 \ s_3 \dots$ 叫做 <mark>Trajectory</mark>，也记作 $\tau$。

**Reward $r_i$ 通过 Observation $s_i$ 和 Action $a_i$ 计算得到**：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630194633904.png" alt="image-20220630194633904"  />

**整个 Optimization 的过程就是找一个 Network 的参数，让产生出来的 Return $R$ 越大越好**。乍看起来没什么难的，但 **RL 困难的地方在于，这不是一个一般的 Optimization 问题**，因为 Environment 有很多问题导致它跟一般的 Network Training 不太一样。

+ 第一个问题是，Actor 的 output 具有随机性。因为其输出的 Action 是 sample 产生的，如果把整个 Environment、Actor 和  Reward 合起来当成一个巨大的 network 来看待，那这个 network 可不一般，它里面的某一层 layer 每次产生的结果是不一样的。
+ 另一个更大的问题是，你的 Environment 和 Reward 根本就是 network，他们只是一个黑盒子而已，你根本不知道里面发生了什么事。刚刚所说的 Reward 是明确的一条规则，但更麻烦的是在一些 RL 问题中，Reward 与 Env 都是具有随机性的。比如在电玩的应用中，同样的 Action，游戏机到底给你怎样的回应是有乱数的。

目前一般的 gradient descent 还无法训练这个 network 来找出 Actor 来最大化 Return。所以 **RL 真正难点在于怎么解这个 Optimization 问题**。这就是 RL 跟一般的 ML 不一样的地方。

但我们还是可以把 RL 看成三个阶段，只是 maximize reward 时跟以前的方法有点不一样。

## 2. Policy Gradient

RL 中用来解 Optimization 的一个常用演算法是 <mark>Policy Gradient</mark>。

### 2.1 How to control your actor

在讲 Policy Gradient 之前，我们先来看看怎样操控一个 Actor 的输出，即怎样让一个 Actor 在看到某一个特定 Observation 时采取一个特定的 Action。

这其实可以想成一个分类的问题，比如让 Actor 输入 s，输出是 $\hat a$：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630215326157.png" alt="image-20220630215326157" style="zoom: 80%;" /></center>

假设你希望 Actor 采取 $\hat a$ 这个行为的话，就定一个 loss，这个 loss 等于 Cross-Entropy，然后用它来 train。

但假设你还想让你的 Actor 不要采取某个行为，比如输入 $s'$，不要采取 $\hat a'$，可以这样做：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630220205070.png" alt="image-20220630220205070" style="zoom:80%;" /></center>

这个过程就像在 train 一个 classifier 一样，用于去控制 Actor 的行为，而且这一部分的过程就是 Supervised Learning，等下会看到它与一般的 Supervised Learning 有啥区别。

所以我们要 train 一个 Actor，其实就是需要收集一些训练资料，这个训练资料说希望在 $s_1$ 时采取 $\hat a_1$，希望在 $s_2$ 时不采取 $\hat a_2$。如下图所示：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630220702592.png" alt="image-20220630220702592" style="zoom:80%;" /></center>

甚至还可以更进一步，可以说每一个行为并不是只有好或者不好，而是有程度区别的，有非常好的，有 nice to have 的，有 a little bad 的，有非常差的。所以我们现在给每一个 $s_i$ 和 $\hat a_i$ 的 pair 都对应一个分数，这个分数代表了我们多希望机器在看到 $s_i$ 时去执行 $\hat a_i$ 这个 action。如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630221154046.png" alt="image-20220630221154046" style="zoom:80%;" /></center>

+ 比如说看到 $s_1$ 时我们很期待执行 $\hat a_1$，看到 $s_3$ 时我们也期待执行 $\hat a_3$，但期待程度不如前者那么高。
+ 比如说看到 $s_N$ 时特别不期待执行 $\hat a_N$，而看到 $s_2$ 时虽然也不期待执行 $\hat a_2$，但真执行了伤害也没有很大。

所以我们透过 $A_n$ 可以控制每一个 action 我们有多希望 Actor 去执行，接下来有下面这个 loss 后就一样可以 train 一个 $\theta^*$，从而找到一个符合我们期待的 Actor。

<center> <img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220630221703100.png" alt="image-20220630221703100" style="zoom:80%;" /></center>

接下来的难点就是怎样定出 $A_n$，还有一个问题是怎样产生 $s_i$ 与 $\hat a_i$ 这对 pair，并怎样知道期不期待执行。