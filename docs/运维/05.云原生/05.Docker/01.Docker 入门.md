---
title: Docker 入门
date: 2022-03-21 22:54:45
permalink: /pages/1283bf/
categories:
  - 运维
  - 容器
  - Docker
tags:
  - 
---

## 1. 初识 Docker

Docker 是一个开源的应用容器引擎，基于 Go 语言实现，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。

+ 容器是完全使用沙箱机制，相互隔离
+ 容器性能开销极低

我们基于 CentOS 7 来学习 Docker。

Docker 的架构：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220322153926908.png" alt="image-20220322153926908" style="zoom:80%;" />

+ **镜像**（**Image**）：就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
+ **容器**（**Container**）：<u>镜像和容器的关系，就像是面向对象程序设计中的类和对象一样</u>，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
+ **仓库**（**Repository**）：仓库可看成一个代码控制中心，用来保存镜像。

我们在使用时，一般都会配置国内的镜像加速器。

## 2. Docker 命令

### 2.1 Docker 服务相关命令

+ 启动 docker 服务：`systemctl start docker`
+ 设置开机启动 docker 服务：`systemctl enable docker`
+ 停止 docker 服务：`systemctl stop docker`
+ 重启 docker 服务：`systemctl restart docker`
+ 查看 docker 服务状态：`systemctl status docker`

### 2.2 Docker 镜像相关命令

+ 查看镜像：查看本地所有的镜像

```sh
docker images
docker images -q  # 查看所用镜像的 id
```

+ 搜索镜像：从网络中查找需要的镜像

```sh
docker search 镜像名称
```

+ 拉取镜像：从 Docker 仓库下载镜像到本地，镜像名称格式为 `名称:版本号`，如果版本号不指定则是最新的版本（latest）。 如果不知道镜像版本，可以去 docker hub 搜索对应镜像查看

```sh
docker pull 镜像名称
```

+ 删除镜像：删除本地镜像

```sh
docker rmi 镜像id # 删除指定本地镜像
docker rmi `docker images -q` # 删除所有本地镜像
```

+ rmi：rm images
+ 删除所有本地镜像的命令，是把 `docker images -q` 的执行结果传给 `docker rmi` 从而实现全部删除

### 2.3 Docker 容器相关命令

+ 查看容器

```sh
docker ps # 查看正在运行的容器
docker ps –a # 查看所有容器（包括历史上的）
```

+ 创建并启动容器

```sh
docker run 参数
```

> 参数说明：
>
> + -i：保持容器运行。通常与 -t 同时使用。加入 -it 这两个参数后，容器创建后自动进入容器中，**退出容器后，容器自动关闭**。
> + -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。
> + -d：以**守护（后台）模式**运行容器。创建一个容器在后台运行，需要使用 `docker exec` 进入容器。**退出后，容器不会关闭**。
> + `-it` 创建的容器一般称为交互式容器，`-id` 创建的容器一般称为守护式容器
> + --name：为创建的容器命名。

+ 进入容器

```sh
docker exec 参数  # 退出容器，容器不会关闭
```

+ 停止容器：`docker stop 容器名称`
+ 启动容器：`docker start 容器名称`
+ 删除容器：`docker rm 容器名称`
  + 如果容器是运行状态则删除失败，需要**停止容器后才能删除**
+ 查看容器信息：`docker inspect 容器名称`

## 3. Docker 容器的数据卷

### 3.1 数据卷的概念及作用

> 思考：
>
> + Docker 容器删除后，在容器中产生的数据还在吗？
>
> <img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220322161149691.png" alt="image-20220322161149691" style="zoom: 80%;" />
>
> + Docker 容器和外部机器可以直接交换文件吗？
>
> <img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220322161209577.png" alt="image-20220322161209577" style="zoom:80%;" />
>
> + 容器之间想要进行数据交互？

**数据卷**：数据卷是<u>宿主机中的一个目录或文件</u>，当容器目录和数据卷目录绑定后，对方的修改会立即同步。一个数据卷可以被多个容器同时挂载，一个容器也可以被挂载多个数据卷。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220322161405138.png" alt="image-20220322161405138" style="zoom:80%;" />

数据卷**作用**：容器数据持久化；外部机器和容器间接通信；容器之间数据交换

### 3.2 配置数据卷

创建启动容器时，使用 `-v` 参数来设置数据卷：

```sh
docker run ... -v 宿主机目录(文件):容器内目录(文件) ...
```

::: warning 注意事项

1. 目录必须是绝对路径
2. 如果目录不存在，会自动创建
3. 可以挂载多个数据卷

:::

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220322161748955.png" alt="image-20220322161748955" style="zoom:67%;" />

> 示例：
>
> ```sh
> docker run -it --name=c1 -v /root/data:/root/data_container centos:7 /bin/bash
> ```
>
> + 这条命令启动了一个 Centos 7 的容器，并将宿主机的 `/root/data` 挂载到了容器的 `/root/data_container`
> + `/bin/bash` 可以省略不写

### 3.3 数据卷容器

多容器进行数据交换的方式：

+ 方式 1：多个容器挂载同一数据卷
+ 方式 2：**数据卷容器**

![image-20220322162607595](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220322162607595.png)

+ c3 作为数据卷容器挂载到一个数据卷上，c1、c2 再分别挂载到 c3 上，完成这个操作后，就相当于 c1、c2 也挂载到了这个数据卷上了。这是 c1、c2、c3 都挂载到了同一个数据卷上，之后即便 c3 挂掉了，c1、c2 也能通过这个数据卷进行通信

#### 配置数据卷容器：

1. 创建启动 c3 数据卷容器，使用 `–v` 参数设置数据卷

```sh
docker run –it --name=c3 –v /volume centos:7 /bin/bash 
```

+ 注意这里的 `-v /volume`，这里写的是容器的目录，这样写的话，Docker 会在宿主机上自动帮我们生成一个数据卷目录并挂载上，在宿主机上自动生成的目录可以通过 `docker inspect ...` 命令查看。

2. 启动 c1、c2 容器，使用 `--volumes-from` 参数设置数据卷

```sh
docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash
docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash 
```

+ 这时 c1、c2、c3 都挂载到了同一个数据卷上，并可以相互通信了

::: tip 数据卷总结

1. 数据卷概念：宿主机的一个目录或文件
2. 数据卷作用：容器数据持久化；客户端和容器数据交换；容器间数据交换
3. 数据卷容器：
   + 创建一个容器，挂载一个目录，让其他容器继承自该容器( `--volume-from` )
   + 通过简单方式实现数据卷配置

:::