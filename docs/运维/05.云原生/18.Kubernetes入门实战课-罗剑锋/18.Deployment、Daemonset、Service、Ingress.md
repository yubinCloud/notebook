---
title: Deployment、Daemonset、Service、Ingress
date: 2023-04-23 23:05:18
permalink: /pages/1dc9b1/
categories:
  - 运维
  - 云原生
  - Kubernetes入门实战课-罗剑锋
tags:
  - 
---

## 1. Deployment：让应用永不宕机

### 1.1 为什么需要 Deployment

除了离线业务，另一大类业务就是在线业务。单独的 Pod 使用 containers 可以任意编排容器，它可以保证容器正常工作，但如果 Pod 本身出错了怎么办呢？比如不小心使用 `kubectl delete` 误删了 Pod，或者节点发生了断电故障，那么 Pod 就会消失，对 container 的控制也就无从谈起了。另外，在线业务也远不止单纯启动一个 Pod 那么简单，还有多实例、高可用、版本更新等许多复杂操作，比如我们需要应对突发流量的压力、需要多个应用副本、需要监控应用状态。如果只是使用 Pod，那么就又走回手工管理的老路了。

Kubernetes 处理这种在线业务问题的思路是创建一个新的 API 对象：Deployment，通过对象套对象的方式，让它来管理 Pod。

### 1.2 如何使用 YAML 描述 Deployment

看一下 Deployment 的基本信息：

```bash
$ kubectl api-resources

NAME         SHORTNAMES   APIVERSION   NAMESPACED   KIND
deployments  deploy       apps/v1      true        Deployment
```

可以看出，Deployment的简称是“**deploy**”，它的apiVersion是“**apps/v1**”，kind是“**Deployment**”。所以我们知道它的 YAML 的开头该怎么写了：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: xxx-dep
```

当然了，我们也可以使用如下命令来创建一个 YAML 样板：

```bash
export out="--dry-run=client -o yaml"
kubectl create deploy ngx-dep --image=nginx:alpine $out
```

得到的 Deployment YAML 大概如下所示：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: ngx-dep
  name: ngx-dep

spec:
  replicas: 2
  selector:
    matchLabels:
      app: ngx-dep

  template:
    metadata:
      labels:
        app: ngx-dep
    spec:
      containers:
      - image: nginx:alpine
        name: nginx
```

对比一下 Job/CronJob 可以发现，有许多相同的地方，比如都有 spec、template 字段，template 下面也有一个 Pod，不同的地方是它的 spec 多了 replicas、selector 两个字段，而这两个字段就是 Deployment 实现多实例、高可用等功能的关键所在。

### 1.3 Deployment 的关键字段

#### 1.3.1 replicas 字段

<mark>replicas 字段</mark>：Pod 实例的副本数量。

Kubernetes 会持续监控 Pod 的运行状态，万一有 Pod 发生意外而消失，他就会通过 apiserver、scheduler 等核心组件去选择新的节点，创建出新的 Pod，直到数量与“期望状态”一致。

#### 1.3.2 selector 字段

<mark>selector 字段</mark>，用于“筛选”出要被 Deployment 管理的 Pod 对象。

下属字段“**matchLabels**”定义了Pod对象应该携带的label，它必须和“template”里Pod定义的“labels”完全相同，否则Deployment就会找不到要控制的Pod对象，apiserver也会告诉你YAML格式校验错误无法创建。

这个 `selector` 字段的用法初看起来好像是有点多余，为了保证Deployment成功创建，我们必须在YAML里把label重复写两次：一次是在“ **selector.matchLabels**”，另一次是在“ **template.matadata**”。像在这里，你就要在这两个地方连续写 `app: ngx-dep` ：

```yaml
spec:
  replicas: 2
  selector:
    matchLabels:
      app: ngx-dep

  template:
    metadata:
      labels:
        app: ngx-dep
    ...
```

你也许会产生疑问：为什么要这么麻烦？为什么不能像Job对象一样，直接用“template”里定义好的Pod就行了呢？

这是因为在线业务和离线业务的应用场景差异很大。离线业务中的Pod基本上是一次性的，只与这个业务有关，紧紧地绑定在Job对象里，一般不会被其他对象所使用。而在线业务就要复杂得多了，因为Pod永远在线，除了要在Deployment里部署运行，还可能会被其他的API对象引用来管理，比如负责负载均衡的Service对象。

所以 **Deployment 和 Pod 实际上是一种松散的组合关系，Deployment 实际上并不“持有” Pod 对象，它只是帮助 Pod 对象能够有足够的副本数量运行，仅此而已**。如果像 Job 那样，把 Pod 在模板里“写死”，那么其他的对象再想要去管理这些 Pod 就无能为力了。

Kubernetes采用的是这种“贴标签”的方式，通过在API对象的“metadata”元信息里加各种标签（labels），我们就可以使用类似关系数据库里查询语句的方式，筛选出具有特定标识的那些对象。**通过标签这种设计，Kubernetes就解除了Deployment和模板里Pod的强绑定，把组合关系变成了“弱引用”**。

下图展示了 Deployment 与被他管理的 Pod 的关系：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230425202026.png" alt="20230425202026" style="zoom:75%;" /></center>

### 1.4 用 kubectl 操作 Deployment

写好 Deployment 的 YAML 后，就可以用 `kubectl apply` 来创建对象了：

```bash
kubectl apply -f deploy.yml
```

然后使用 `kubectl get deploy` 来查看 Deployment 的状态：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230425202339.png" alt="20230425202339" style="zoom:75%;" /></center>

- READY表示运行的Pod数量，前面的数字是当前数量，后面的数字是期望数量，所以“2/2”的意思就是要求有两个Pod运行，现在已经启动了两个Pod。
- UP-TO-DATE指的是当前已经更新到最新状态的Pod数量。因为如果要部署的Pod数量很多或者Pod启动比较慢，Deployment完全生效需要一个过程，UP-TO-DATE就表示现在有多少个Pod已经完成了部署，达成了模板里的“期望状态”。
- AVAILABLE要比READY、UP-TO-DATE更进一步，不仅要求已经运行，还必须是健康状态，能够正常对外提供服务，它才是我们最关心的Deployment指标。
- 最后一个AGE就简单了，表示Deployment从创建到现在所经过的时间，也就是运行的时间。

因为 Deployment 管理的是 Pod，所以也可以用 `kubectl get pod` 来查看 Pod 的状态，可以看到，这些被 Deployment 管理的 Pod 自动带上了名字，命名的规则是 Deployment 的名字加上两串随机数：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230425202539.png" alt="20230425202539" style="zoom:75%;" /></center>

这时候如果我们尝试删除某个 Pod，Kubernetes 在 Deployment 的管理下又会很快创建一个新的 Pod 来保证满足期望状态。

**在 Deployment 部署成功后，你还可以使用 `kubectl scale` 来随时调整 Pod 的数量，从而实现应用伸缩**。通过指定 `--replicas` 参数可以指定副本的数量，比如下面的命令将 Nginx 扩容到 5 个：

```bash
kubectl scale --replicas=5 deploy ngx-dep
```

> 注意，kubectl scale 只是临时的措施。

### 1.5 补充：Pod 中 labels 的用法

之前我们通过 `labels` 为对象“贴”了各种“标签”，在使用 `kubectl get` 命令的时候，加上参数 `-l`，使用 `==`、 `!=`、 `in`、 `notin` 的表达式，就能够很容易地用“标签”筛选、过滤出所要查找的对象（有点类似社交媒体的 `#tag` 功能），效果和Deployment里的 `selector` 字段是一样的。

看两个例子，第一条命令找出“app”标签是 `nginx` 的所有Pod，第二条命令找出“app”标签是 `ngx`、 `nginx`、 `ngx-dep` 的所有Pod：

```bash
kubectl get pod -l app=nginx
kubectl get pod -l 'app in (ngx, nginx, ngx-dep)'
```

### 1.6 小结

这一大节学习的 Deployment 对象包装了 Pod，通过添加额外的控制功能实现了应用永不宕机。Pod 只能管理容器，不能管理自身，所以就出现了 Deployment，由它来管理 Pod。

> 学了Deployment这个API对象，我们今后就不应该再使用“裸Pod”了。即使我们只运行一个Pod，也要以Deployment的方式来创建它，虽然它的 `replicas` 字段值是1，但Deployment会保证应用永远在线。

另外，作为Kubernetes里最常用的对象，Deployment的本事还不止这些，它还支持滚动更新、版本回退，自动伸缩等高级功能，这些将在后面学习。

## 2. Daemonset：忠实可靠的看门狗
