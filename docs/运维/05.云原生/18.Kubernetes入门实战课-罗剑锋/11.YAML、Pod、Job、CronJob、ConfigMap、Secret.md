---
title: YAML、Pod、Job、CronJob、ConfigMap、Secret
date: 2023-04-22 21:45:11
permalink: /pages/c76480/
categories:
  - 运维
  - 云原生
  - Kubernetes入门实战课-罗剑锋
tags:
  - 
---

> 参考：[Kubernetes 入门实战课 | 极客时间](https://time.geekbang.org/column/intro/100114501?tab=catalog) 第 11-16 讲

## 1. YAML：Kubernetes 世界里的通用语

### 1.1 声明式与命令式

Dockerfile 属于**命令式**（imperative），告诉了计算机每步怎么做，而 Kubernetes 的 YAML 属于**声明式**（declarative），它告诉了计算机一个目标状态，并让计算机想办法去完成任务。

### 1.2 什么是 YAML

YAML 是 JSON 的超集，即任何合法的 JSON 文档也都是 YAML 文档。但 YAML 语法更简单紧凑：

- 使用空白与缩进表示层次（有点类似Python），可以不使用花括号和方括号。
- 可以使用 `#` 书写注释，比起JSON是很大的改进。
- 对象（字典）的格式与JSON基本相同，但Key不需要使用双引号。
- 数组（列表）是使用 `-` 开头的清单形式（有点类似MarkDown）。
- 表示对象的 `:` 和表示数组的 `-` 后面都必须要有空格。
- 可以使用 `---` 在一个文件里分隔多个YAML对象。

关于 YAML 的知识整理如下图：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230422215537.png" alt="20230422215537" style="zoom:75%;" /></center>

### 1.3 什么是 API 对象

我们需要在 YAML 中声明哪些东西呢？Kubernetes 在理论层面抽象出了很多个概念用来描述系统的管理运维工作，这些概念就叫做 <mark>API 对象</mark>，之前提到的组件 apiserver 的名字也是来源于它。

> 因为apiserver是Kubernetes系统的唯一入口，外部用户和内部组件都必须和它通信，而它采用了HTTP协议的URL资源理念，API风格也用RESTful的GET/POST/DELETE等等，所以，这些概念很自然地就被称为是“API对象”了。

有哪些 API 对象呢？可以使用命令 `kubectl api-resources` 查看当前 k8s 支持的所有对象：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230422215922.png" alt="20230422215922" style="zoom:75%;" /></center>

在输出的“NAME”一栏，就是对象的名字，比如ConfigMap、Pod、Service等等，第二栏“SHORTNAMES”则是这种资源的简写，在我们使用kubectl命令的时候很有用，可以少敲几次键盘，比如Pod可以简写成po，Service可以简写成svc。

在使用kubectl命令的时候，你还可以加上一个参数 `--v=9`，它会显示出详细的命令执行过程，清楚地看到发出的HTTP请求，比如：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230422220054.png" alt="20230422220054" style="zoom:75%;" /></center>

从截图里可以看到，**kubectl 客户端等价于调用了 curl**，向 8443 端口发送了 HTTP GET 请求，URL 是 `/api/v1/namespaces/default/pods`。

目前的Kubernetes 1.23版本有50多种API对象，全面地描述了集群的节点、应用、配置、服务、账号等等信息，apiserver会把它们都存储在数据库etcd里，然后kubelet、scheduler、controller-manager等组件通过apiserver来操作它们，就在API对象这个抽象层次实现了对整个集群的管理。

### 1.4 如何描述 API 对象

之前我们使用 kubectl 运行 nginx 的命令用的是命令式的 `kubectl run`：

```bash
kubectl run ngx --image=nginx:alpine
```

下面看一下如何以 YAML 语言来声明式地在 k8s 中描述并创建 API 对象。在 YAML 中，我们需要说清楚我们的目标状态，让 Kubernetes 自己去决定如何拉取镜像并运行：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: ngx-pod
  labels:
    env: demo
    owner: chrono

spec:
  containers:
  - image: nginx:alpine
    name: ngx
    ports:
    - containerPort: 80
```

可以看出，这里是创建一个 pod，要使用 nginx:alpine 的 image 来创建一个 container，并开放 80 端口，而其他部分就是 k8s 对 API 对象强制的格式要求了。

因为API对象采用标准的 HTTP 协议，为了方便理解，我们可以借鉴一下 HTTP 的报文格式，把 API 对象的描述分成“header”和“body”两部分。

header 包含的是 API 对象的基本信息，有三个字段：

- **apiVersion**：表示操作这种资源的 API 版本号，由于 Kubernetes 的迭代速度很快，不同的版本创建的对象会有差异，为了区分这些版本就需要使用 apiVersion 这个字段，比如 v1、v1alpha1、v1beta1 等等。
- **kind**：表示资源对象的类型，比如 Pod、Node、Job、Service 等。
- **metadata**：表示的是资源的一些元信息，也就是用来标记对象，方便 Kubernetes 管理的一些信息。在上面的示例中有两个元信息：
  - name：给 pod 起了个名字
  - labels：给 pod 贴上一些便于查找的标签，分别是 `env` 和 `owner`。

以上信息都被 kubectl 用于生成 HTTP 请求发给 apiserver，你可以用 `--v=9` 参数在请求的 URL 里看到它们，比如：

```plain
https://192.168.49.2:8443/api/v1/namespaces/default/pods/ngx-pod
```

**header 中的 apiVersion、kind、metadata 这三个字段都是任何对象都必须有的**，而 body 部分则会与对象特定相关，每种对象会有不同的规格定义，在 YAML 里就表现为 `spec` 字段（即 specification），表示我们对对象的“期望状态”（desired status）。

还是来看这个 Pod，它的 spec 里就是一个 `containers` 数组，里面的每个元素又是一个对象，指定了名字、镜像、端口等信息：

```yaml
spec:
  containers:
  - image: nginx:alpine
    name: ngx
    ports:
    - containerPort: 80
```

现在把这些字段综合起来，我们就能够看出，这份 YAML 文档完整地描述了一个类型是 Pod 的 API 对象，要求使用 v1 版本的 API 接口去管理，其他更具体的名称、标签、状态等细节都记录在了 metadata 和 spec 字段等里。

使用 `kubectl apply`、 `kubectl delete`，再加上参数 `-f`，你就可以使用这个 YAML 文件，创建或者删除对象了：

```bash
kubectl apply -f ngx-pod.yml    # 创建 API 对象
kubectl delete -f ngx-pod.yml   # 删除 API 对象
```

Kubernetes 收到这份“声明式”的数据，再根据 HTTP 请求里的 POST/DELETE 等方法，就会自动操作这个资源对象，至于对象在哪个节点上、怎么创建、怎么删除完全不用我们操心。

### 1.5 如何编写 YAML

这么多字段，我们怎样才能编写正确的 YAML 呢？

这个问题的最权威的答案自然是 k8s 的[官方文档](https://kubernetes.io/docs/reference/kubernetes-api/)，API 对象的所有字段都可以在里面找到。但这内容太多，下面介绍一些实用的小技巧。

**第一个技巧**其实前面已经说过了，就是 `kubectl api-resources` 命令，它会显示出资源对象相应的API版本和类型，比如Pod的版本是“v1”，Ingress的版本是“networking.k8s.io/v1”，照着它写绝对不会错。

**第二个技巧**，是命令 `kubectl explain`，它相当于是Kubernetes自带的API文档，会给出对象字段的详细说明，这样我们就不必去网上查找了。比如想要看Pod里的字段该怎么写，就可以这样：

```bash
kubectl explain pod
kubectl explain pod.metadata
kubectl explain pod.spec
kubectl explain pod.spec.containers
```

使用前两个技巧编写 YAML 就基本上没有难度了。

:star: **第三个技巧**就是kubectl的两个特殊参数 `--dry-run=client` 和 `-o yaml`，前者是空运行，后者是生成YAML格式，**结合起来使用就会让 kubectl 不会有实际的创建动作，而只生成 YAML 文件**。例如，想要生成一个Pod的YAML样板示例，可以在 `kubectl run` 后面加上这两个参数：

```bash
kubectl run ngx --image=nginx:alpine --dry-run=client -o yaml
```

就会生成一个绝对正确的 YAML 文件：

```yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: ngx
  name: ngx
spec:
  containers:
  - image: nginx:alpine
    name: ngx
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
```

接下来你要做的，就是查阅对象的说明文档，添加或者删除字段来定制这个 YAML 了。

这个小技巧还可以再进化一下，把这段参数定义成Shell变量（名字任意，比如`$do`/`$go`，这里用的是 `$out`），用起来会更省事，比如：

```bash
export out="--dry-run=client -o yaml"
kubectl run ngx --image=nginx:alpine $out
```

今后除了一些特殊情况，我们都不会再使用 `kubectl run` 这样的命令去直接创建 Pod，而是会编写 YAML，用“声明式”来描述对象，再用 `kubectl apply` 去发布 YAML 来创建对象。

### 1.6 课外小贴士

- Kubernetes 的 AP 版本命名有明确规范，正式版本(GA，Generally available) 是 v1 这样的纯数字，试验性质、不稳定的是 alpha,比较稳定、即将发布的是 beta。
- 因为 Kubernetes 的开发语言是 Go，所以 API 对象字段用的都是 Go 语法规范，例如字段命名遵循“Camel Case”，类型是 boolean、string、[]Object 等。

## 2. Pod：Kubernetes 里最核心的概念

为什么 Kubernetes 不直接使用 container，而是还是再抽象出一个 Pod 对象？

### 2.1 为什么要有 Pod？

Pod 原意是“豌豆荚”，看一下下面这个图片，每一颗豌豆就像一个容器，Pod 就是包含了很多成员的一种结构：

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230422224207.png" alt="20230422224207" style="zoom:55%;" /></center>

容器让进程运行在一个沙盒环境里，但当进入生产环境时，这种隔离性带来了不少麻烦，因为大多数任务都是需要多个进程相互协作来完成。而容器的理念又希望每个 container 里只运行一个进程。为了解决这样多应用联合运行的问题，同时还要不破坏容器的隔离，就需要在容器外面再建立一个“收纳舱”，这就是 Pod 概念的提出。容器正是“豆荚”里那些小小的“豌豆”，你可以在Pod的YAML里看到，“spec.containers”字段其实是一个数组，里面允许定义多个容器。

### 2.2 为什么 Pod 是 Kubernetes 的核心对象
