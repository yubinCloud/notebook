---
title: 实操篇（下）
date: 2022-02-14 16:57:22
permalink: /pages/edf6d9/
categories:
  - 运维
  - Linux
  - 韩顺平 2021 Linux 课程笔记
tags:
  - 
---
## 1. 网络配置

### 1.1 Linux 网络配置原理

假设我们的物理主机在一个教室的局域网内：

 ![image-20220214170223466](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220214170223466.png)

+ Linux 虚拟机和  vmnet8 在一个子网内形成一个网络，可以互通（ping 通）
+ 本机电脑的无线网卡与教室局域网的网管互通，vmnet8 又和无线网卡互通

### 1.2 查看网络 IP 和网关

#### 1.2.1 查看虚拟机 IP

在 Linux 中的 `ifconfig` 可以看到本机的 IP：

```bash {3}
$ ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.220.134  netmask 255.255.255.0  broadcast 192.168.220.255
        inet6 fe80::c84d:947f:c9c3:2aa3  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:f9:c5:14  txqueuelen 1000  (Ethernet)
        RX packets 142  bytes 14858 (14.5 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 130  bytes 17101 (16.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

可以看到 Linux 虚拟机的 IP 为 192.168.220.134。

#### 1.2.2 查看网络编辑器和网关

在 VMware 的**虚拟网络编辑器**中，可以看到 NAT 连接方式下本机的子网 IP：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220214171502174.png" alt="image-20220214171502174" style="zoom: 72%;" />

然后在点击 `NAT 设置` 可以看到网关：

![image-20220214171709983](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220214171709983.png)

#### 1.2.3 查看 Windows 环境中的 VMnet8 网络配置

使用 `ipconfig` 命令：

```powershell
> ipconfig
...
以太网适配器 VMware Network Adapter VMnet8:

   连接特定的 DNS 后缀 . . . . . . . :
   本地链接 IPv6 地址. . . . . . . . : fe80::c823:6a37:c475:ed49%24
   IPv4 地址 . . . . . . . . . . . . : 192.168.220.1
   子网掩码  . . . . . . . . . . . . : 255.255.255.0
   默认网关. . . . . . . . . . . . . :
...
```

### 1.3 ping 测试连通性

`ping 目的主机`：测试当前服务器是否可以连接目的主机

> 测试是否可以连接百度：`ping www.baidu.com`

### 1.4 Linux 网络环境配置

#### 1.4.1 第一种方法：自动获取

登录后，通过界面来设置自动获取 IP。特点：Linux 启动后会自动获取 IP，但**每次自动获取的 IP 地址可能不一样**。

![image-20220214174016538](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220214174016538.png)

#### 1.4.2 第二种方法：指定 IP :star:

直接修改配置文件来指定 IP，并可以连接到外网（程序员推荐）。

配置文件根据网卡不同名字有所区别，但文件路径一致：/etc/sysconfig/network-scripts/，常见的配置文件名有 ifcfg-eth0 或者 ifcfg-ens33，可以通过 ifconfig 查看后缀。

以 ifcfg-ens33 为例，使用 vim 修改此文件 `vim /etc/sysconfig/network-scripts/ifcfg-ens33 `：

```diff
YPE="Ethernet"
PROXY_METHOD="none"
BROWSER_ONLY="no"
- BOOTPROTO="dhcp"
+ BOOTPROTO="static"
DEFROUTE="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_FAILURE_FATAL="no"
IPV6_ADDR_GEN_MODE="stable-privacy"
NAME="ens33"
UUID="1af88ac9-573c-49da-993c-9ab4e6c73159"
DEVICE="ens33"
ONBOOT="yes"
+ IPADDR=192.168.200.130 # 本机 IP 地址
+ NETMASK=255.255.255.0 # 子网掩码
+ GATEWAY=192.168.200.2 # 默认网关
+ DNS1=192.168.200.2 # 域名解析器
```

修改好后并保存。然后进入 VMware 的虚拟网络编辑器，将 NAT 配置中的子网 IP 改为 `192.168.200.0`，将网关 IP 改为 `192.168.200.2`。修改位置可见本文的 1.2.2 节所示。

完成以上操作后，重启网络服务或重启系统生效：

`service network restart`、`reboot`

以上这些操作就是将本文 1.1 节图中的 Linux 虚拟机和 vmnet8 的地址分别改成了 `192.168.200.130` 和 `192.168.200.1`。这时在虚拟机中使用 `ifconfig` 命令可以看到：

```bash {3}
$ ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.200.130  netmask 255.255.255.0  broadcast 192.168.200.255
        inet6 fe80::c84d:947f:c9c3:2aa3  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:f9:c5:14  txqueuelen 1000  (Ethernet)
        RX packets 792  bytes 825124 (805.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 456  bytes 33428 (32.6 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

+ 本机 IP 已经成功改为了 192.168.200.130。

### 1.5 设置主机名和 hosts 映射

#### 1.5.1 设置主机名

为了方便记忆，可以**给 Linux 系统设置主机名**，也可以根据需要修改主机名。

指令 `hostname`：查看主机名

修改文件在 /etc/hostname 指定。修改后重启生效。

#### 1.5.2 设置 hosts 映射

思考：如何通过主机名能够找到（比如 ping）某个 Linux 系统？

**Hosts**：一个记录 IP 和 hostname 之间映射关系的文本文件。

:pencil2: Windows 中，在 `C:\Windows\System32\drivers\etc\hosts` 文件指定即可。

> 案例：`192.168.200.130 hspEdu100`
>
> + 前半部分是 IP 地址，后半部分是其对应的主机名
>
> PS：还有一个常见的案例是 `127.0.0.1 localhost`

:pencil2: Linux 中，在 `/etc/hosts` 文件指定即可。

> 案例：`192.168.200.1 ThinkPad-PC`

### 1.6 应用实例：浏览器解析 `www.baidu.com` 的过程

1. 浏览器**先检查浏览器中有没有该域名解析 IP**，有就先调用这个 IP 完成解析。如果没有，就**再检查 DNS 解析器缓存**，如果有就直接返回 IP 完成解析。这两个缓存可以理解为**本地解析器缓存**。
2. 一般来说，当电脑第一次成功访问某一个网站后，在一定时间内浏览器或 OS 会缓存它的 DNS 解析记录。

```
ipconfig /displaydns  // 查看 DNS 域名解析缓存
ipconfig /flushdns    // 手动清理 DNS 缓存
```

3. 如果本地解析器缓存没有找到对应的映射，就**检查系统中 hosts 文件**中有没有对应的域名 IP 映射，有则完成解析并返回。
4. 如果本地 DNS 解析器缓存和 hosts 文件都没能解析出对应的 IP，则到域名服务 DNS 进行解析域。

## 2. 进程管理

### 2.1 基本介绍

在 Linux 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号，即进程号，PID。

每个进程都可能以两种方式存在的：前台与后台。所谓**前台进程**就是用户目前的屏幕上可以进行操作的。**后台进程**则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。

**一般系统的服务都是以后台进程的方式存在**，而且都会常驻在系统中，直到关机才才结束。

### 2.2 ps 显示系统执行的进程

#### 2.2.1 ps 命令

`ps` 命令是 Process Status 的缩写，用来列出系统中**当前正在运行**的那些进程，就是执行 ps 命令的那个时刻的那些进程的**快照**。

> ps 查看的结果不是动态连续的，如果想要动态的显示进程信息，就可以使用 top、htop 命令。

```bash
$ ps
   PID TTY          TIME CMD
  2149 pts/0    00:00:00 zsh
  2228 pts/0    00:00:00 ps
```

+ ps 显示的信息字段：
  + PID：进程识别号
  + **TTY**：终端机号
  + TIME：进程使用 CPU 的总时间
  + CMD：正在执行的命令或进程名

+ 常用选项：
  + -a：显示当前终端的所有进程信息
  + -u：以用户的格式显示进程信息
  + -x：显示后台进程运行的参数

> 常见情况下是 `ps -aux | more` 三个选项一块用，并分页查看

#### 2.2.2 ps 详解

输入 `ps -aux|more` 后可以看到：

![image-20220215124549030](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220215124549030.png)

+ USER：用户名称
+ %CPU：进程占用 CPU 百分比
+ %MEM：进程占用物理内存的百分比
+ VSZ：进程占用的虚拟内存大小（单位 KB）
+ RSS：进程占用的物理内存大小（单位 KB）
+ TTY：终端名称，缩写
+ STAT：进程状态。S 睡眠，s 表示该进程是会话的先导进程，N 表示该进程拥有比普通优先级更低的优先级，R 正在运行，D 短期等待，Z 僵死进程，T 被跟踪或被停止等
+ START：进程的启动时间
+ TIME：进程使用 CPU 的总时间
+ COMMAND：启动进程所用的命令和参数，如果过长会被截断显示

但是直接 ps 会显示太多的进程了，**如果想看有没有某个进程，可以用 `ps -aux|grep xxx`**。

#### 2.2.3 应用实例

要求：以全格式显示当前所有的进程

`ps -ef`：以全格式查看系统上的运行的所有进程 【常用】

+ -e：显示运行在系统上的所有进程
+ -f：全格式，即扩展显示输出

![image-20220215130330330](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220215130330330.png)

+ C 字段是 CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行的优先级会降低；数值越小，表明进程是 IO 密集型运算，执行优先级会提高。
+ **PPID：父进程的 PID**

### 2.3 kill 和 killall

> 这部分在 CSAPP 中有讲解

kill 命令会向操作系统内核**发送一个信号**（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作。**预设的信息为 SIGTERM(15)，可将指定程序终止**。

这里只讲用 kill 命令终止进程：

+ `kill [选项] 进程号`：终止进程

+ `killall 进程名称`：通过进程名称杀死进程（及其子进程），也**支持通配符**，这在系统因负载过大而变得很慢时很有用。

常用选项：

- -9：表示强迫进程立即终止

#### :pen: 案例 1：踢掉某个非法用户

我们先让用户 fox 登录，然后 root 下输入 `ps -aux | grep sshd`，可以看到：

```bash {5}
$ ps -aux | grep sshd
root       1462  0.0  0.2 112984  4324 ?        Ss   12:24   0:00 /usr/sbin/sshd -D
root       2140  0.0  0.2 161072  5584 ?        Ss   12:24   0:00 sshd: yubin [priv]
yubin      2148  0.0  0.1 161072  2556 ?        S    12:24   0:00 sshd: yubin@pts/0
root       2900  0.3  0.2 161080  5584 ?        Ss   13:22   0:00 sshd: fox [priv]
fox        2907  0.0  0.1 161080  2560 ?        S    13:22   0:00 sshd: fox@pts/1
root       3006  0.0  0.0 112828   984 pts/0    S+   13:23   0:00 grep --color=auto sshd
```

可以看到 fox 登录的时候，是通过进程 2900 登录的，于是我们 `kill 2900` 后可以看到 fox 用户被踢掉。

#### :pen: 案例 2：终止远程登录服务 sshd，并在适当时候再次重启 sshd 服务

类似于案例1，在案例 1 的输出中可以看到，sshd 服务（`/usr/sbin/sshd -D` 启动的进程）的进程号是 1462，所以 `kill 1462` 即可终止 sshd 服务。终止后会发现别的用户无法再远程登录。

终止 sshd 后，通过 `/bin/systemctl start sshd.service` 即可重启该服务。

#### :pen: 案例 3：终止多个 gedit

先在图形化界面下用 gedit 打开多个文本编辑页面，然后 `killall gedit` 即可一次性关闭全部。

#### :pen: 案例 4：强制杀掉一个终端

先开一个 bash 终端，然后 `ps -aux|grep bash` 即可看到所有的 bash 进程，找到要杀死的 bash 进程号 xxxx，然后使用  `kill -9 bash对应的进程号` 即可杀死。

+ 加上 -9 选项是因为如果不加的话，系统会认为由于要被 kill 的 bash 正在工作，而认为你的 kill 是一个误操作，从而置之不理，只有加了 -9 才会强制杀掉。

### 2.4 pstree 查看进程树

`pstree [选项]`：可以更加直观的来看进程信息。

+ -p：显示进程的 PID
+ -u：显示进程的所属用户

> 案例：
>
> - pstree -p：树状的形式显示进程的 PID。
> - pstree -u：树状的形式显示进程的用户