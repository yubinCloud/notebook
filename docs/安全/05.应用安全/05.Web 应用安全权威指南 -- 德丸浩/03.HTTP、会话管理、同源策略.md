---
title: HTTP、会话管理、同源策略
date: 2022-07-12 21:23:49
permalink: /pages/security/WASBOOK/basic/
categories:
  - 安全
  - 应用安全
  - Web 应用安全权威指南 -- 德丸浩
tags:
  - 
---

## 1. HTTP 与会话管理

### 1.1 HTTP

略过一些基础知识。

#### :pen: 百分号编码

百分号编码（Percent-Encoding）也被称为 **URL 编码**。中文和特殊符号等不能直接用于 URL，如果要将它们用在 URL 上的话就需要经过百分号编码。百分号编码是将字符以字节为单位转换成 `%xx` 的形式，其中 xx 是该字节的十六进制表示。

#### :pen: Referer

HTTP 请求消息中有时含有 <mark>Referer 头信息</mark>，它能告诉我们当前请求是从哪个页面链接过来的，值就是那个页面的 URL。除了通过 form 元素发送的请求，a 元素生成的链接或 img 元素的图像等也会产生 Referer 头信息。

Referer 头信息有时是提升安全性的帮手，有时却能成为问题之源。

+ <u>Referer 有益的一面体现在</u>，当我们为了确保安全性而主动检验 Referer 头信息时，通过查看 Referer，能够确认应用程序的跳转是否跟预期一样。但是，同其他头信息一样，Referer 也能由访问者本人通过 Fiddler 之类的工具修改，或者被浏览器插件和其他安全方面的软件修改或删除，所以未必会正确显示链接的来源。
+ <u>当 URL 中包含敏感信息时，Referer 就可能会引发安全问题</u>。比如：URL 中包含的会话 ID 通过 Referer 泄漏给外界，从而使自己的身份被他人恶意胃名顶替就是一个典型的案例。

**URL 中包含重要信息时，就有被 Referer 头信息泄密的风险**。

#### :pen: GET 与 POST 的使用区别

RFC 2616 记载了区别两者的注意点：

+ GET 方法仅用于查询（获取资源）
+ GET 方法被认为没有副作用
+ GET 发送敏感数据时应使用 POST 方法（因为 URL 中的参数可能经由 Referer 泄露）

#### :pen: 篡改 HTTP 信息

在 Fiddler 的 Rules 菜单中，选择 “Automatic Breakpoints” - “Before Request”，此时点击“注册”按钮，Fiddler 就能截取到浏览器的请求消息，此时还未发送给服务器，我们可以在 Fiddler 中编辑修改此请求。

所以说，**浏览器发送的值都能够被变更**。

### 1.2 无状态的 HTTP 认证

HTTP 支持认证功能，可以根据实现方式细分为 Basic 认证、NTLM 认证和 Digest 认证等。正如 HTTP 无状态，HTTP 认证也是无状态的。

#### 1.2.1 Basic 认证

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220712220327041.png" alt="image-20220712220327041" style="zoom: 60%;" /></center>

Basic 认证下，当浏览器请求一个需要认证的网页时，服务器会先向浏览器返回“401 Unauthorized(未认证)”状态码。浏览器收到此状态码后，会显示要求输入 ID 和密码的画面，然后再将输入的 ID 和密码添加到请求信息中，再次向服务器发送。

在认证失败时，Basic 认证的规定会输出以下头信息：

```http
HTTP/1.1 401 Authorization Required
WWW-Authenticate: Basic realm="xxxxx"
```

在用户提交 ID 和密码时，HTTP 请求消息会附带如下 Authorization 信息：

```
Authorization: Basic dXNlcjE6cGFzczE=
```

Basic 后面的字符串内容是 ID 和密码以冒号相隔组成的字符串，再经过 Base64 编码后的结果。

实际上，之后的每次请求都会发送 ID 和密码，认证状态并没有被保存。因此 Basic 认证也是无状态的。

::: note 认证与授权

+ **认证**：通过一些方法手段来确认操作者确实是其本人；
+ **授权**：授予已经通过认证的用户一些权限。

:::

### 1.3 Cookie 与会话管理

为了实现会话管理，HTTP 引入了名为 Cookie 的机制。Cookie 相当于服务器下达给浏览器的命令，让其记住发送给它的“名称=变量”这种格式的值。

Cookie 可以设置有效期限，**没有设置有效期限的 Cookie 会在浏览器被关闭之前一直有效**。

由于 Cookie 只能记忆少量数据，所以可以采用 Session 技术的会话管理，这时只在 Cookie 中保存类似于“受理编号”的会话 ID，实际对应的值则保存在服务器端。

这个会话 ID 很有讲究，如果采用连续的号，则会产生下面的情况：

> :smiling_imp: 恶人：Hi
>
> :blush: 柜员：您的受理编号为 006，请提供银行卡号和密码。
>
> 恶人将受理编号减去 1 变成 005，假设 005 的顾客已经通过了身份核实…
>
>  :smiling_imp: 恶人：受理编号 005，请向卡号 99999 转账 5 万元。
>
> :blush: 柜员：转账完毕！

仅仅改变了受理编号，就能成功使用他人的账户进行转账。

由此可见，会话 ID 不能使用连续的数字，而应当使用位数足够长的随机数。**会话 ID 需要满足如下需求**：

1. 会话 ID 不能被第三方推测
2. 会话 ID 不能被第三方劫持
3. 会话 ID 不能向第三方泄漏

面对需求 1，**在实际开发中，会话 ID 不要自己去生成，而是使用开发工具提供生成的会话 ID**。

面对需求 2 说的会话 ID 不能被劫持，我们来看看刚刚可能产生的安全问题：

> :smiling_imp: 恶人：你好。
>
> :blush: 柜员：您的受理编号为9466ir8 fgmmk1gn6raeo7ne71。请提供您的银行卡号和密码。
>
> :smiling_imp: 恶人暂时离开柜台并等待来客。有顾客进入银行时，恶人冒充银行柜员向顾客搭话。
>
> :smiling_imp: 恶人：您的受理编号为9466ir8fgmmk1gn6raeo7ne71。
>
> :boy: 顾客：知道了。
>
>顾客走向柜台。
>
> :boy: 顾客：我的受理编号为9466ir8fgmmk1gn6raeo7ne71。
>
> :blush: 柜员：请提供您的银行卡号和密码。
>
> :boy: 顾客：受理编号为9466ir8fgmmk1gn6raeo7ne71。卡号为12345，密码为9876，请确认。
>
> :blush: 柜员：身份核实完毕。
>
>顾客执行完身份确认后恶人也走向了柜台。
>
> :smiling_imp: 恶人：受理编号为9466ir8fgmmk1gn6raeo7ne71。请向卡号99999的账户转账3万元。柜员：转账完毕。

像这样，恶人（攻击者）劫持正规用户的会话 ID 来进行攻击的手法被称为<mark>会话固定攻击</mark>（**Session Fixation Attack**）。

我们可以尝试修复此安全隐患：

>有顾客进入银行时，恶人冒充银行柜员向顾客搭话。
>
> :smiling_imp: 恶人：您的受理编号为9466ir8fgmmk1gn6raeo7ne71。
>
> :boy: 顾客：知道了。
>
>顾客走向柜台。
>
> :boy: 顾客：我的受理编号为9466ir8fgmmk1gn6raeo7ne71。
>
> :blush: 柜员：请提供您的银行卡号和密码。
>
> :boy: 顾客：受理编号为9466ir8fgmmk1gn6raeo7ne71。卡号为12345，密码为9876，请确认。
>
> :blush: 柜员：身份核实完毕。您新的受理编号为eut1j15a058pm8gapa871937h6。
>
>顾客执行完本人身份确认后恶人也走向了柜台。
>
> :smiling_imp: 恶人：受理编号为9466ir8fgmmk1gn6raeo7ne71。请向卡号99999的账户转账3万元。
>
> :blush: 柜员：您还没有进行身份核实。请提供您的银行卡号和密码。

这里修复的要点是：**认证后改变会话 ID**。

继续看需求 3 的防止会话 ID 泄露。其泄露的原因有如下几种：

+ 发行 Cookie 时的属性指定有问题（稍后讲解）
+ 会话 ID 在网络上被监听
+ 通过跨站脚本漏洞等应用中的安全隐患被泄漏
+ 由于 PHP 或浏览器等平台存在安全隐患而被泄漏
+ 会话 ID 保存在 URL 中的情况下，会通过 Referer 消息头泄漏

### 1.4 Cookie 属性

生成 Cookie 时可以设置很多属性。主要属性如下：

|   属性   |                     含义                      |
| :------: | :-------------------------------------------: |
|  Domain  |          Cookie 发送对象服务器的域名          |
|   Path   |          Cookie 发送对象 URL 的路径           |
| Expires  | Cookie 的有效期限，未指定则表示至浏览器关闭。 |
|  Secure  |     仅在 SSL 加密的情况下可以发送 Cookie      |
| HttpOnly | 指定了此属性的 Cookie 不能被 JavaScript 访问  |

#### 1.4.1 Domain 属性

Cookie 在默认情况下只能被发送到与其绑定的服务器，虽然这是安全的，但有时也需要能向多个服务器发送的 Cookie，这时就需要用到 Domain 属性。

如下图，当浏览器中的 Cookie 属性为 `Domain=example.jp` 时，上面两个服务器可以访问成功，但 a.example.com 会因为域名不用而没有发送。

<center><img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220712230530144.png" alt="image-20220712230530144" style="zoom:58%;" /></center>

假如 a.example.jp 的服务器在 Set-Cookie 中指定了 `Domain=example.com`，此 Cookie 也会被浏览器忽略，因为 Cookie 中指定不同的域名可能遭受会话固定攻击，所以 **Cookie 是不能指定不同域名的**。

未指定 Domain 时，Cookie 只能被发送至生成它的服务器。在原则上，**尽量不要设置 Cookie 的 Domain 属性**。

#### 1.4.2 Cookie 的 Secure 属性

未设置时 Cookie 则无关是否为 SSL 传输，都会被发送；而设置后仅在 SSL 传输的情况下才会被发送。

#### 1.4.3 Cookie 的 HttpOnly 属性

**设置了 HttpOnly 属性后，JavaScript就不能访问该 Cookie 了**。恶意使用 JawaScript 进行跨站脚本攻击从而取得 Cookie信息，是窃取 Cookie 中会话 ID 的典型案例。而 Cookie 中设置了 HttpOnly 属性后，就能防止 JavaScript 窃取Cookie 信息。

后面专门讲述跨站脚本攻击也会提到，其实设置了 HttpOnly 属性也无法彻底抵御跨站脚本攻击，但是能加大攻击的难度，而设置 HttpOnly 属性通常不会带来环处，所以**应当时常给 Cookie 加上 HttpOnly 属性**。