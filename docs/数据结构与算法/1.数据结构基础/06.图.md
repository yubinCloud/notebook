---
title: 图
date: 2021-11-06 18:04:14
permalink: /pages/77426d/
categories:
  - 数据结构与算法
tags:
  - 数据结构
---

## 1. 图的基本概念



## 2. 图的存储



## 3. 图的遍历

<mark>图的遍历</mark>是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次**且仅访问一次**。

### 3.1 广度优先搜索（BFS）

![image-20211106181601107](../images/image-20211106181601107.png)

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。

广度优先搜索的伪代码（用邻接矩阵来实现）：

```c++
bool visited[MAX_VEXTEX_NUM];

void BFSTraverse(Graph G) {
    Queue Q;
    for (i = 0; i < G.vexNum; i++) {
        visited[i] = false;
    }
    for (i = 0; i < G.vexNum; i++) {
        if (!visited[i])
            BFS(G, i);
    }
}

void BFS(Graph G, int v) {
    visit(v);
    visited[v] = true;
    Q.offer(v);
    
    while (!Q.isEmpty()) {
        v = Q.poll();
        for (int x: v的所有邻居) {
            if (visited[x])
                continue;
            visit(x);
            visited[x] = true;
            Q.offer(x);
        }
    }
}
```

+ 队列 `Q` 存储当前已经访问但还没有访问其邻居的节点，其中记忆的顶点要被用来访问其下一层顶点。
+ `visited` 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 `visited`。这里 `visited` 也可以用 `Set` 来实现。

