---
title: 建造者模式
date: 2024-03-03 20:01:00
permalink: /pages/desgin-pattern/builder/
categories:
  - 计算机专业课
  - 设计模式
tags:
  - 
---

## 1. 概述

将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240303203730621.png" alt="image-20240303203730621" style="zoom:80%;" />

- **分离了部件的构造（由 Builder 来负责）和装配（由 Director 负责）**。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。
- 实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是**实现了构建算法、装配算法的解耦，实现了更好的复用**。
- 建造者模式可以将部件和其组装过程分开，**一步一步创建一个复杂的对象**。用户只需要指定复杂对象的类型就可以得到该对象，而**无须知道其内部的具体构造细节**。

## 2. 结构

建造者模式包含如下角色：

- **抽象建造者类**（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 
- **具体建造者类**（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 

- **产品类**（Product）：要创建的复杂对象。

- **指挥者类**（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 

类图说明：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240303205055769.png" alt="image-20240303205055769" style="zoom: 80%;" />

## 3. 实例

生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。

这里 `Bike` 是产品，包含车架，车座等组件；`Builder` 是抽象建造者，`MobikeBuilder` 和 `OfoBuilder` 是具体的建造者；`Director` 是指挥者。类图如下：

<img src="https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240303205351973.png" alt="image-20240303205351973"  />

具体代码如下：

```java
//自行车类
@Data
public class Bike {
    private String frame;
    private String seat;
}

// 抽象 builder 类
public abstract class Builder {

    protected Bike mBike = new Bike();

    public abstract void buildFrame();
    public abstract void buildSeat();
    public abstract Bike createBike();
}

//摩拜单车Builder类
public class MobikeBuilder extends Builder {

    @Override
    public void buildFrame() {
        mBike.setFrame("铝合金车架");
    }

    @Override
    public void buildSeat() {
        mBike.setSeat("真皮车座");
    }

    @Override
    public Bike createBike() {
        return mBike;
    }
}

//ofo单车Builder类
public class OfoBuilder extends Builder {

    @Override
    public void buildFrame() {
        mBike.setFrame("碳纤维车架");
    }

    @Override
    public void buildSeat() {
        mBike.setSeat("橡胶车座");
    }

    @Override
    public Bike createBike() {
        return mBike;
    }
}

//指挥者类
public class Director {
    private Builder mBuilder;

    public Director(Builder builder) {
        mBuilder = builder;
    }

    public Bike construct() {
        mBuilder.buildFrame();
        mBuilder.buildSeat();
        return mBuilder.createBike();
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        showBike(new OfoBuilder());
        showBike(new MobikeBuilder());
    }
    private static void showBike(Builder builder) {
        Director director = new Director(builder);
        Bike bike = director.construct();
        System.out.println(bike.getFrame());
        System.out.println(bike.getSeat());
    }
}
```

上面示例是 Builder模式的常规用法，**指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类**。

但在有些情况下需要简化系统结构，就可以吧指挥者类和抽象建造者进行结合：

```java
// 抽象 builder 类
public abstract class Builder {

    protected Bike mBike = new Bike();

    public abstract void buildFrame();
    public abstract void buildSeat();
    public abstract Bike createBike();
    
    public Bike construct() {
        this.buildFrame();
        this.BuildSeat();
        return this.createBike();
    }
}
```

虽然这样确实简化了系统结构，但同时也加重了抽象造者类的职责，也不是太符合单一职责原则，如果`construct()` 过于复杂，建议还是封装到 Director 中。

## 4. 优缺点分析

### 4.1 优点

- 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
- 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
- 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
- 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。

### 4.2 缺点

建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，**如果产品之间的差异性很大，则不适合使用建造者模式**，因此其使用范围受到一定的限制。

## 5. 适用场景

建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用：

- 创建的对象较复杂，**由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的**。
- **创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式**，即产品的构建过程和最终的表示是独立的。

## 6. 模式扩展  -- 类的 Builder

在开发中有一个常用的使用方式，就是当一个类构造器需要传入很多参数时（比如成百上千的参数），那么创建这个类实例的代码将会很复杂，此时就可以用类的 Builder 进行改造。

示例如下：

```java
public class Phone {

    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    private Phone(Builder builder) {
        cpu = builder.cpu;
        screen = builder.screen;
        memory = builder.memory;
        mainboard = builder.mainboard;
    }

    public static final class Builder {
        private String cpu;
        private String screen;
        private String memory;
        private String mainboard;

        public Builder() {}

        public Builder cpu(String val) {
            cpu = val;
            return this;
        }
        public Builder screen(String val) {
            screen = val;
            return this;
        }
        public Builder memory(String val) {
            memory = val;
            return this;
        }
        public Builder mainboard(String val) {
            mainboard = val;
            return this;
        }
        public Phone build() {
            return new Phone(this);}
    }
    @Override
    public String toString() {
        return "Phone{" +
                "cpu='" + cpu + '\'' +
                ", screen='" + screen + '\'' +
                ", memory='" + memory + '\'' +
                ", mainboard='" + mainboard + '\'' +
                '}';
    }
}

public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone.Builder()
                .cpu("intel")
                .mainboard("华硕")
                .memory("金士顿")
                .screen("三星")
                .build();
        System.out.println(phone);
    }
}
```

关键是 `Phone` 类的静态内部类 `Builder`。

## 7. 创建者模式对比

### 7.1 工厂模式 VS 建造者模式

- 工厂方法模式注重的是整体对象的创建方式；
- 建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。

> 我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。

### 7.2 抽象工厂模式 VS 建造者模式

- 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。
- 建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。

> 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。