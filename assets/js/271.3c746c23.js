(window.webpackJsonp=window.webpackJsonp||[]).push([[271],{1023:function(s,t,a){"use strict";a.r(t);var n=a(22),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("blockquote",[a("p",[s._v("参考："),a("a",{attrs:{href:"https://time.geekbang.org/column/article/71806",target:"_blank",rel:"noopener noreferrer"}},[s._v("12 为什么我的MySQL会“抖”一下？| 极客时间"),a("OutboundLink")],1)])]),s._v(" "),a("h2",{attrs:{id:"_1-为什么我的-mysql-会抖一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么我的-mysql-会抖一下"}},[s._v("#")]),s._v(" 1. 为什么我的 MySQL 会抖一下？")]),s._v(" "),a("p",[s._v("平时的工作中，不知道你有没有遇到过这样的场景，一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。看上去，这就像是数据库“抖”了一下。今天，我们就一起来看一看这是什么原因。")]),s._v(" "),a("h3",{attrs:{id:"_1-1-你的-sql-语句为什么变-慢-了"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-你的-sql-语句为什么变-慢-了"}},[s._v("#")]),s._v(" 1.1 你的 SQL 语句为什么变“慢”了")]),s._v(" "),a("p",[s._v("之前我们知道，InnoDB 在处理更新语句时，只做了写 redo log 这一个磁盘操作，并在更新内存写完 redo log 后就返回给客户端，表示本次更新成功。")]),s._v(" "),a("blockquote",[a("p",[s._v("做下类比的话，酒店掌柜记账的账本是数据文件，记账用的粉板是 redo log，掌柜的记忆就是内存。")])]),s._v(" "),a("p",[s._v("掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 "),a("strong",[s._v("flush")]),s._v("。")]),s._v(" "),a("p",[s._v("当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“"),a("mark",[s._v("脏页")]),s._v("”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“"),a("mark",[s._v("干净页")]),s._v("”。不论是脏页还是干净页，都在内存中。")]),s._v(" "),a("p",[s._v("由此你可以不难想象，我们平时执行很快的更新操作，其实就是在写内存和写 redo log，而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。")]),s._v(" "),a("p",[s._v("那什么情况下会做 flush 操作呢？：")]),s._v(" "),a("ol",[a("li",[a("strong",[s._v("第一种场景是")]),s._v("："),a("u",[s._v("粉板满了，记不下了")]),s._v("。也就是 InnoDB 的 redo log 满了，即便再来新请求，也必须先 flush 一下，把 checkpoint 向前推进，从而让 redo log 可以留出空间继续写。我们将 redo log 画成环形，如下图：")])]),s._v(" "),a("center",[a("img",{staticStyle:{zoom:"75%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230601223031.png",alt:"20230601223031"}})]),s._v(" "),a("center",[a("font",{attrs:{color:"grey"}},[s._v("redo log 状态图：通过将 checkpoint 从 CP 推进到 CP‘，也就是将两点之间绿色部分对应的脏页 flush 到磁盘上，那 write pos 到 CP’ 之间的部分就是可以继续再写入的 redo log 的区域了")])],1),s._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[s._v("第二种场景是")]),s._v("："),a("u",[s._v("这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去")]),s._v("。这种场景，对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。")])]),s._v(" "),a("p",[s._v("你一定会说，这时候难道不能直接把内存淘汰掉，下次需要请求的时候，从磁盘读入数据页，然后拿 redo log 出来应用不就行了？这里其实是从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：")]),s._v(" "),a("ul",[a("li",[s._v("一种是内存里存在，内存里就肯定是正确的结果，直接返回；")]),s._v(" "),a("li",[s._v("另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。")])]),s._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[s._v("第三种场景是")]),s._v("，"),a("u",[s._v("生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本")]),s._v("。这种场景，对应的就是 MySQL 认为系统“空闲”的时候。当然，MySQL“这家酒店”的生意好起来可是会很快就能把粉板记满的，所以“掌柜”要合理地安排时间，即使是“生意好”的时候，也要见缝插针地找时间，"),a("strong",[s._v("只要有机会就 flush 一点")]),s._v("。")]),s._v(" "),a("li",[a("strong",[s._v("第四种场景是")]),s._v("，"),a("u",[s._v("年底了咸亨酒店要关门几天，需要把账结清一下，这样明年重新开张就能对着账本明确账目情况了")]),s._v("。这种场景，对应的就是 MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。")])]),s._v(" "),a("p",[s._v("接下来，我们分析一下上面四种场景对性能的影响。")]),s._v(" "),a("p",[s._v("其中，第三种情况是属于 MySQL 空闲时的操作，这时系统没什么压力，而第四种场景是数据库本来就要关闭了。这两种情况下，你不会太关注“性能”问题。所以这里，我们主要来分析一下前两种场景下的性能问题。")]),s._v(" "),a("p",[s._v("第一种是“redo log 写满了，要 flush 脏页”，"),a("strong",[s._v("这种情况是 InnoDB 要尽量避免的")]),s._v("。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。如果你从监控上看，这时候更新数会跌为 0。")]),s._v(" "),a("p",[s._v("第二种是“内存不够用了，要先将脏页写到磁盘”，这种情况其实是常态。"),a("strong",[s._v("InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("第一种是，还没有使用的；")]),s._v(" "),a("li",[s._v("第二种是，使用了并且是干净页；")]),s._v(" "),a("li",[s._v("第三种是，使用了并且是脏页。")])]),s._v(" "),a("p",[s._v("InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。")]),s._v(" "),a("p",[s._v("所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：")]),s._v(" "),a("ol",[a("li",[s._v("一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；")]),s._v(" "),a("li",[s._v("日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。")])]),s._v(" "),a("p",[s._v("所以，"),a("strong",[s._v("InnoDB 需要有控制脏页比例的机制")]),s._v("，来尽量避免上面的这两种情况。")]),s._v(" "),a("h3",{attrs:{id:"_1-2-innodb-刷脏页的控制策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-innodb-刷脏页的控制策略"}},[s._v("#")]),s._v(" 1.2 InnoDB 刷脏页的控制策略")]),s._v(" "),a("p",[s._v("接下来，我就来和你说说 InnoDB 脏页的控制策略，以及和这些策略相关的参数。")]),s._v(" "),a("p",[s._v("首先，你要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快。")]),s._v(" "),a("p",[s._v("这就要用到 innodb_io_capacity 这个参数了，它会告诉 InnoDB 你的磁盘能力。这个值我建议你设置成磁盘的 IOPS。磁盘的 IOPS 可以通过 fio 这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：")]),s._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v(" fio -filename"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("$filename")]),s._v(" -direct"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" -iodepth "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" -thread -rw"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("randrw -ioengine"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("psync -bs"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("16k -size"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("500M -numjobs"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" -runtime"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" -group_reporting -name"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("mytest \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("blockquote",[a("p",[s._v("其实，因为没能正确地设置 innodb_io_capacity 参数，而导致的性能问题也比比皆是。之前，就曾有其他公司的开发负责人找我看一个库的性能问题，说 MySQL 的写入速度很慢，TPS 很低，但是数据库主机的 IO 压力并不大。经过一番排查，发现罪魁祸首就是这个参数的设置出了问题。\n他的主机磁盘用的是 SSD，但是 innodb_io_capacity 的值设置的是 300。于是，InnoDB 认为这个系统的能力就这么差，所以刷脏页刷得特别慢，甚至比脏页生成的速度还慢，这样就造成了脏页累积，影响了查询和更新性能。")])]),s._v(" "),a("p",[s._v("虽然我们现在已经定义了“全力刷脏页”的行为，但平时总不能一直是全力刷吧？毕竟磁盘能力不能只用来刷脏页，还需要服务用户请求。所以接下来，我们就一起看看 InnoDB 怎么控制引擎按照“全力”的百分比来刷脏页。根据我前面提到的知识点，试想一下，"),a("strong",[s._v("如果你来设计策略控制刷脏页的速度，会参考哪些因素呢")]),s._v("？")]),s._v(" "),a("blockquote",[a("p",[s._v("这个问题可以这么想，如果刷太慢，会出现什么情况？首先是内存脏页太多，其次是 redo log 写满。")])]),s._v(" "),a("p",[s._v("所以，"),a("strong",[s._v("InnoDB 的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是 redo log 的写盘速度")]),s._v("。")]),s._v(" "),a("p",[s._v("InnoDB 会根据这两个因素先单独算出两个数字。参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字，计算这个数字的伪代码类似这样：")]),s._v(" "),a("div",{staticClass:"language-python line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[s._v("F1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("M"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("M "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">=")]),s._v(" innodb_max_dirty_pages_pct"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("100")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("M"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("innodb_max_dirty_pages_pct"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。")]),s._v(" "),a("p",[s._v("上述的计算流程比较抽象，不容易理解，所以我画了一个如下图的简单的流程图。图中的 F1、F2 就是上面我们通过脏页比例和 redo log 写入速度算出来的两个值。")]),s._v(" "),a("center",[a("img",{staticStyle:{zoom:"75%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230601230103.png",alt:"20230601230103"}})]),s._v(" "),a("center",[a("font",{attrs:{colro:"grey"}},[s._v("InnoDB 刷脏页速度策略")])],1),s._v(" "),a("p",[s._v("现在你知道了，InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。")]),s._v(" "),a("p",[s._v("要尽量避免这种情况，你就要合理地设置 innodb_io_capacity 的值，并且"),a("strong",[s._v("平时要多关注脏页比例，不要让它经常接近 75%")]),s._v("。其中，脏页比例是通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到的，具体的命令参考下面的代码：")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("into")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("@a")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" global_status "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" VARIABLE_NAME "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'Innodb_buffer_pool_pages_dirty'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("into")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("@b")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" global_status "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" VARIABLE_NAME "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'Innodb_buffer_pool_pages_total'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("@a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("@b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("接下来，我们再看一个有趣的策略：")]),s._v(" "),a("p",[s._v("一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，这个查询就可能要比平时慢了。而 MySQL 中的一个机制，可能让你的查询会更慢："),a("strong",[s._v("在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉")]),s._v("；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。")]),s._v(" "),a("p",[s._v("在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。")]),s._v(" "),a("p",[a("strong",[s._v("找“邻居”这个优化在机械硬盘时代是很有意义的")]),s._v("，可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。而如果使用的是 SSD 这类 IOPS 比较高的设备的话，我就建议你把 innodb_flush_neighbors 的值设置成 0。因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷脏页操作，减少 SQL 语句响应时间。")]),s._v(" "),a("blockquote",[a("p",[s._v("在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了。")])]),s._v(" "),a("h3",{attrs:{id:"_1-3-小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-小结"}},[s._v("#")]),s._v(" 1.3 小结")]),s._v(" "),a("p",[s._v("这一章我们延续 WAL 的概念，解释了这个机制后续需要的刷脏页操作和执行时机。利用 WAL 技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。")]),s._v(" "),a("p",[s._v("但是，由此也带来了内存脏页的问题。脏页会被后台线程自动 flush，也会由于数据页淘汰而触发 flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。在这里，我也给你介绍了控制刷脏页的方法和对应的监控方式。")])],1)}),[],!1,null,null,null);t.default=r.exports}}]);