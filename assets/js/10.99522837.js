(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{1074:function(t,v,a){"use strict";a.r(v);var r=a(22),_=Object(r.a)({},(function(){var t=this,v=t.$createElement,r=t._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_4-3-y86-64-的顺序实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-y86-64-的顺序实现"}},[t._v("#")]),t._v(" 4.3 Y86-64 的顺序实现")]),t._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#_4-3-1-将处理组织成阶段"}},[t._v("4.3.1 将处理组织成阶段")]),r("ul",[r("li",[r("a",{attrs:{href:"#计算中各数值的含义"}},[t._v("计算中各数值的含义")])]),r("li",[r("a",{attrs:{href:"#arith-log-opq"}},[t._v("Arith/Log. Opq")])]),r("li",[r("a",{attrs:{href:"#rrmovq-和-irmovq"}},[t._v("rrmovq 和 irmovq")])]),r("li",[r("a",{attrs:{href:"#rmmovq"}},[t._v("rmmovq")])]),r("li",[r("a",{attrs:{href:"#mrmovq"}},[t._v("mrmovq")])]),r("li",[r("a",{attrs:{href:"#pushq、popq"}},[t._v("pushq、popq")])]),r("li",[r("a",{attrs:{href:"#jumps"}},[t._v("jumps")])]),r("li",[r("a",{attrs:{href:"#call"}},[t._v("call")])]),r("li",[r("a",{attrs:{href:"#ret"}},[t._v("ret")])]),r("li",[r("a",{attrs:{href:"#conditional-move"}},[t._v("Conditional Move")])])])]),r("li",[r("a",{attrs:{href:"#_4-3-2-seq-的硬件结构"}},[t._v("4.3.2 SEQ 的硬件结构")]),r("ul",[r("li",[r("a",{attrs:{href:"#_1-取指阶段"}},[t._v("（1）取指阶段")])]),r("li",[r("a",{attrs:{href:"#_2-译码和写回阶段"}},[t._v("（2）译码和写回阶段")])]),r("li",[r("a",{attrs:{href:"#_3-执行阶段"}},[t._v("（3）执行阶段")])]),r("li",[r("a",{attrs:{href:"#_4-访存阶段"}},[t._v("（4）访存阶段")])]),r("li",[r("a",{attrs:{href:"#_5-更新-pc-阶段"}},[t._v("（5）更新 PC 阶段")])])])])])]),r("p"),t._v(" "),r("h2",{attrs:{id:"_4-3-1-将处理组织成阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-将处理组织成阶段"}},[t._v("#")]),t._v(" 4.3.1 将处理组织成阶段")]),t._v(" "),r("ol",[r("li",[r("strong",[t._v("取指")]),t._v("（fetch）：从内存中读取地址为 PC 的指令字节。valP = PC + 指令长度。")]),t._v(" "),r("li",[r("strong",[t._v("译码")]),t._v("（decode）：从寄存器文件读入最多两个操作数，得到 valA、valB。通常是读入指令 rA 和 rB 字段指明的寄存器，不过也有些指令是读 %rsp 的。")]),t._v(" "),r("li",[r("strong",[t._v("执行")]),t._v("（execute）：ALU 要么执行指令指明的操作（根据 ifun），计算内存引用的有效地址，要么增加或减小栈指针。得到的值称为 valE。在此也有可能设置条件码，这个阶段会决定是否应该选择分支。")]),t._v(" "),r("li",[r("strong",[t._v("访存")]),t._v("（memory）：读写内存，读出的值为 valM。")]),t._v(" "),r("li",[r("strong",[t._v("写回")]),t._v("（write back）：最多可以写两个结果到寄存器文件。")]),t._v(" "),r("li",[r("strong",[t._v("更新 PC")]),t._v("（PC update）：将 PC 设置为下一条指令的地址。")])]),t._v(" "),r("h3",{attrs:{id:"计算中各数值的含义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算中各数值的含义"}},[t._v("#")]),t._v(" 计算中各数值的含义")]),t._v(" "),r("p",[r("strong",[t._v("取指：")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("名称")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("含义")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("icode")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("指令码")])]),t._v(" "),r("tr",[r("td",[t._v("ifun")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("指令功能")])]),t._v(" "),r("tr",[r("td",[t._v("rA、rB")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("指令寄存器 A、B")])]),t._v(" "),r("tr",[r("td",[t._v("valC")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("指令中的常数")])])])]),t._v(" "),r("p",[r("strong",[t._v("译码：")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("名称")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("含义")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("srcA、srcB")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("寄存器 ID A、B")])]),t._v(" "),r("tr",[r("td",[t._v("dstE、dstM")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("目的寄存器 E、M")])]),t._v(" "),r("tr",[r("td",[t._v("valA、valB")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("寄存器值 A、B")])])])]),t._v(" "),r("p",[r("strong",[t._v("执行：")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("名称")]),t._v(" "),r("th",{staticStyle:{"text-align":"center"}},[t._v("含义")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("valE")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("ALU 运算结果")])]),t._v(" "),r("tr",[r("td",[t._v("cnd")]),t._v(" "),r("td",{staticStyle:{"text-align":"center"}},[t._v("分支或转移标识")])])])]),t._v(" "),r("h3",{attrs:{id:"arith-log-opq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#arith-log-opq"}},[t._v("#")]),t._v(" Arith/Log. Opq")]),t._v(" "),r("p",[r("img",{attrs:{src:a(609),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"rrmovq-和-irmovq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rrmovq-和-irmovq"}},[t._v("#")]),t._v(" rrmovq 和 irmovq")]),t._v(" "),r("p",[r("img",{attrs:{src:a(610),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"rmmovq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rmmovq"}},[t._v("#")]),t._v(" rmmovq")]),t._v(" "),r("p",[r("img",{attrs:{src:a(611),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"mrmovq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mrmovq"}},[t._v("#")]),t._v(" mrmovq")]),t._v(" "),r("p",[r("img",{attrs:{src:a(612),alt:""}})]),t._v(" "),r("ul",[r("li",[t._v("注意 "),r("code",[t._v("mrmovq D(rB), rA")]),t._v(" 指令的写法中 rA、rB 所在的先后顺序与指令编码中是相反的。")])]),t._v(" "),r("h3",{attrs:{id:"pushq、popq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pushq、popq"}},[t._v("#")]),t._v(" pushq、popq")]),t._v(" "),r("p",[r("img",{attrs:{src:a(613),alt:""}})]),t._v(" "),r("ul",[r("li",[r("code",[t._v("pushq")]),t._v(" 应该先将栈指针减去 8，即使栈指针的更新实际上是在内存操作完成后才进行的。")]),t._v(" "),r("li",[r("code",[t._v("pop")]),t._v(" 应该首先读内存，然后再增加栈指针。")])]),t._v(" "),r("h3",{attrs:{id:"jumps"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jumps"}},[t._v("#")]),t._v(" jumps")]),t._v(" "),r("p",[r("img",{attrs:{src:a(614),alt:""}})]),t._v(" "),r("ul",[r("li",[t._v("跳转的实现：在执行阶段，检查条件码和跳转条件来确定是否要选择分支，产生一个一位信号 Cnd。在更新 PC 阶段，检查这个标志，如果这个标志为 1，就将 PC 设为 valC（跳转目标），如果为 0，就设为 valP（下一条指令的地址）。")])]),t._v(" "),r("h3",{attrs:{id:"call"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#call"}},[t._v("#")]),t._v(" call")]),t._v(" "),r("p",[r("img",{attrs:{src:a(615),alt:""}})]),t._v(" "),r("ul",[r("li",[t._v("对指令 call，我们要将 valP，也就是 call 指令后紧跟着的那条指令的地址，压入栈中。在更新 PC 阶段，将 PC 设为 valC，也就是调用的目的地。")])]),t._v(" "),r("h3",{attrs:{id:"ret"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ret"}},[t._v("#")]),t._v(" ret")]),t._v(" "),r("p",[r("img",{attrs:{src:a(616),alt:""}})]),t._v(" "),r("ul",[r("li",[t._v("对指令 ret，在更新 PC 阶段，我们将 valM，即从栈中取出的值，赋值给 PC。")])]),t._v(" "),r("h3",{attrs:{id:"conditional-move"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#conditional-move"}},[t._v("#")]),t._v(" Conditional Move")]),t._v(" "),r("p",[r("img",{attrs:{src:a(617),alt:""}})]),t._v(" "),r("h2",{attrs:{id:"_4-3-2-seq-的硬件结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-seq-的硬件结构"}},[t._v("#")]),t._v(" 4.3.2 SEQ 的硬件结构")]),t._v(" "),r("p",[r("img",{attrs:{src:a(618),alt:""}})]),t._v(" "),r("details",{staticClass:"custom-block details"},[r("summary",[t._v("图片说明")]),t._v(" "),r("ul",[r("li",[t._v("浅蓝色方框：硬件单元，如内存、ALU 等")]),t._v(" "),r("li",[t._v("灰色方框：控制逻辑，用 HCL 描述")]),t._v(" "),r("li",[t._v("白色椭圆框：信号标识")]),t._v(" "),r("li",[t._v("粗线：宽度为字长的数据（64位）")]),t._v(" "),r("li",[t._v("细线：宽度为字节或更窄的数据（4-8位）")]),t._v(" "),r("li",[t._v("虚线：单个位的数据")])])]),t._v(" "),r("h3",{attrs:{id:"_1-取指阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-取指阶段"}},[t._v("#")]),t._v(" （1）取指阶段")]),t._v(" "),r("p",[r("img",{attrs:{src:a(619),alt:""}})]),t._v(" "),r("p",[r("strong",[t._v("预定义的单元：")])]),t._v(" "),r("ul",[r("li",[t._v("PC：存储 PC 的寄存器")]),t._v(" "),r("li",[t._v("指令内存：读出 10 个字节（PC ~ PC+9），发出指令地址不合法的信号（imem_error）")]),t._v(" "),r("li",[t._v("Split：把指令字节分为 icode 和 ifun")]),t._v(" "),r("li",[t._v("Align：把读出的字节放入寄存器和常数字（valC）中")])]),t._v(" "),r("p",[r("strong",[t._v("控制逻辑：")])]),t._v(" "),r("ul",[r("li",[t._v("instr_valid：指令是否有效？")]),t._v(" "),r("li",[t._v("icode、ifun：指令地址无效时（检查 imem_error 信号）生成 no-op 指令；有效时是指令的相应字段")]),t._v(" "),r("li",[t._v("need_regids：指令是否有寄存器字节？")]),t._v(" "),r("li",[t._v("need_valC：指令中是否有常数字？")])]),t._v(" "),r("h3",{attrs:{id:"_2-译码和写回阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-译码和写回阶段"}},[t._v("#")]),t._v(" （2）译码和写回阶段")]),t._v(" "),r("p",[r("img",{attrs:{src:a(620),alt:""}})]),t._v(" "),r("p",[r("strong",[t._v("寄存器文件：")])]),t._v(" "),r("ul",[r("li",[t._v("读端口 A, B")]),t._v(" "),r("li",[t._v("写端口 E, M")]),t._v(" "),r("li",[t._v("地址为寄存器 ID 或者是 15（0xF），15 时无法访问")])]),t._v(" "),r("p",[r("strong",[t._v("控制逻辑：")])]),t._v(" "),r("ul",[r("li",[t._v("srcA, srcB: 读端口地址")]),t._v(" "),r("li",[t._v("dstE, dstM: 写端口地址")])]),t._v(" "),r("p",[r("strong",[t._v("信号：")])]),t._v(" "),r("ul",[r("li",[t._v("Cnd: 标明是否触发条件转移。在执行阶段计算出Cnd条件信号。")])]),t._v(" "),r("h3",{attrs:{id:"_3-执行阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-执行阶段"}},[t._v("#")]),t._v(" （3）执行阶段")]),t._v(" "),r("p",[r("img",{attrs:{src:a(621),alt:""}})]),t._v(" "),r("p",[r("strong",[t._v("单元：")])]),t._v(" "),r("ul",[r("li",[t._v("ALU：实现四种所需的功能；生成条件码")]),t._v(" "),r("li",[t._v("CC：包含三个条件码的寄存器")]),t._v(" "),r("li",[t._v("cond：计算条件转移或跳转标识")])]),t._v(" "),r("p",[r("strong",[t._v("控制逻辑：")])]),t._v(" "),r("ul",[r("li",[t._v("Set CC：是否加载条件码寄存器？")]),t._v(" "),r("li",[t._v("ALU A：数据 A 送入 ALU")]),t._v(" "),r("li",[t._v("ALU fun：ALU 执行哪个功能")])]),t._v(" "),r("h3",{attrs:{id:"_4-访存阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-访存阶段"}},[t._v("#")]),t._v(" （4）访存阶段")]),t._v(" "),r("p",[r("img",{attrs:{src:a(622),alt:""}})]),t._v(" "),r("p",[r("strong",[t._v("控制逻辑：")])]),t._v(" "),r("ul",[r("li",[t._v("stat：指令的状态是什么")]),t._v(" "),r("li",[t._v("Mem.read：是否读数据字")]),t._v(" "),r("li",[t._v("Mem.write：是否写数据字")]),t._v(" "),r("li",[t._v("Mem.addr：选择地址")]),t._v(" "),r("li",[t._v("Mem.data：选择数据")])]),t._v(" "),r("h3",{attrs:{id:"_5-更新-pc-阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-更新-pc-阶段"}},[t._v("#")]),t._v(" （5）更新 PC 阶段")]),t._v(" "),r("p",[r("img",{attrs:{src:a(623),alt:""}})]),t._v(" "),r("ul",[r("li",[t._v("新 PC：选取下一个 PC 的值")])])])}),[],!1,null,null,null);v.default=_.exports},609:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-31-50.a85984b7.png"},610:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-18-48-48.4bac74ce.png"},611:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-36-06.3ccfff86.png"},612:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-06-12.aa423b59.png"},613:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-06-48.1e5c061f.png"},614:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-38-58.843783d2.png"},615:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-39-45.9ae1d41d.png"},616:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-40-12.33223fb1.png"},617:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-38-18.397696e5.png"},618:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-19-53-35.8be79dd7.png"},619:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-03-07.b2529df6.png"},620:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-09-22.a95ff76b.png"},621:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-12-12.62724e30.png"},622:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-15-17.c940a65f.png"},623:function(t,v,a){t.exports=a.p+"assets/img/2021-08-17-20-17-08.4adc93a1.png"}}]);