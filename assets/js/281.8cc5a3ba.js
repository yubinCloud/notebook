(window.webpackJsonp=window.webpackJsonp||[]).push([[281],{1034:function(_,v,t){"use strict";t.r(v);var s=t(22),e=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("blockquote",[t("p",[_._v("参考：")]),_._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/article/271754",target:"_blank",rel:"noopener noreferrer"}},[_._v("04 AOF 日志：宕机了，Redis 如何避免数据丢失？| 极客时间"),t("OutboundLink")],1)]),_._v(" "),t("li",[t("a",{attrs:{href:"https://time.geekbang.org/column/intro/100056701?tab=catalog",target:"_blank",rel:"noopener noreferrer"}},[_._v("05 内存快照：宕机后，Redis 如何实现快速恢复？| 极客时间"),t("OutboundLink")],1)])])]),_._v(" "),t("p",[_._v("Redis 用作缓存并将数据存于内存中，就会面对一个问题：一旦服务器宕机，内存中的数据将全部丢失。")]),_._v(" "),t("p",[_._v("也许有个解决方案：从后端数据库恢复这些数据。但这频繁访问数据库会使得性能严重下降。所以对于 Redis 而言，实现数据的持久化，避免从后端中恢复数据，是至关重要的。")]),_._v(" "),t("p",[_._v("目前，Redis 的持久化主要有两大机制：AOF 日志和 RDB 快照。这里讲分别讲解。")]),_._v(" "),t("h2",{attrs:{id:"_1-aof-日志-宕机了-redis-如何避免数据丢失"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-aof-日志-宕机了-redis-如何避免数据丢失"}},[_._v("#")]),_._v(" 1. AOF 日志：宕机了，Redis 如何避免数据丢失？")]),_._v(" "),t("p",[_._v("AOF：Append Only File")]),_._v(" "),t("h3",{attrs:{id:"_1-1-aof-日志是如何实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-aof-日志是如何实现的"}},[_._v("#")]),_._v(" 1.1 AOF 日志是如何实现的？")]),_._v(" "),t("p",[_._v("说到日志，我们熟悉的是预写日志（WAL，Write Ahead Log），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，"),t("strong",[_._v("AOF 日志正好相反，它是写后日志")]),_._v("，“写后”的意思是 "),t("strong",[_._v("Redis 是先执行命令，把数据写入内存，然后才记录日志")]),_._v("，如下图所示：")]),_._v(" "),t("center",[t("img",{staticStyle:{zoom:"70%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214153236.png",alt:"20230214153236"}})]),_._v(" "),t("p",[_._v("那 AOF 为什么要先执行命令再记日志呢？要回答这个问题，我们要先知道 AOF 里记录了什么内容。")]),_._v(" "),t("p",[_._v("传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 "),t("strong",[_._v("AOF 里记录的是 Redis 收到的每一条命令")]),_._v("，这些命令是以文本形式保存的。")]),_._v(" "),t("p",[_._v("我们以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。如下图，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。")]),_._v(" "),t("center",[t("img",{staticStyle:{zoom:"73%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214153656.png",alt:"20230214153656"}})]),_._v(" "),t("p",[_._v("但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。")]),_._v(" "),t("p",[_._v("而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，"),t("strong",[_._v("Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况")]),_._v("。")]),_._v(" "),t("p",[_._v("除此之外，AOF 还有一个好处："),t("strong",[_._v("它是在命令执行后才记录日志，所以不会阻塞当前的写操作")]),_._v("。")]),_._v(" "),t("p",[_._v("不过，AOF 也有两个潜在的风险:")]),_._v(" "),t("ul",[t("li",[_._v("首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。")]),_._v(" "),t("li",[_._v("其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。")])]),_._v(" "),t("p",[_._v("仔细分析的话，你就会发现，这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味着，"),t("strong",[_._v("如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"_1-2-三种写回策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-三种写回策略"}},[_._v("#")]),_._v(" 1.2 三种写回策略")]),_._v(" "),t("p",[_._v("其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 "),t("strong",[_._v("appendfsync")]),_._v(" 的三个可选值：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("Always")]),_._v("，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；")]),_._v(" "),t("li",[t("strong",[_._v("Everysec")]),_._v("，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；")]),_._v(" "),t("li",[t("strong",[_._v("No")]),_._v("，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。")])]),_._v(" "),t("p",[_._v("针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。我们来分析下其中的原因：")]),_._v(" "),t("ul",[t("li",[_._v("“同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；")]),_._v(" "),t("li",[_._v("虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；")]),_._v(" "),t("li",[_._v("“每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。")])]),_._v(" "),t("p",[_._v("三种写回策略的对比如下：")]),_._v(" "),t("center",[t("img",{staticStyle:{zoom:"75%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214154209.png",alt:"20230214154209"}})]),_._v(" "),t("p",[_._v("选择哪种写回策略，就要在高性能和高可靠性之间做 trade-off 了：")]),_._v(" "),t("ul",[t("li",[_._v("想要获得高性能，就选择 No 策略；")]),_._v(" "),t("li",[_._v("如果想要得到高可靠性保证，就选择 Always 策略；")]),_._v(" "),t("li",[_._v("如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。")])]),_._v(" "),t("p",[_._v("随着 Redis 接收的命令越来越多，AOF 文件也会越来越大，这也就意味着，"),t("strong",[_._v("我们一定要小心 AOF 文件过大带来的性能问题")]),_._v("。这里的“性能问题”，主要在于以下三个方面：")]),_._v(" "),t("ol",[t("li",[_._v("文件系统本身对文件大小有限制，无法保存过大的文件；")]),_._v(" "),t("li",[_._v("如果文件太大，之后再往里面追加命令记录的话，效率也会变低；")]),_._v(" "),t("li",[_._v("如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。")])]),_._v(" "),t("p",[_._v("所以，我们就要采取一定的控制手段，这个时候，"),t("strong",[_._v("AOF 重写机制")]),_._v("就登场了。")]),_._v(" "),t("h3",{attrs:{id:"_1-3-aof-重写机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-aof-重写机制"}},[_._v("#")]),_._v(" 1.3 AOF 重写机制")]),_._v(" "),t("p",[_._v("当 AOF 日志文件太大了，就需要 AOF 重写机制了。")]),_._v(" "),t("p",[t("mark",[_._v("AOF 重写机制")]),_._v("：就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，"),t("strong",[_._v("读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入")]),_._v("。比如说，当读取了键值对“testkey”: “testvalue”之后，重写机制会记录 set testkey testvalue 这条命令。这样，当需要恢复时，可以重新执行该命令，实现“testkey”: “testvalue”的写入。")]),_._v(" "),t("p",[_._v("为什么"),t("strong",[_._v("重写机制可以把日志文件变小呢")]),_._v("? 实际上，重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。因为这个过程把一些中间的修改记录给去掉了，只保留了最新的数据库状态。如下图所示：")]),_._v(" "),t("center",[t("img",{staticStyle:{zoom:"75%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214155004.png",alt:"20230214155004"}})]),_._v(" "),t("p",[_._v("不过，虽然 AOF 重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。这时，我们就要继续关注另一个问题了："),t("strong",[_._v("重写会不会阻塞主线程")]),_._v("？")]),_._v(" "),t("h3",{attrs:{id:"_1-4-aof-重写会阻塞吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-aof-重写会阻塞吗"}},[_._v("#")]),_._v(" 1.4 AOF 重写会阻塞吗？")]),_._v(" "),t("p",[_._v("和 AOF 日志由主线程写回不同，"),t("strong",[_._v("重写过程是由后台子进程 bgrewriteaof 来完成的")]),_._v("，这也是为了避免阻塞主线程，导致数据库性能下降。")]),_._v(" "),t("p",[_._v("我把重写的过程总结为“"),t("strong",[_._v("一个拷贝，两处日志")]),_._v("”：")]),_._v(" "),t("p",[_._v("“"),t("strong",[_._v("一个拷贝")]),_._v("”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。")]),_._v(" "),t("p",[_._v("“"),t("strong",[_._v("两处日志")]),_._v("”又是什么呢？")]),_._v(" "),t("p",[_._v("因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。")]),_._v(" "),t("p",[_._v("而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。")]),_._v(" "),t("p",[_._v("因此，AOF 非阻塞的重写过程如下图所示：")]),_._v(" "),t("center",[t("img",{staticStyle:{zoom:"75%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214155527.png",alt:"20230214155527"}})]),_._v(" "),t("p",[_._v("总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。")]),_._v(" "),t("h3",{attrs:{id:"_1-5-小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-小结"}},[_._v("#")]),_._v(" 1.5 小结")]),_._v(" "),t("p",[_._v("这一节介绍了 Redis 用于避免数据丢失的 AOF 日志机制。这个方法通过逐一记录操作命令，在恢复时再逐一执行命令的方式，保证了数据的可靠性。")]),_._v(" "),t("p",[_._v("AOF 机制考虑到对 Redis 性能的影响，提供了 AOF 日志的三种写回策略。")]),_._v(" "),t("p",[_._v("此外，为了避免日志文件过大，Redis 提供了 AOF 重写机制，直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志。这个过程通过后台线程完成，避免了对主线程的阻塞。")]),_._v(" "),t("p",[_._v("不过，上面介绍的落盘时机和重写机制都是用于“记日志”的方法，而在”用日志“时，需要对所有的操作记录进行顺序重放，这个重放过程就很慢了。那，有没有既能避免数据丢失，又能更快地恢复的方法呢？当然有，那就是 RDB 快照了。")]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("本节问题 1：AOF 重写过程有没有其他潜在的阻塞风险")]),_._v("？")]),_._v(" "),t("p",[_._v("这里有两个风险：")]),_._v(" "),t("ol",[t("li",[_._v("Redis 主线程 fork 创建 bgrewriteaof 子进程时，内核需要创建用于管理子进程的相关数据结构，这些数据结构在操作系统中通常叫作进程控制块（Process Control Block，简称为 PCB）。内核要把主线程的 PCB 内容拷贝给子进程。这个创建和拷贝过程由内核执行，是会阻塞主线程的。而且，在拷贝过程中，子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。"),t("strong",[_._v("如果 Redis 实例内存大，页表就会大，fork 执行时间就会长，这就会给主线程带来阻塞风险")]),_._v("。")]),_._v(" "),t("li",[_._v("bgrewriteaof 子进程会和主线程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。"),t("strong",[_._v("因为操作系统在分配内存空间时，有查找和锁的开销，这就会导致阻塞")]),_._v("。")])]),_._v(" "),t("p",[t("strong",[_._v("本节问题 2：AOF 重写为什么不共享使用 AOF 本身的日志")]),_._v("？")]),_._v(" "),t("p",[_._v("如果都用 AOF 日志的话，主线程要写，bgrewriteaof 子进程也要写，这两者会竞争文件系统的锁，这就会对 Redis 主线程的性能造成影响。")]),_._v(" "),t("h2",{attrs:{id:"_2-rdb-快照-宕机后-redis如何实现快速恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-rdb-快照-宕机后-redis如何实现快速恢复"}},[_._v("#")]),_._v(" 2. RDB 快照：宕机后，Redis如何实现快速恢复？")]),_._v(" "),t("h3",{attrs:{id:"_2-1-什么是-rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什么是-rdb"}},[_._v("#")]),_._v(" 2.1 什么是 RDB")]),_._v(" "),t("p",[_._v("上一节讲的 Redis 避免数据丢失的 AOF 方法，好处是每次执行只需要记录操作命令，需要持久化的数据量不大，只要你不是采用的 Always 的持久化策略，就不会对性能造成太大影响。")]),_._v(" "),t("p",[_._v("但由于记录的命令而不是实际数据，因此使用 AOF 日志进行故障恢复时需要重放一遍，如果日志过多会耗费很长时间。那有没有既可以保证可靠性，还能在宕机时实现快速恢复的其他方法呢？这就是这节要学习的持久化方法——内存快照。")]),_._v(" "),t("p",[t("mark",[_._v("内存快照")]),_._v("：指内存中的数据在某一个时刻的状态记录。")]),_._v(" "),t("p",[_._v("这就像平时拍照片一样，内存快照把某一时刻的状态以文件的形式写到磁盘上，这样即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 "),t("mark",[_._v("RDB 文件")]),_._v("。")]),_._v(" "),t("blockquote",[t("p",[_._v("RDB: Redis DataBase")])]),_._v(" "),t("p",[_._v("和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。")]),_._v(" "),t("p",[_._v("但拍快照就涉及到两个关键问题：")]),_._v(" "),t("ul",[t("li",[_._v("给哪些数据拍快照？这涉及到快照的执行效率的问题。")]),_._v(" "),t("li",[_._v("拍快照时还能增删改吗？这涉及 Redis 是否被阻塞。")])]),_._v(" "),t("h3",{attrs:{id:"_2-2-给哪些数据拍快照"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-给哪些数据拍快照"}},[_._v("#")]),_._v(" 2.2 给哪些数据拍快照？")]),_._v(" "),t("p",[_._v("Redis的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是"),t("strong",[_._v("全量快照")]),_._v("，也就是说，把内存中的所有数据都记录到磁盘中。")]),_._v(" "),t("p",[_._v("但全量快照全部写入磁盘会花费很多时间，而 Redis 的单线程模型又决定了我们要尽量避免所有会阻塞主线程的操作。那 "),t("strong",[_._v("RDB 文件的生成是否会阻塞主线程")]),_._v("？")]),_._v(" "),t("p",[_._v("Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("save")]),_._v("：在主线程中执行，会导致阻塞；")]),_._v(" "),t("li",[t("strong",[_._v("bgsave")]),_._v("：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。")])]),_._v(" "),t("p",[_._v("接下来需要考虑，使用 bgsave 来执行全量快照时，Redis 能否正常处理写操作？")]),_._v(" "),t("h3",{attrs:{id:"_2-3-快照时数据能修改吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-快照时数据能修改吗"}},[_._v("#")]),_._v(" 2.3 快照时数据能修改吗？")]),_._v(" "),t("p",[_._v("在拍快照时，如果发生数据改动，则很容易产生数据不一致现象。如果不想让数据发生改动，那拍快照期间 Redis 无法接收写请求，这在生产环境下是不被允许的。这时，Redis 就借助了操作系统提供的"),t("strong",[_._v("写时复制技术")]),_._v("（Copy-On-Write，COW），在执行快照的同时，正常处理写操作。")]),_._v(" "),t("p",[_._v("简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。")]),_._v(" "),t("ul",[t("li",[_._v("此时，如果主线程对这些数据都是读操作（如图中的键值对 A），那么，主线程和bgsave子进程相互不影响。")]),_._v(" "),t("li",[_._v("但如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后，主线程在这个数据副本上进行修改。同时，bgsave子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。")])]),_._v(" "),t("center",[t("img",{staticStyle:{zoom:"70%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214194653.png",alt:"20230214194653"}})]),_._v(" "),t("p",[_._v("这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。")]),_._v(" "),t("p",[_._v("到这里，我们就解决了对“哪些数据做快照”以及“做快照时数据能否修改”这两大问题："),t("font",{attrs:{color:"blue"}},[_._v("Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据")]),_._v("。")],1),_._v(" "),t("h3",{attrs:{id:"_2-4-拍快照的频率"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-拍快照的频率"}},[_._v("#")]),_._v(" 2.4 拍快照的频率")]),_._v(" "),t("p",[_._v("快照间隔时间也是一个关键问题。")]),_._v(" "),t("p",[_._v("拍快照的间隔越小，发生宕机时丢失的数据也就越少，那能不能每秒拍一次快照？")]),_._v(" "),t("p",[_._v("这种想法是错误的。频繁执行全量快照会带来两方面的开销：")]),_._v(" "),t("ul",[t("li",[_._v("一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。")]),_._v(" "),t("li",[_._v("另一方面，bgsave子进程需要通过fork操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，"),t("strong",[_._v("fork这个创建过程本身会阻塞主线程")]),_._v("，而且主线程的内存越大，阻塞时间越长。如果频繁fork出bgsave子进程，这就会频繁阻塞主线程了（所以，在Redis中如果有一个bgsave在运行，就不会再启动第二个bgsave子进程）。那么，有什么其他好方法吗？")])]),_._v(" "),t("p",[_._v("此时，我们可以做"),t("mark",[_._v("增量快照")]),_._v("：做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。")]),_._v(" "),t("p",[_._v("在第一次做完全量快照后，T1 和 T2 时刻如果再做快照，我们只需要将被修改的数据写入快照文件就行。但是，这么做的前提是，"),t("strong",[_._v("我们需要记住哪些数据被修改了")]),_._v("。这个“记住”需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：")]),_._v(" "),t("center",[t("img",{staticStyle:{zoom:"70%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214200409.png",alt:"20230214200409"}})]),_._v(" "),t("p",[_._v("如果我们对每一个键值对的修改，都做个记录，那么，如果有 1 万个被修改的键值对，我们就需要有 1 万条额外的记录。而且，有的时候，键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息，可能就需要 8 字节，这样的画，为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说，有些得不偿失。")]),_._v(" "),t("p",[_._v("到这里，你可以发现，"),t("strong",[_._v("RDB 快照虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握")]),_._v("，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销，那么，还有什么方法既能利用RDB的快速恢复，又能以较小的开销做到尽量少丢数据呢？")]),_._v(" "),t("p",[_._v("Redis 4.0中提出了一个"),t("mark",[_._v("混合使用AOF日志和内存快照")]),_._v("的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。")]),_._v(" "),t("p",[_._v("这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。")]),_._v(" "),t("p",[_._v("如下图所示，T1和T2时刻的修改，用AOF日志记录，等到第二次做全量快照时，就可以清空AOF日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。")]),_._v(" "),t("center",[t("img",{staticStyle:{zoom:"70%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/20230214200035.png",alt:"20230214200035"}})]),_._v(" "),t("p",[t("strong",[_._v("这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势")]),_._v("，颇有点“鱼和熊掌可以兼得”的感觉，建议你在实践中用起来。")]),_._v(" "),t("h3",{attrs:{id:"_2-5-小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-小结"}},[_._v("#")]),_._v(" 2.5 小结")]),_._v(" "),t("p",[_._v("这一大节，介绍了 Redis 用于避免数据丢失的 RDB 内存快照的方法，它可以快速恢复数据库。")]),_._v(" "),t("p",[_._v("Redis 设计 bgsave 和写时复制的方式来尽可能减少了内存快照对正常读写的影响。")]),_._v(" "),t("p",[_._v("但频繁快照又是不可接受的，于是出现了混合使用 RDB 和 AOF 的方式，正好可以取两者之长，避两者之短，以较小的性能开销保证数据可靠性和性能。")]),_._v(" "),t("p",[t("font",{attrs:{color:"red"}},[_._v("最后，关于 AOF 和 RDB 的选择问题，我想提三点建议")]),_._v("：")],1),_._v(" "),t("ul",[t("li",[_._v("数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；")]),_._v(" "),t("li",[_._v("如果允许分钟级别的数据丢失，可以只使用 RDB；")]),_._v(" "),t("li",[_._v("如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。")])])],1)}),[],!1,null,null,null);v.default=e.exports}}]);