(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{915:function(t,_,v){"use strict";v.r(_);var a=v(22),e=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"_1-单元测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-单元测试"}},[t._v("#")]),t._v(" 1. 单元测试")]),t._v(" "),v("h3",{attrs:{id:"_1-1-单元测试概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-单元测试概述"}},[t._v("#")]),t._v(" 1.1 单元测试概述")]),t._v(" "),v("p",[v("strong",[t._v("单元测试")]),t._v("就是针对最小的功能单元编写测试代码，Java 程序最小的功能单元是方法，因此，单元测试就是"),v("strong",[t._v("针对 Java 方法的测试")]),t._v("，进而检查方法的正确性。")]),t._v(" "),v("p",[v("strong",[t._v("JUnit")]),t._v(" 是使用 Java 语言实现的单元测试框架，几乎所有的 IDE 工具都集成了 JUnit，这样我们就可以直接在 IDE 中编写并运行 JUnit 测试。")]),t._v(" "),v("p",[t._v("JUnit "),v("strong",[t._v("优点")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法")]),t._v(" "),v("li",[t._v("可以生成全部方法的测试报告")]),t._v(" "),v("li",[t._v("单元测试中的某个方法测试失败了，不会影响其他测试方法的测试")])]),t._v(" "),v("h3",{attrs:{id:"_1-2-单元测试快速入门"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-单元测试快速入门"}},[t._v("#")]),t._v(" 1.2 单元测试快速入门")]),t._v(" "),v("p",[t._v("需求：使用单元测试进行业务方法预期结果、正确性测试的快速入门")]),t._v(" "),v("p",[t._v("过程：")]),t._v(" "),v("ol",[v("li",[t._v("将 JUnit 的 jar 包导入到项目中；")]),t._v(" "),v("li",[t._v("编写测试方法：该测试方法必须是公共的无参数无返回值的非静态方法；")]),t._v(" "),v("li",[t._v("在测试方法上使用 "),v("code",[t._v("@Test")]),t._v("注解：标注该方法是一个测试方法；")]),t._v(" "),v("li",[t._v("在测试方法中完成被测试方法的预期正确性测试（用 "),v("code",[t._v("Assert")]),t._v(" 类）；")]),t._v(" "),v("li",[t._v("选中测试方法，选择“JUnit运行” ：红色失败，绿色成功。")])]),t._v(" "),v("p",[t._v("进行预期的"),v("strong",[t._v("正确性测试")]),t._v("：断言——"),v("code",[t._v("Assert.assertEquals(...)")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"_1-3-单元测试常用注解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-单元测试常用注解"}},[t._v("#")]),t._v(" 1.3 单元测试常用注解")]),t._v(" "),v("p",[t._v("Junit 常用注解(Junit "),v("strong",[t._v("4")]),t._v(".xxxx版本)：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("注解")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("@Test")]),t._v(" "),v("td",[t._v("测试方法")])]),t._v(" "),v("tr",[v("td",[t._v("@Before")]),t._v(" "),v("td",[t._v("用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。")])]),t._v(" "),v("tr",[v("td",[t._v("@After")]),t._v(" "),v("td",[t._v("用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。")])]),t._v(" "),v("tr",[v("td",[t._v("@BeforeClass")]),t._v(" "),v("td",[t._v("用来静态修饰方法，该方法会在所有测试方法之前只执行一次。")])]),t._v(" "),v("tr",[v("td",[t._v("@AfterClass")]),t._v(" "),v("td",[t._v("用来静态修饰方法，该方法会在所有测试方法之后只执行一次。")])])])]),t._v(" "),v("ul",[v("li",[t._v("开始执行的方法:初始化资源。")]),t._v(" "),v("li",[t._v("执行完之后的方法:释放资源。")])]),t._v(" "),v("p",[t._v("Junit 常用注解(Junit "),v("strong",[t._v("5")]),t._v(".xxxx版本)：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("注解")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("@Test")]),t._v(" "),v("td",[t._v("测试方法")])]),t._v(" "),v("tr",[v("td",[t._v("@BeforeEach")]),t._v(" "),v("td",[t._v("用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。")])]),t._v(" "),v("tr",[v("td",[t._v("@AfterEach")]),t._v(" "),v("td",[t._v("用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。")])]),t._v(" "),v("tr",[v("td",[t._v("@BeforeAll")]),t._v(" "),v("td",[t._v("用来静态修饰方法，该方法会在所有测试方法之前只执行一次。")])]),t._v(" "),v("tr",[v("td",[t._v("@AfterAll")]),t._v(" "),v("td",[t._v("用来静态修饰方法，该方法会在所有测试方法之后只执行一次。")])])])]),t._v(" "),v("h2",{attrs:{id:"_2-反射"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-反射"}},[t._v("#")]),t._v(" 2. 反射")]),t._v(" "),v("h3",{attrs:{id:"_2-1-概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-概述"}},[t._v("#")]),t._v(" 2.1 概述")]),t._v(" "),v("p",[v("strong",[t._v("反射")]),t._v('是指对于任何一个Class类，在"运行的时候"都可以直接得到这个类全部成分。')]),t._v(" "),v("ul",[v("li",[t._v("在运行时,可以直接得到这个类的构造器对象：Constructor")]),t._v(" "),v("li",[t._v("在运行时,可以直接得到这个类的成员变量对象：Field")]),t._v(" "),v("li",[t._v("在运行时,可以直接得到这个类的成员方法对象：Method")])]),t._v(" "),v("p",[t._v("这种运行时动态获取类信息以及动态调用类中成分的能力称为 Java 语言的"),v("strong",[t._v("反射机制")]),t._v("。")]),t._v(" "),v("p",[t._v("反射的核心思想和"),v("strong",[t._v("关键")]),t._v("就是：得到编译以后的 class 文件对象")]),t._v(" "),v("p",[t._v("HelloWorld.java -> javac -> HelloWorld.class")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Class")]),t._v(" c "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HelloWorld")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("h3",{attrs:{id:"_2-2-获取-class-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-获取-class-对象"}},[t._v("#")]),t._v(" 2.2 获取 Class 对象")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220131150236109.png",alt:"image-20220131150236109"}})]),t._v(" "),v("p",[t._v("三种方式：")]),t._v(" "),v("ol",[v("li",[v("code",[t._v('Class.forName("com.example.Student")')])]),t._v(" "),v("li",[v("code",[t._v("Student.class")])]),t._v(" "),v("li",[v("code",[t._v("s.getClass()")])])]),t._v(" "),v("h3",{attrs:{id:"_2-3-获取-constructor-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-获取-constructor-对象"}},[t._v("#")]),t._v(" 2.3 获取 Constructor 对象")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("Constructor<?>[] getConstructors()")])]),t._v(" "),v("td",[t._v("返回所有构造器对象的数组（"),v("strong",[t._v("只能拿public的")]),t._v("）")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("Constructor<?>[] getDeclaredConstructors()")])]),t._v(" "),v("td",[t._v("返回所有构造器对象的数组，"),v("strong",[t._v("存在就能拿到")])])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("Constructor<T> getConstructor(Class<?>... parameterTypes)")])]),t._v(" "),v("td",[t._v("返回单个构造器对象（只能拿public的）")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)")])]),t._v(" "),v("td",[t._v("返回单个构造器对象，存在就能拿到")])])])]),t._v(" "),v("p",[t._v("获取构造器的作用依然是初始化一个对象。Constructor 类中用于创建对象的方法：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("符号")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("T "),v("strong",[t._v("newInstance")]),t._v("(Object...  initargs)")]),t._v(" "),v("td",[t._v("根据指定的构造器创建对象")])]),t._v(" "),v("tr",[v("td",[t._v("public  void "),v("strong",[t._v("setAccessible")]),t._v("(boolean  flag)")]),t._v(" "),v("td",[t._v("设置为true，表示取消访问检查，进行"),v("strong",[t._v("暴力反射")]),t._v("，从而可以拿到私有的构造器来创建对象，这个方式"),v("strong",[t._v("破坏了封装性")]),t._v("。")])])])]),t._v(" "),v("h3",{attrs:{id:"_2-4-获取-field-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-获取-field-对象"}},[t._v("#")]),t._v(" 2.4 获取 Field 对象")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Field[]  getFields()")]),t._v(" "),v("td",[t._v("返回所有成员变量对象的数组（只能拿public的）")])]),t._v(" "),v("tr",[v("td",[t._v("Field[]  getDeclaredFields()")]),t._v(" "),v("td",[t._v("返回所有成员变量对象的数组，存在就能拿到")])]),t._v(" "),v("tr",[v("td",[t._v("Field  getField(String  name)")]),t._v(" "),v("td",[t._v("返回单个成员变量对象（只能拿public的）")])]),t._v(" "),v("tr",[v("td",[t._v("Field  getDeclaredField(String  name)")]),t._v(" "),v("td",[t._v("返回单个成员变量对象，存在就能拿到")])])])]),t._v(" "),v("p",[t._v("获取成员变量可以在某个对象中取值、赋值，Field 类中用于取值、赋值的方法：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("符号")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("void  set(Object obj, Object value)：")]),t._v(" "),v("td",[t._v("赋值")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("Object  get(Object obj)")]),t._v(" "),v("td",[t._v("获取值。")])])])]),t._v(" "),v("p",[t._v("如果成员是非 public 的，那可以用 "),v("code",[t._v("setAccessible")]),t._v(" 打开权限。")]),t._v(" "),v("h3",{attrs:{id:"_2-5-获取-method-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-获取-method-对象"}},[t._v("#")]),t._v(" 2.5 获取 Method 对象")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Method[]  getMethods()")]),t._v(" "),v("td",[t._v("返回所有成员方法对象的数组（只能拿public的）")])]),t._v(" "),v("tr",[v("td",[t._v("Method[]  getDeclaredMethods()")]),t._v(" "),v("td",[t._v("返回所有成员方法对象的数组，存在就能拿到")])]),t._v(" "),v("tr",[v("td",[t._v("Method  getMethod(String  name, Class<?>... parameterTypes)")]),t._v(" "),v("td",[t._v("返回单个成员方法对象（只能拿public的）")])]),t._v(" "),v("tr",[v("td",[t._v("Method  getDeclaredMethod(String  name, Class<?>... parameterTypes)")]),t._v(" "),v("td",[t._v("返回单个成员方法对象，存在就能拿到")])])])]),t._v(" "),v("p",[t._v("l获取成员方法后可以在某个对象中进行执行此方法，Method 类中用于触发执行的方法：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("符号")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("Object "),v("strong",[t._v("invoke")]),t._v("(Object obj, Object... args)")]),t._v(" "),v("td",[t._v("运行方法。参数一：用obj对象调用该方法； 参数二：调用方法的传递的参数（如果没有就不写）；返回值：方法的返回值（如果没有就不写）")])])])]),t._v(" "),v("p",[t._v("如果方法是非 public 的，那可以用 "),v("code",[t._v("setAccessible")]),t._v(" 打开权限。")]),t._v(" "),v("h3",{attrs:{id:"_2-6-反射的作用-绕过编译阶段为集合添加数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-反射的作用-绕过编译阶段为集合添加数据"}},[t._v("#")]),t._v(" 2.6 反射的作用 —— 绕过编译阶段为集合添加数据")]),t._v(" "),v("p",[t._v("反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以"),v("strong",[t._v("为集合存入其他任意类型的元素")]),t._v("。因为泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成 Class 文件进入运行阶段的时候，其真实类型都是原生 ArrayList 了，泛型相当于被擦除了。"),v("strong",[t._v("反射是作用在运行时的技术，此时已经不存在泛型了")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"_2-7-反射的作用-通用框架的底层原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-反射的作用-通用框架的底层原理"}},[t._v("#")]),t._v(" 2.7 反射的作用 —— 通用框架的底层原理")]),t._v(" "),v("p",[t._v("需求：给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。比如：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20220131154633699.png",alt:"image-20220131154633699"}})]),t._v(" "),v("p",[t._v("分析：")]),t._v(" "),v("ol",[v("li",[t._v("定义一个方法，可以接收任意类的对象；")]),t._v(" "),v("li",[t._v("使用反射获取对象的Class类对象，然后获取全部成员变量信息；")]),t._v(" "),v("li",[t._v("遍历成员变量信息，然后提取本成员变量在对象中的具体值；")]),t._v(" "),v("li",[t._v("存入成员变量名称和值到文件中去即可。")])]),t._v(" "),v("p",[t._v("基本上主流框架都会基于反射设计一些通用技术功能。")]),t._v(" "),v("h2",{attrs:{id:"_3-注解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-注解"}},[t._v("#")]),t._v(" 3. 注解")]),t._v(" "),v("h3",{attrs:{id:"_3-1-概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-概述"}},[t._v("#")]),t._v(" 3.1 概述")]),t._v(" "),v("p",[t._v("Java "),v("strong",[t._v("注解")]),t._v("（"),v("strong",[t._v("Annotation")]),t._v("）又称 Java 标注，是 JDK5.0 引入的一种注释机制。类、构造器、方法、成员变量、参数等"),v("strong",[t._v("都可以被注解进行标注")]),t._v("。")]),t._v(" "),v("p",[t._v("注解"),v("strong",[t._v("作用")]),t._v("：对 Java 中类、方法、成员变量"),v("strong",[t._v("做标记，然后进行特殊处理")]),t._v("，至于到底做何种处理由业务需求来决定。")]),t._v(" "),v("p",[t._v("例如：JUnit 框架中，标记了注解 "),v("code",[t._v("@Test")]),t._v(" 的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。")]),t._v(" "),v("h3",{attrs:{id:"_3-2-自定义注解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-自定义注解"}},[t._v("#")]),t._v(" 3.2 自定义注解")]),t._v(" "),v("p",[t._v("自定义注解就是自己做一个注解来使用：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@interface")]),t._v(" 注解名称 "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" 属性类型 属性名"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" 默认值"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("ul",[v("li",[t._v("Java 支持的数据类型基本上都支持")])]),t._v(" "),v("p",[t._v("特殊属性——"),v("strong",[t._v("value 属性")]),t._v("：如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写，但是如果有多个属性, 且多个属性没有默认值，那么value名称是不能省略的。")]),t._v(" "),v("h3",{attrs:{id:"_3-3-元注解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-元注解"}},[t._v("#")]),t._v(" 3.3 元注解")]),t._v(" "),v("p",[t._v("元注解：它也是一个注解，这个注解用来注解其他注解，即放在注解头上的注解。")]),t._v(" "),v("p",[t._v("常见的元注解：")]),t._v(" "),v("h4",{attrs:{id:"_1-target"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-target"}},[t._v("#")]),t._v(" 1）@Target")]),t._v(" "),v("p",[t._v("约束自定义注解只能在哪些地方使用。它可使用的值定义在 "),v("code",[t._v("ElementType")]),t._v(" 枚举类中，常用值如下：")]),t._v(" "),v("ul",[v("li",[t._v("TYPE，类，接口")]),t._v(" "),v("li",[t._v("FIELD, 成员变量")]),t._v(" "),v("li",[t._v("METHOD, 成员方法")]),t._v(" "),v("li",[t._v("PARAMETER, 方法参数")]),t._v(" "),v("li",[t._v("CONSTRUCTOR, 构造器")]),t._v(" "),v("li",[t._v("LOCAL_VARIABLE, 局部变量")])]),t._v(" "),v("h4",{attrs:{id:"_2-retention"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-retention"}},[t._v("#")]),t._v(" 2）@Retention")]),t._v(" "),v("p",[t._v("申明注解的存活范围。它可使用的值定义在 "),v("code",[t._v("RetentionPolicy")]),t._v(" 枚举类中，常用值如下：")]),t._v(" "),v("ul",[v("li",[t._v("SOURCE： 注解只作用在源码阶段，被编译器丢弃，生成的字节码文件中不存在")]),t._v(" "),v("li",[t._v("CLASS： 注解作用在源码阶段、字节码文件阶段，被 VM 丢弃，运行阶段不存在，默认值.")]),t._v(" "),v("li",[t._v("RUNTIME：注解作用在源码阶段、字节码文件阶段和运行阶段（开发常用），可以通过反射机制读取注解的信息。")])]),t._v(" "),v("h3",{attrs:{id:"_3-4-注解解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-注解解析"}},[t._v("#")]),t._v(" 3.4 注解解析")]),t._v(" "),v("p",[t._v("注解的解析就是判断是否存在注解，存在注解就解析出内容。")]),t._v(" "),v("p",[v("strong",[t._v("与注解解析相关的接口")]),t._v("：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("Annotation")]),t._v(": 注解的顶级接口，注解都是Annotation类型的对象")]),t._v(" "),v("li",[v("code",[t._v("AnnotatedElement")]),t._v("：该接口定义了与注解解析相关的解析方法")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("Annotation[] getDeclaredAnnotations()")])]),t._v(" "),v("td",[t._v("获得当前对象上使用的所有注解，返回注解数组。")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("T getDeclaredAnnotation(Class<T> annotationClass)")])]),t._v(" "),v("td",[t._v("根据注解类型获得对应注解对象")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("boolean isAnnotationPresent(Class<Annotation> annotationClass)")])]),t._v(" "),v("td",[t._v("判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false")])])])]),t._v(" "),v("p",[t._v("所有的类成分 Class, Method , Field , Constructor，"),v("strong",[t._v("都实现了 AnnotatedElement 接口")]),t._v("，他们都拥有解析注解的能力")]),t._v(" "),v("p",[v("strong",[t._v("解析注解的技巧")]),t._v("：注解在哪个成分上，我们就先拿哪个成分对象")]),t._v(" "),v("ul",[v("li",[t._v("比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解")]),t._v(" "),v("li",[t._v("比如注解作用在类上，则要该类的Class对象，再来拿上面的注解")]),t._v(" "),v("li",[t._v("比如注解作用在成员变量上，则要获得该成员变量对应的Field对象，再来拿上面的注解")])]),t._v(" "),v("h3",{attrs:{id:"_3-5-注解的应用场景练习-junit"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-注解的应用场景练习-junit"}},[t._v("#")]),t._v(" 3.5 注解的应用场景练习：JUnit")]),t._v(" "),v("p",[v("strong",[t._v("需求")]),t._v("：定义若干个方法，只要加了 "),v("code",[t._v("MyTest")]),t._v(" 注解，就可以在启动时被触发执行")]),t._v(" "),v("p",[v("strong",[t._v("分析")])]),t._v(" "),v("ol",[v("li",[t._v("定义一个自定义注解 "),v("code",[t._v("MyTest")]),t._v("，只能注解方法，存活范围是一直都在。")]),t._v(" "),v("li",[t._v("定义若干个方法，只要有 "),v("code",[t._v("@MyTest")]),t._v(" 注解的方法就能在启动时被触发执行，没有这个注解的方法不能执行")])])])}),[],!1,null,null,null);_.default=e.exports}}]);