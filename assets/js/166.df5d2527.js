(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{919:function(t,s,a){"use strict";a.r(s);var n=a(22),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-string、stringbuffer、stringbuilder有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-string、stringbuffer、stringbuilder有什么区别"}},[t._v("#")]),t._v(" 1. String、StringBuffer、StringBuilder有什么区别？")]),t._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[t._v("Question")]),t._v(" "),a("p",[t._v("理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别？")])]),t._v(" "),a("h3",{attrs:{id:"_1-1-典型回答"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-典型回答"}},[t._v("#")]),t._v(" 1.1 典型回答")]),t._v(" "),a("p",[t._v("String 是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。")]),t._v(" "),a("p",[t._v("StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。"),a("strong",[t._v("StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销")]),t._v("，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。")]),t._v(" "),a("p",[t._v("StringBuilder 在能力上与 StringBuffer 没有本质区别，但 "),a("strong",[t._v("StringBuilder 去掉了线程安全部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"_1-2-考点分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-考点分析"}},[t._v("#")]),t._v(" 1.2 考点分析")]),t._v(" "),a("p",[t._v("理解字符串的设计和实现以及相关工具如拼接类的使用，对写出高质量代码是非常有帮助的。")]),t._v(" "),a("p",[t._v("要知道 String 是 Immutable 的，字符串操作不当可能会产生大量临时字符串，以及"),a("strong",[t._v("线程安全方面的区别")]),t._v("。")]),t._v(" "),a("p",[t._v("如果继续深入，面试官可以从各种不同的角度考察，比如可以：")]),t._v(" "),a("ul",[a("li",[t._v("通过 String 和相关类，考察基本的线程安全设计与实现，各种基础编程实践。")]),t._v(" "),a("li",[t._v("考察 JVM 对象缓存机制的理解以及如何良好地使用。")]),t._v(" "),a("li",[t._v("考察 JVM 优化 Java 代码的一些技巧。")]),t._v(" "),a("li",[t._v("String 相关类的演进，比如 Java 9 中实现的巨大变化。")]),t._v(" "),a("li",[t._v("...")])]),t._v(" "),a("h3",{attrs:{id:"_1-3-知识扩展"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-知识扩展"}},[t._v("#")]),t._v(" 1.3 知识扩展")]),t._v(" "),a("h4",{attrs:{id:"_1-3-1-字符串设计和实现考量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-字符串设计和实现考量"}},[t._v("#")]),t._v(" 1.3.1 字符串设计和实现考量")]),t._v(" "),a("p",[t._v("String 是 Immutable 类的典型实现，"),a("strong",[t._v("原生的保证了基础线程安全")]),t._v("，因为你无法对它内部数据进行任何修改。")]),t._v(" "),a("p",[t._v("我们再来看看 StringBuffer 实现的一些细节，"),a("strong",[t._v("它的线程安全是通过把各种修改数据的方法都加上 synchronized 关键字实现的")]),t._v("，非常直白。其实，这种简单粗暴的实现方式，"),a("strong",[t._v("非常适合我们常见的线程安全类实现")]),t._v("，不必纠结于 synchronized 性能之类的，有人说“过早优化是万恶之源”，考虑可靠性、正确性和代码可读性才是大多数应用开发最重要的因素。")]),t._v(" "),a("p",[t._v("为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。")]),t._v(" "),a("p",[t._v("另外，这个内部数组应该创建成多大的呢？目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。")]),t._v(" "),a("p",[t._v("在没有线程安全问题的情况下，全部拼接操作是应该都用 StringBuilder 实现吗？毕竟这样书写的代码，还是要多敲很多字的，可读性也不理想，下面的对比非常明显：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 StringBuilder")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" strByBuilder  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StringBuilder")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aa"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bb"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("append")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("append\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dd"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 +")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" strByConcat "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aa"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bb"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cc"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dd"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])]),a("p",[t._v("其实，在通常情况下，没有必要过于担心，要相信 Java 还是非常智能的。"),a("strong",[t._v("JDK 编译器会对字符串的拼接进行优化，所以怎样简单怎么来就行")]),t._v("。在日常编程中，保证程序的可读性、可维护性，往往比所谓的最优性能更重要，你可以根据实际需求酌情选择具体的编码方式。")]),t._v(" "),a("blockquote",[a("p",[t._v("你可以看一下 "),a("code",[t._v('String strByConcat = "aa" + "bb" + "cc" + "dd"')]),t._v(" 这一行代码在 JDK 编译器下编译的结果。JDK 8 中会自动转换成 StringBuilder，而 JDK 9 中对其更进一步优化，所以，"),a("strong",[t._v("不用担心性能啦")]),t._v("。")])]),t._v(" "),a("h4",{attrs:{id:"_1-3-2-字符串缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-2-字符串缓存"}},[t._v("#")]),t._v(" 1.3.2 字符串缓存")]),t._v(" "),a("p",[t._v("我们粗略统计过，把常见应用进行堆转储（Dump Heap），然后分析对象组成，"),a("strong",[t._v("会发现平均 25% 的对象是字符串，并且其中约半数是重复的")]),t._v("。如果能避免创建重复字符串，可以有效降低内存消耗和对象创建开销。")]),t._v(" "),a("p",[t._v("String 在 Java 6 以后提供了 "),a("strong",[t._v("intern() 方法")]),t._v("，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。")]),t._v(" "),a("p",[t._v("看起来很不错是吧？但实际情况估计会让你大跌眼镜。一般使用 Java 6 这种历史版本，"),a("strong",[t._v("并不推荐大量使用 intern")]),t._v("，为什么呢？魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。所以，如果使用不当，OOM 就会光顾。")]),t._v(" "),a("p",[t._v("在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。你可以使用下面的参数直接打印具体数字，可以拿自己的 JDK 立刻试验一下：")]),t._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("-XX:+PrintStringTableStatistics\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("你也可以使用下面的 JVM 参数 "),a("code",[t._v("-XX:StringTableSize=N")]),t._v(" 手动调整大小，但是绝大部分情况下并不需要调整，除非你确定它的大小已经影响了操作效率。")]),t._v(" "),a("p",[a("strong",[t._v("Intern 是一种显式地排重机制")]),t._v("，但是它也有一定的副作用，因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。注意这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：")]),t._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("-XX:+UseStringDeduplication\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("前面说到的几个方面，只是 Java 底层对字符串各种优化的一角，在运行时，字符串的一些基础操作会直接利用 JVM 内部的 Intrinsic 机制，往往运行的就是特殊优化的本地代码，而根本就不是 Java 代码生成的字节码。Intrinsic 可以简单理解为，是一种利用 native 方式 hard-coded 的逻辑，算是一种特别的内联，很多优化还是需要直接使用特定的 CPU 指令.")]),t._v(" "),a("p",[t._v("可以看出，仅仅是字符串一个实现，就需要 Java 平台工程师和科学家付出如此大且默默无闻的努力，我们得到的很多便利都是来源于此。如果感兴趣，可以继续深入学习。")]),t._v(" "),a("h4",{attrs:{id:"_1-3-3-string-自身的演化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-3-string-自身的演化"}},[t._v("#")]),t._v(" 1.3.3 String 自身的演化")]),t._v(" "),a("p",[t._v("如果你仔细观察过 Java 的字符串，"),a("strong",[t._v("在历史版本中，它是使用 char 数组来存数据的")]),t._v("，这样非常直接。但是 Java 中的 char 是两个 bytes 大小，拉丁语系语言的字符，根本就不需要太宽的 char，这样无区别的实现就造成了一定的浪费。密度是编程语言平台永恒的话题，因为归根结底绝大部分任务是要来操作数据的。")]),t._v(" "),a("p",[a("strong",[t._v("在 Java 9 中")]),t._v("，我们引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。"),a("strong",[t._v("将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder")]),t._v("，并且将相关字符串操作类都进行了修改。另外，所有相关的 Intrinsic 之类也都进行了重写，以保证没有任何性能损失。")]),t._v(" "),a("p",[t._v("虽然底层实现发生了这么大的改变，但是 Java 字符串的行为并没有任何大的变化，所以这个特性对于绝大部分应用来说是透明的，绝大部分情况不需要修改已有代码。在通用的性能测试和产品实验中，我们能非常明显地看到紧凑字符串带来的优势，即"),a("strong",[t._v("更小的内存占用、更快的操作速度")]),t._v("。")])])}),[],!1,null,null,null);s.default=r.exports}}]);