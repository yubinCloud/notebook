(window.webpackJsonp=window.webpackJsonp||[]).push([[316],{1081:function(a,t,s){"use strict";s.r(t);var n=s(22),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"_1-page-fault-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-page-fault-基础"}},[a._v("#")]),a._v(" 1. Page fault 基础")]),a._v(" "),s("p",[a._v("今天介绍 page fault，以及通过 page fault 可以实现的一系列虚拟内存的功能：")]),a._v(" "),s("ul",[s("li",[a._v("lazy allocation")]),a._v(" "),s("li",[a._v("copy-on-write fork")]),a._v(" "),s("li",[a._v("demand paging")]),a._v(" "),s("li",[a._v("memory mapped files")])]),a._v(" "),s("p",[a._v("几乎所有正经的 OS 都实现了这些功能，比如 Linux。但在 xv6 中，这些功能一个都没实现。一旦用户进程触发 page fault，那就会导致进程被杀掉，这是一个非常保守的处理方式。")]),a._v(" "),s("p",[a._v("这节课将探讨发生 page fault 时可以做的一些有趣的事情，这些功能也是后续的 lab 内容，我们将会花一些时间来研究他们。")]),a._v(" "),s("p",[a._v("在这之前，我们先回顾一下虚拟内存，它的两个主要优点是：")]),a._v(" "),s("ul",[s("li",[a._v("Isolation。提供了多个用户程序、内核空间与用户空间的隔离性。")]),a._v(" "),s("li",[a._v("level of indirection。处理器和所有指令都可以使用虚拟地址，而内核会定义从虚拟地址到物理地址的映射关系。这一层抽象是我们这节课要讨论的许多有趣功能的基础。")])]),a._v(" "),s("blockquote",[s("p",[a._v("在之前，xv6 中的内存地址映射很无聊，基本上都是直接映射（也就是 VA = PA）。")])]),a._v(" "),s("p",[a._v("之前我们介绍的内存地址映射相对来说比较静态，也就是 user page table 和 kernel page table 都在最开始就设置后，后面基本不做变动了。而 page fault 就让地址映射关系变得动态起来。"),s("strong",[a._v("通过 page fault，内核可以更新 page table，这是一个非常强大的功能")]),a._v("。")]),a._v(" "),s("p",[a._v("我们需要思考一下，"),s("strong",[a._v("当发生 page fault 时，内核需要什么样的信息才能够处理 page fault")]),a._v("？")]),a._v(" "),s("ul",[s("li",[s("u",[a._v("触发 page fault 的出错的虚拟地址")]),a._v("。当一个用户程序触发了 page fault 时，page fault 会使用 trap 机制将程序运行切换到内核，同时将出错的地址放到 "),s("strong",[a._v("STVAL 寄存器")]),a._v("中。")]),a._v(" "),s("li",[s("u",[a._v("出错的原因")]),a._v("。我们或许会想要对不同场景的 page fault 有不同的处理方式，比如 load 指令、store 指令、jump 指令等不同触发 page fault 的原因。RISC-V 文档介绍了，"),s("strong",[a._v("SCAUSE 寄存器")]),a._v("用来记录 trap 机制进入 supervisor mode 的原因，其中有 3 类原因是与 page fault 相关的，分别是执行、读、写指令导致的：12 表示因指令执行而引起的 page fault，13 表示因 load 指令而引起的 page fault，15 表示因 store 指令而引起的 page fault。")]),a._v(" "),s("li",[s("u",[a._v("触发 page fault 的指令的地址")]),a._v("。因为我们可能希望在修复 page fault 后能重新执行对应的指令。从上节课我们知道，作为 trap 处理代码的一部分，这个地址存放在 SEPC 寄存器中，并同时保存在 "),s("code",[a._v("trapframe->epc")]),a._v(" 中。")])]),a._v(" "),s("blockquote",[s("p",[a._v("在通过 ECALL 指令进入 supervisor mode 时，SCAUSE 寄存器中记录的值是 8")])]),a._v(" "),s("p",[a._v("所以，当出现 page fault 时，有 3 个对我们很重要的信息，分别是：")]),a._v(" "),s("ol",[s("li",[a._v("引起 page fault 的内存地址")]),a._v(" "),s("li",[a._v("引起 page fault 的原因类型")]),a._v(" "),s("li",[a._v("引起 page fault 时的程序计数器的值，这表明了 page fault 在用户空间发生的位置")])]),a._v(" "),s("p",[a._v("接下来我们看一下这些利用 page fault 而实现的不同机制，来帮助我们理解如何利用 page fault handler 修复 page table 并做一些有趣的事情。")]),a._v(" "),s("h2",{attrs:{id:"_2-lazy-page-allocation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-lazy-page-allocation"}},[a._v("#")]),a._v(" 2. Lazy page allocation")]),a._v(" "),s("h3",{attrs:{id:"_2-1-sbrk"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-sbrk"}},[a._v("#")]),a._v(" 2.1 sbrk")]),a._v(" "),s("p",[a._v("先来看一下内存的分配，也就是 "),s("strong",[a._v("sbrk")]),a._v(" 系统调用，它使得用户程序可以扩大自己的 heap。当一个应用程序启动的时候，"),s("strong",[a._v("sbrk 指向的是 heap 的最底端，同时也是 stack 的最顶端")]),a._v("。当调用 sbrk 时，传入一个整数参数，表示你想要申请的 heap 字节数，sbrk 会扩展 heap 的上边界。")]),a._v(" "),s("blockquote",[s("p",[a._v("在代码中，代表进程的数据结构中的 sz 字段就表示 sbrk 所指向的位置，即 "),s("code",[a._v("p->sz")]),a._v("。")])]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240203134839522.png",alt:"image-20240203134839522"}}),a._v(" "),s("p",[a._v("这意味着，"),s("strong",[a._v("当 sbrk 被调用时，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间里面，然后将内存内容初始化为 0，再返回给 sbrk 系统调用")]),a._v("。类似的，应用程序也可以给 sbrk 传入负数来减少它的地址空间。不过在这节课我们只关注增加内存的场景。")]),a._v(" "),s("h3",{attrs:{id:"_2-2-eager-allocation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-eager-allocation"}},[a._v("#")]),a._v(" 2.2 eager allocation")]),a._v(" "),s("p",[a._v("在 xv6 中，"),s("strong",[a._v("sbrk 的默认实现是 eager allocation")]),a._v("。也就是一旦调用 sbrk，内核会立刻分配应用程序所需要的物理内存。但实际上，应用程序很难预测自己需要多少内存，通常他会申请多于自己需要的内存，但在之后并不会使用这些内存。")]),a._v(" "),s("blockquote",[s("p",[a._v("比如一些矩阵运算，程序员会最大可能为矩阵分配内存，但实际的运算只在一个很小的矩阵上完成。所以，"),s("strong",[a._v("程序员过多申请内存的情况还挺常见的")]),a._v("。")])]),a._v(" "),s("h3",{attrs:{id:"_2-3-lazy-allocation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-lazy-allocation"}},[a._v("#")]),a._v(" 2.3 lazy allocation")]),a._v(" "),s("p",[a._v("eager allocation 并不是什么大问题，但是用虚拟内存和 page fault handler，我们完全可以实现 "),s("mark",[a._v("lazy allocation")]),a._v("。核心思想就是，sbrk 系统调用基本不做什么事情，只需要将 "),s("code",[a._v("p-sz")]),a._v(" 增大所需分配的内存空间，但内核并不会实际分配物理内存。在之后的某个时间点，当应用程序用到了新申请的那部分内存，由于 page table 中没有记录这块内存而会触发 page fault。所以，如果我们解析一个大于旧的 "),s("code",[a._v("p->sz")]),a._v(" 但又小于新的 "),s("code",[a._v("p->sz")]),a._v(" 的虚拟地址时，我们希望内核能够分配一个 page，并重新执行指令。")]),a._v(" "),s("p",[a._v("所以，"),s("strong",[a._v("实现思路就是")]),a._v("："),s("u",[a._v("当我们看到一个 page fault，相应的 VA 小于当前 "),s("code",[a._v("p->sz")]),a._v(" 但又大于 stack，那我们就知道这是一个来自于 heap 的地址，但内核还没有分配任何物理内存，所以这个 page fault 的处理方式很直接明了：在 page fault handler 中，通过 kalloc 函数分配一个内存 page，然后初始化这个 page 的内容为 0，将这个内存 page 映射到 user page table 中，最后重新执行指令")]),a._v("。在我们映射完新申请的物理内存 page 后，重新执行指令就应该可以通过了。")]),a._v(" "),s("p",[a._v("下面看一下为了实现 lazy allocation，代码应该会是什么样的。这也是今天唯一与编程相关的内容。")]),a._v(" "),s("p",[a._v("我们首先要修改的是 sys_sbrk 函数，sys_sbrk 原本会完成实际增加应用程序的地址空间，分配内存等等一系列相关的操作。但我们需要修改这个函数，让它只对 "),s("code",[a._v("p->sz")]),a._v(" 加 n，并不执行实际的增加内存的操作：")]),a._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[a._v("uint64\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sys_sbrk")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("argint")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&")]),a._v("n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  addr "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("myproc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("sz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// if(growproc(n) < 0)")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//   return -1;")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br")])]),s("p",[a._v("修改完之后启动 xv6 并执行 "),s("code",[a._v("echo hi")]),a._v("，那我们就会得到一个 page fault：")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240203142849582.png",alt:"image-20240203142849582"}}),a._v(" "),s("blockquote",[s("p",[a._v("这里会出现 page fault 的原因是，shell 需要 fork 出一个子进程，并通过 exec 执行 echo，而这个过程需要 shell 来申请一些内存，所以 shell 会调用 sys_sbrk，然后就出错了。")])]),a._v(" "),s("p",[a._v("上图的输出中包含了一些有趣的信息：")]),a._v(" "),s("ul",[s("li",[a._v("输出的 SCAUSE 寄存器内容是 15，表明这是一个 store page fault")]),a._v(" "),s("li",[a._v("这个 pid 是 3，这很可能是 shell 的 pid")]),a._v(" "),s("li",[a._v("可以看到出错的虚拟内存地址，也就是 STVAL 寄存器的值 0x4008")])]),a._v(" "),s("p",[a._v("以上就是 page fault 的信息，我们接下来看看如何能够聪明地处理这里的 page fault。")]),a._v(" "),s("p",[a._v("首先看一下 trap.c 中的 usertrap 函数中的这段代码：")]),a._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("r_scause")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// system call")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("p"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("killed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("exit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// sepc points to the ecall instruction,")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// but we want to return to the next instruction.")]),a._v("\n    p"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("trapframe"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("epc "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// an interrupt will change sstatus &c registers,")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// so don't enable until done with those registers.")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("intr_on")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("syscall")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("which_dev "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("devintr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ok")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"usertrap(): unexpected scause %p pid=%d\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("r_scause")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" p"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("pid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"            sepc=%p stval=%p\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("r_sepc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("r_stval")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    p"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v("killed "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br")])]),s("ul",[s("li",[a._v("这段代码检查 SCAUSE 寄存器的值，如果是 8 的话，就代表这次 trap 是一次 system call，如果不等于 8，就会接着检查是否有任何的设备中断，如果有的话处理相关的设备中断。如果两个条件都不满足，这里会打印一些信息，并且杀掉进程。")])]),a._v(" "),s("p",[a._v("我们在这里增加一个检查，判断 "),s("code",[a._v("SCAUSE == 15")]),a._v("，如果符合条件，我们需要一些定制化的处理来完成物理内存的分配。")]),a._v(" "),s("p",[a._v("这里以演示为目的展示一种处理方式：")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240203144906384.png",alt:"image-20240203144906384"}}),a._v(" "),s("p",[a._v("在上面的代码中，首先打印了一些调试信息，之后分配了一个物理内存 page，如果 ka 等于 0，表明没有物理内存，于是直接 OOM 了，我们就会直接杀掉进程。如果还有物理内存，先会将内存内容设置为 0，之后将物理内存 page 指向用户地址空间中合适的虚拟内存地址。具体来说，我们首先将虚拟地址向下取整，这里引起 page fault 的虚拟地址是 0x4008，向下取整之后是 0x4000。之后我们将物理内存地址跟取整之后的虚拟内存地址的关系加到 page table 中。对应的PTE需要设置常用的权限标志位，在这里是 u，w，r bit 位。")]),a._v(" "),s("p",[a._v("接下来运行这一部分代码，重新编译后执行 "),s("code",[a._v("echo hi")]),a._v("：")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240203145231164.png",alt:"image-20240203145231164"}}),a._v(" "),s("p",[a._v("不幸的是，这里并没有正常工作，这里出现了两个 page fault，第一个对应的虚拟内存地址是0x4008，但是很明显在处理这个page fault时，我们又有了另一个page fault 0x13f48。现在唯一的问题是，uvmunmap在报错，一些它尝试unmap的page并不存在。这里unmap的内存是什么？答案是，之前 lazy allocation 没有实际分配的内存在被 ummap 时会报错。所以对于这个内存，并没有对应的物理内存。所以在 uvmunmap 函数中，当PTE的 v 标志位为 0 并且没有对应的 mapping，这并不是一个实际的 panic，这是我们预期的行为。原先的 uvmunmap 函数如下：")]),a._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Remove npages of mappings starting from va. va must be")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// page-aligned. The mappings must exist.")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Optionally free the physical memory.")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("uvmunmap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("pagetable_t")]),a._v(" pagetable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" uint64 va"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" uint64 npages"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" do_free"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  uint64 a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("pte_t")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("pte"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("va "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),a._v(" PGSIZE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("panic")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"uvmunmap: not aligned"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" va"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" va "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" npages"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("PGSIZE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" PGSIZE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("pte "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("walk")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("pagetable"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("panic")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"uvmunmap: walk"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("pte "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&")]),a._v(" PTE_V"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("panic")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"uvmunmap: not mapped"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("PTE_FLAGS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("pte"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" PTE_V"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("panic")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"uvmunmap: not a leaf"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("do_free"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      uint64 pa "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("PTE2PA")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("pte"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("kfree")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("pa"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("pte "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br"),s("span",{staticClass:"line-number"},[a._v("24")]),s("br"),s("span",{staticClass:"line-number"},[a._v("25")]),s("br"),s("span",{staticClass:"line-number"},[a._v("26")]),s("br")])]),s("p",[a._v("所以实际上，对于这个 page 我们其实并不用做任何事情，我们可以直接 continue 跳到下一个 page：")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/1706944269977.png",alt:"1706944269977"}}),a._v(" "),s("p",[a._v("接下来再重新编译并执行：")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240203151627682.png",alt:"image-20240203151627682"}}),a._v(" "),s("p",[a._v("可以看到，这次有两个 page fault，但 "),s("code",[a._v("echo hi")]),a._v(" 正常工作了。现在，我们一定程度上有了最基本最简单的 lazy allocation。")]),a._v(" "),s("h2",{attrs:{id:"_3-zero-fill-on-demand"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-zero-fill-on-demand"}},[a._v("#")]),a._v(" 3. Zero Fill On Demand")]),a._v(" "),s("p",[a._v("另一个简单但使用很频繁的功能是 "),s("mark",[a._v("zero fill on demand")]),a._v("。")]),a._v(" "),s("p",[a._v("在一个用户程序的地址空间中，存在 text 区域、data 区域、BSS 区域，BSS 区域包含了未被初始化或者初始化为 0 的全局或静态变量，这些变量的内存中都是 0。")]),a._v(" "),s("p",[a._v("在一个正常的 OS 中，如果执行 exec，exec 会申请地址空间，里面会存放 text、data、BSS 等，BSS 里面保存了很多 page，这些 page 的内容都是 0。"),s("strong",[a._v("一个可以调优的地方是，对于这些内容全为 0 的 page，在物理内存中只分配一个 page，这个 page 的内容全是 0，然后将所有虚拟地址空间的全 0 的 page 都 map 到这一个物理 page 上，这样至少在程序启动时可以节省大量的物理内存分配")]),a._v("。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240203155631236.png",alt:"image-20240203155631236"}}),a._v(" "),s("p",[a._v("当然这里的 mapping 要非常小心，我们不能允许对于这个 page 执行写操作，因为所有的虚拟地址空间 page 都期望 page 内容全 0，所以这个 PTE 都是只读的。在之后的某个时间点，当应用程序尝试写 BSS 中的一个 page 时，会产生 page fault，那我们就应该在 page fault handler 中为其创建一个新的 page，并将其内容写为全 0，更新 mapping 后然后重新执行指令。")]),a._v(" "),s("p",[a._v("这种优化思想就类似于 lazy allocation。假如程序申请了一个大的数组，来保存可能的最大的输入，并且这个数组是全局变量且初始为 0。但是最后或许只有一小部分内容会被使用，那么这种优化会减少很多开销。")]),a._v(" "),s("p",[a._v("第二个好处是在 exec 中需要做的工作变少了。程序可以启动的更快，这样你可以获得更好的交互体验，因为你只需要分配一个内容全是 0 的物理 page。所有的虚拟 page 都可以映射到这一个物理 page 上。")]),a._v(" "),s("p",[a._v("但注意，page fault 也是具有开销的，一次由 page fault 而导致的 trap 就会涉及大量指令的运行。这些类似 lazy allocation 的方法会将很多开销推迟到了 page fault 发生时。")]),a._v(" "),s("h2",{attrs:{id:"_4-copy-on-write-fork"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-copy-on-write-fork"}},[a._v("#")]),a._v(" 4. Copy On Write Fork")]),a._v(" "),s("p",[a._v("这也是一个常见的优化：copy-on-write fork，也被称为 COW fork。")]),a._v(" "),s("p",[a._v("当 shell 处理命令时，它会 fork 一个子进程，这个子进程是 shell 进程的拷贝，子进程接着调用 exec 运行其他程序（比如 echo）。现在的情况是，fork 创建的地址空间的完整拷贝，会被 exec 立刻丢弃，取而代之的是一个包含了 echo 的地址空间。这看起来就很浪费。")]),a._v(" "),s("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20240203161217308.png",alt:"image-20240203161217308"}}),a._v(" "),s("p",[a._v("在物理内存中，xv6 的 shell 通常有 4 个 page，当调用 fork 后，会新创建 4 个 page，并将父进程 page 的内容拷贝到新创建的子进程的 page 中。但是，"),s("strong",[a._v("一旦调用了 exec，我们又会释放掉这些 page，并分配新的 page 来包含 echo 的内容")]),a._v("。所以，对于这个特定场景有一个非常有效的优化："),s("mark",[a._v("COW fork")]),a._v("："),s("u",[a._v("当我们创建子进程时，与其创建，分配并拷贝内容到新的物理内存，其实我们可以直接共享父进程的物理内存 page。所以这里，我们可以设置子进程的 PTE 指向父进程对应的物理内存 page。当子进程需要写 page 时，再为其创建新的物理内存 page 并修改 page table 的 mapping")]),a._v("。")]),a._v(" "),s("p",[s("strong",[a._v("实现的做法就是")]),a._v("：当 fork 时，将子进程的 PTE 都指向父进程对应的物理内存 page，"),s("strong",[a._v("同时父进程和子进程的 PTE 均设置为只读")]),a._v("，当有一方想要写入 page 时，会触发 page fault，内核就分配一个新的物理内存 page，并将原 page 的内容拷贝到新 page 中，然后更新 page table 的 mapping 关系，这样父进程和子进程的 PTE 都变成可读可写的了。之后再重新执行用户的指令就好了。")]),a._v(" "),s("blockquote",[s("p",[a._v("重新执行用户指令就是指调用 userret 函数，这也是之前介绍的返回到用户空间的方法。")])]),a._v(" "),s("p",[a._v("注意，内核为了识别是一个 copy-on-write 场景触发的 page fault，需要在 PTE 上增加一个 bit 来标识这是一个 copy-on-write page，否则内核无法识别这个 page fault 是一次错误的“向只读地址写入数据”还是 copy-on-write。几乎所有的 page table 硬件都支持这一点，这个多出来的 bit 标志位可以放在 PTE 的预留位中。")]),a._v(" "),s("p",[a._v("在copy-on-write lab中，还有个细节需要注意。目前在XV6中，除了trampoline page外，一个物理内存page只属于一个用户进程。trampoline page永远也不会释放，所以也不是什么大问题。但是对于这里的物理内存page，现在有多个用户进程或者说多个地址空间都指向了相同的物理内存page，举个例子，当父进程退出时我们需要更加的小心，因为我们要判断是否能立即释放相应的物理page。如果有子进程还在使用这些物理page，而内核又释放了这些物理page，我们将会出问题。那么现在释放内存page的依据是什么呢？")]),a._v(" "),s("p",[a._v("我们需要对于每一个物理内存page的引用进行计数，当我们释放虚拟page时，我们将物理内存page的引用数减1，如果引用数等于0，那么我们就能释放物理内存page。所以在copy-on-write lab中，你们需要引入一些额外的数据结构或者元数据信息来完成引用计数。")]),a._v(" "),s("h2",{attrs:{id:"_5-demand-paging"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-demand-paging"}},[a._v("#")]),a._v(" 5. Demand Paging")]),a._v(" "),s("p",[a._v("Demand Paging 也是一个很流行的功能，许多操作系统都实现了它。")]),a._v(" "),s("p",[a._v("在 exec 中，xv6 的默认行为是 OS 会加载程序内存的 text、data 区域，并且以 eager 的方式将这些区域加载进 page table。但是根据我们在 lazy allocation 和 zero-filled on demand 的经验，为什么我们要以 eager 的方式将程序加载到内存中呢？为什么不再等等，"),s("strong",[a._v("直到应用程序实际需要这些指令的时候再加载内存")]),a._v("？程序的二进制文件可能非常的巨大，将它全部从磁盘加载到内存中将会是一个代价很高的操作。又或者data区域的大小远大于常见的场景所需要的大小，我们并不一定需要将整个二进制都加载到内存中。")]),a._v(" "),s("p",[a._v("所以对于 exec，在虚拟地址空间中，"),s("strong",[a._v("我们为 text 和 data 分配好地址段，但是相应的 PTE 并不对应任何物理内存 page")]),a._v("。对于这些 PTE，我们只需要将 valid bit 位设置为 0。")]),a._v(" "),s("p",[a._v("按照这样修改 xv6 后，由于应用程序是从 0 地址开始运行，text 区域从地址 0 开始向上增长，所以"),s("strong",[a._v("位于地址 0 的指令是会触发第一个 page fault 的指令")]),a._v("。")]),a._v(" "),s("p",[s("strong",[a._v("如何处理这里的 page fault 呢")]),a._v("？"),s("u",[a._v("首先我们可以发现这个 page 是一个 on-demand page，我们需要在某个地方记录了这些 page 对应的程序文件，我们在 page fault handler 中需要从程序文件中读取 page 数据，加载到内存中，之后将内存 page 映射到 page table，最后再重新执行指令，程序就可以正常运行了")]),a._v("。")]),a._v(" "),s("p",[a._v("前面的流程还有点问题，对于 demand paging 来说，当发生 page fault 时，"),s("strong",[a._v("如果内存已经耗尽或者 OOM 了该怎么办")]),a._v("？")]),a._v(" "),s("p",[a._v("如果内存耗尽了，一种选择是撤回 page（"),s("strong",[a._v("evict page")]),a._v("）。比如说将这部分内存 page 中的内容写回到文件系统再撤回 page。一旦你撤回并释放了 page，那你就有了一个新的空闲 page，你就可以使用这个刚刚空闲出来的 page，分配给刚刚的 page fault handler，再重新执行指令。")]),a._v(" "),s("p",[a._v("以上就是常见 OS 的行为。这里的关键问题是，"),s("strong",[a._v("什么样的 page 可以被撤回")]),a._v("？"),s("strong",[a._v("并且该使用什么样的策略来撤回 page")]),a._v("？")]),a._v(" "),s("p",[a._v("最常见的策略就是 LRU（Least recently Used），但除此之外还有一个小优化，如果你要撤回一个 page，你需要在 dirty page 和 non-dirty page 中做出一个选择。如果你选择 dirty page，那么之后如果这个 page 再被修改，现在你或许需要对它写两次了（注，一次内存，一次文件），所以现实中往往选择 non-dirty page。"),s("u",[a._v("对于选中需要 evict 的 page，将其的内容写到文件中，再将相应的 PTE 标记为 non-valid，这就完成了所有的工作")]),a._v("。之后你可以在另一个 page table 重复使用这个 page，所以通常来说会优先选择 non-dirty page 来 evict。")]),a._v(" "),s("p",[a._v("在 PTE 的标志位中，专门有一个 dirty bit，当硬件向一个 page 写入数据的时候，会设置 dirty bit，之后操作系统就可以发现这个 page 曾经被写入过了。另外还有一个 access bit，任何一个 page 被读或者写了，这个 access bit 就会被置 1。在想实现 LRU 时，我们想知道在一定时间内没有被访问过的 page，就是靠的这个 access bit，当然，OS 也需要定期将一些 page 的 access bit 恢复为 0，表示可以 evict。")]),a._v(" "),s("blockquote",[s("p",[a._v("这里可以参考 CMU 15445 实验中的 replacer 的实现方式。")])]),a._v(" "),s("h2",{attrs:{id:"_6-memory-mapped-files"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-memory-mapped-files"}},[a._v("#")]),a._v(" 6. Memory Mapped Files")]),a._v(" "),s("p",[a._v("这也是后续的一个 lab，就是 memory mapped files。它的核心思想是："),s("strong",[a._v("将完整或部分文件加载到内存中，这样就可以通过内存地址相关的 load 或者 store 指令来操纵文件")]),a._v("。现代 OS 的 "),s("strong",[a._v("mmap")]),a._v(" 系统调用就是这个功能的实现。")]),a._v(" "),s("p",[a._v("mmap 系统调用会接收一个虚拟内存地址（VA），长度（len），protection，一些标志位，一个打开文件的文件描述符，和偏移量（offset）。这里的语义就是，从文件描述符对应的文件的偏移量的位置开始，映射长度为len的内容到虚拟内存地址VA，同时我们需要加上一些保护，比如只读或者读写。")]),a._v(" "),s("p",[a._v("假设文件内容是读写并且内核实现 mmap 的方式是 eager 方式（不过大部分系统都不会这么做），内核会从文件的 offset 位置开始，将数据拷贝到内存，设置好 PTE 指向物理内存的位置。之后应用程序就可以使用 load 或者 store 指令来修改内存中对应的文件内容。当完成操作之后，会有一个对应的unmap系统调用，参数是虚拟地址（VA），长度（len）。来表明应用程序已经完成了对文件的操作，在 unmap 时间点，我们需要将 dirty block 写回到文件中。我们可以很容易的找到哪些 block 是 dirty 的，因为它们在 PTE 中的 dirty bit 为 1。")]),a._v(" "),s("p",[a._v("当然，在任何聪明的内存管理机制中，所有的这些都是以lazy的方式实现。你不会立即将文件内容拷贝到内存中，而是先记录一下这个PTE属于这个文件描述符。相应的信息通常在VMA结构体中保存，VMA全称是Virtual Memory Area。例如对于这里的文件f，会有一个VMA，在VMA中我们会记录文件描述符，偏移量等等，这些信息用来表示对应的内存虚拟地址的实际内容在哪，这样当我们得到一个位于VMA地址范围的page fault时，内核可以从磁盘中读数据，并加载到内存中。所以这里回答之前一个问题，dirty bit是很重要的，因为在unmap中，你需要向文件回写dirty block。")]),a._v(" "),s("blockquote",[s("p",[a._v("Question: 有没有可能多个进程将同一个文件映射到内存，然后会有同步的问题？")]),a._v(" "),s("p",[a._v("Answer: 这个问题其实等价于，多个进程同时通过read/write系统调用读写一个文件会怎么样？这里的行为是不可预知的。write系统调用会以某种顺序出现，如果两个进程向一个文件的block写数据，要么第一个进程的write能生效，要么第二个进程的write能生效，只能是两者之一生效。在这里其实也是一样的，所以我们并不需要考虑冲突的问题。一个更加成熟的Unix操作系统支持锁定文件，你可以先锁定文件，这样就能保证数据同步。但是默认情况下，并没有同步保证。")])]),a._v(" "),s("h2",{attrs:{id:"_7-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-总结"}},[a._v("#")]),a._v(" 7. 总结")]),a._v(" "),s("p",[a._v("总结一下最近几节课的内容。我们首先看了 page table 是如何工作的，之后又详细看了一下 trap 是如何工作的，而 page fault 结合了这两部分内容，可以用来实现非常强大且优雅的虚拟内存功能。")]),a._v(" "),s("p",[a._v("这节课介绍的内容只是 OS 基于 page fault 功能的子集，一个典型的 OS 实现了今天讨论的所有内容，如果你查看 Linux，它就包含了所有的内容，以及许多其他有趣的功能。今天的内容是希望你理解，一个你可以在 page fault handler 中动态更新 page table，虚拟内存将会变得有多强大。")])])}),[],!1,null,null,null);t.default=e.exports}}]);